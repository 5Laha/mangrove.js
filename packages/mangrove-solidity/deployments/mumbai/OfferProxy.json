{
  "address": "0x4fB36159a84fce9098dd9117695ef48a74D496EB",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_addressesProvider",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "_MgvReader",
          "type": "address"
        },
        {
          "internalType": "address payable",
          "name": "_MGV",
          "type": "address"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "outbound_tkn",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "inbound_tkn",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "offerId",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "string",
          "name": "errorCode",
          "type": "string"
        }
      ],
      "name": "ErrorOnMint",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "outbound_tkn",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "inbound_tkn",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "offerId",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "string",
          "name": "errorCode",
          "type": "string"
        }
      ],
      "name": "ErrorOnRedeem",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "outbound_tkn",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "inbound_tkn",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "offerId",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "missingAmount",
          "type": "uint256"
        }
      ],
      "name": "GetFail",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "outbound_tkn",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "inbound_tkn",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "offerId",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "owner",
          "type": "address"
        }
      ],
      "name": "NewOffer",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "outbound_tkn",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "inbound_tkn",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "offerId",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "string",
          "name": "message",
          "type": "string"
        }
      ],
      "name": "PosthookFail",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "outbound_tkn",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "inbound_tkn",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "offerId",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "missingAmount",
          "type": "uint256"
        }
      ],
      "name": "PutFail",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "outbound_tkn",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "inbound_tkn",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "offerId",
          "type": "uint256"
        }
      ],
      "name": "Reneged",
      "type": "event"
    },
    {
      "inputs": [],
      "name": "MGV",
      "outputs": [
        {
          "internalType": "contract Mangrove",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "OFR_GASREQ",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "admin",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "token",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        }
      ],
      "name": "approveLender",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "outbound_tkn",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        }
      ],
      "name": "approveMangrove",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "fundMangrove",
      "outputs": [],
      "stateMutability": "payable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "outbound_tkn",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "inbound_tkn",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "gasreq",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "gasprice",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "offerId",
          "type": "uint256"
        }
      ],
      "name": "getMissingProvision",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "lendingPool",
      "outputs": [
        {
          "internalType": "contract ILendingPool",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "address",
              "name": "outbound_tkn",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "inbound_tkn",
              "type": "address"
            },
            {
              "internalType": "uint256",
              "name": "offerId",
              "type": "uint256"
            },
            {
              "internalType": "Offer.t",
              "name": "offer",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "wants",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "gives",
              "type": "uint256"
            },
            {
              "internalType": "OfferDetail.t",
              "name": "offerDetail",
              "type": "uint256"
            },
            {
              "internalType": "Global.t",
              "name": "global",
              "type": "uint256"
            },
            {
              "internalType": "Local.t",
              "name": "local",
              "type": "uint256"
            }
          ],
          "internalType": "struct MgvLib.SingleOrder",
          "name": "order",
          "type": "tuple"
        }
      ],
      "name": "makerExecute",
      "outputs": [
        {
          "internalType": "bytes32",
          "name": "ret",
          "type": "bytes32"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "address",
              "name": "outbound_tkn",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "inbound_tkn",
              "type": "address"
            },
            {
              "internalType": "uint256",
              "name": "offerId",
              "type": "uint256"
            },
            {
              "internalType": "Offer.t",
              "name": "offer",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "wants",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "gives",
              "type": "uint256"
            },
            {
              "internalType": "OfferDetail.t",
              "name": "offerDetail",
              "type": "uint256"
            },
            {
              "internalType": "Global.t",
              "name": "global",
              "type": "uint256"
            },
            {
              "internalType": "Local.t",
              "name": "local",
              "type": "uint256"
            }
          ],
          "internalType": "struct MgvLib.SingleOrder",
          "name": "order",
          "type": "tuple"
        },
        {
          "components": [
            {
              "internalType": "bytes32",
              "name": "makerData",
              "type": "bytes32"
            },
            {
              "internalType": "bytes32",
              "name": "mgvData",
              "type": "bytes32"
            }
          ],
          "internalType": "struct MgvLib.OrderResult",
          "name": "result",
          "type": "tuple"
        }
      ],
      "name": "makerPosthook",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "asset",
          "type": "address"
        },
        {
          "internalType": "bool",
          "name": "tryBorrow",
          "type": "bool"
        },
        {
          "internalType": "address",
          "name": "onBehalf",
          "type": "address"
        }
      ],
      "name": "maxGettableUnderlying",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "name": "mgvBalanceOf",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "outbound_tkn",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "inbound_tkn",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "wants",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "gives",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "gasreq",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "gasprice",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "pivotId",
          "type": "uint256"
        }
      ],
      "name": "newOffer",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "offerId",
          "type": "uint256"
        }
      ],
      "stateMutability": "payable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "outbound_tkn",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "inbound_tkn",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "fromId",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "maxOffers",
          "type": "uint256"
        }
      ],
      "name": "offerOwners",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "nextId",
          "type": "uint256"
        },
        {
          "internalType": "uint256[]",
          "name": "offerIds",
          "type": "uint256[]"
        },
        {
          "internalType": "address[]",
          "name": "__offerOwners",
          "type": "address[]"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "contract IERC20",
          "name": "asset",
          "type": "address"
        }
      ],
      "name": "overlying",
      "outputs": [
        {
          "internalType": "contract IERC20",
          "name": "aToken",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "outbound_tkn",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "inbound_tkn",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "offerId",
          "type": "uint256"
        }
      ],
      "name": "ownerOf",
      "outputs": [
        {
          "internalType": "address",
          "name": "owner",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "priceOracle",
      "outputs": [
        {
          "internalType": "contract IPriceOracleGetter",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "token",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        }
      ],
      "name": "redeemToken",
      "outputs": [
        {
          "internalType": "bool",
          "name": "success",
          "type": "bool"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "outbound_tkn",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "inbound_tkn",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "offerId",
          "type": "uint256"
        },
        {
          "internalType": "bool",
          "name": "deprovision",
          "type": "bool"
        }
      ],
      "name": "retractOffer",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "received",
          "type": "uint256"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_admin",
          "type": "address"
        }
      ],
      "name": "setAdmin",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "gasreq",
          "type": "uint256"
        }
      ],
      "name": "setGasreq",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "name": "tokenBalanceOf",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "recipient",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        }
      ],
      "name": "transferETH",
      "outputs": [
        {
          "internalType": "bool",
          "name": "success",
          "type": "bool"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "outbound_tkn",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "inbound_tkn",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "wants",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "gives",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "gasreq",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "gasprice",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "pivotId",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "offerId",
          "type": "uint256"
        }
      ],
      "name": "updateOffer",
      "outputs": [],
      "stateMutability": "payable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "receiver",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        }
      ],
      "name": "withdrawFromMangrove",
      "outputs": [
        {
          "internalType": "bool",
          "name": "noRevert",
          "type": "bool"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    }
  ],
  "transactionHash": "0x09b585abd0b26a1a4c3a78584335d0902f3442993a06aaea7a66a9bd7382a8cb",
  "receipt": {
    "to": null,
    "from": "0x47897EE61498D02B18794601Ed3A71896A1Ff894",
    "contractAddress": "0x4fB36159a84fce9098dd9117695ef48a74D496EB",
    "transactionIndex": 0,
    "gasUsed": "3508615",
    "logsBloom": "0x00000000000000020000000000000000000000000000000000000000000000000000000000040000000000000000000000008000000000000000000000000000000000020000000000000000000000800000000000000000100100000000000000000000000000000000000000000000000000000000000080000000000000000000000000000000000000000000000000000000000000000000000000000000200000000000000020000000000000000001000000000000000000000000004000000000000000000001000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000000000000100000",
    "blockHash": "0x5a6c9991118eca4a8abf53a7ed91885e3bbd405813cbb5c4f5d1b06a2328e909",
    "transactionHash": "0x09b585abd0b26a1a4c3a78584335d0902f3442993a06aaea7a66a9bd7382a8cb",
    "logs": [
      {
        "transactionIndex": 0,
        "blockNumber": 23600576,
        "transactionHash": "0x09b585abd0b26a1a4c3a78584335d0902f3442993a06aaea7a66a9bd7382a8cb",
        "address": "0x0000000000000000000000000000000000001010",
        "topics": [
          "0x4dfe1bbbcf077ddc3e01291eea2d5c70c2b422b415d95645b9adcfd678cb1d63",
          "0x0000000000000000000000000000000000000000000000000000000000001010",
          "0x00000000000000000000000047897ee61498d02b18794601ed3a71896a1ff894",
          "0x000000000000000000000000c26880a0af2ea0c7e8130e6ec47af756465452e8"
        ],
        "data": "0x0000000000000000000000000000000000000000000000000175f400a82f67c80000000000000000000000000000000000000000000000000bcbeb0e02e025b800000000000000000000000000000000000000000000044495e3af11188bf93c0000000000000000000000000000000000000000000000000a55f70d5ab0bdf00000000000000000000000000000000000000000000004449759a311c0bb6104",
        "logIndex": 0,
        "blockHash": "0x5a6c9991118eca4a8abf53a7ed91885e3bbd405813cbb5c4f5d1b06a2328e909"
      }
    ],
    "blockNumber": 23600576,
    "cumulativeGasUsed": "3508615",
    "status": 1,
    "byzantium": true
  },
  "args": [
    "0x178113104fEcbcD7fF8669a0150721e231F0FD4B",
    "0xa1e2f6EEe41799d44e365135F70fD23b0d0505D6",
    "0xD27139C60ED051b65c3AEe193BCABFfa1067D243"
  ],
  "solcInputHash": "dca7e022ec1acab3066ffde621761c1e",
  "metadata": "{\"compiler\":{\"version\":\"0.8.10+commit.fc410830\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addressesProvider\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_MgvReader\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"_MGV\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"outbound_tkn\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"inbound_tkn\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"offerId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"errorCode\",\"type\":\"string\"}],\"name\":\"ErrorOnMint\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"outbound_tkn\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"inbound_tkn\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"offerId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"errorCode\",\"type\":\"string\"}],\"name\":\"ErrorOnRedeem\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"outbound_tkn\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"inbound_tkn\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"offerId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"missingAmount\",\"type\":\"uint256\"}],\"name\":\"GetFail\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"outbound_tkn\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"inbound_tkn\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"offerId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"NewOffer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"outbound_tkn\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"inbound_tkn\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"offerId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"message\",\"type\":\"string\"}],\"name\":\"PosthookFail\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"outbound_tkn\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"inbound_tkn\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"offerId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"missingAmount\",\"type\":\"uint256\"}],\"name\":\"PutFail\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"outbound_tkn\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"inbound_tkn\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"offerId\",\"type\":\"uint256\"}],\"name\":\"Reneged\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"MGV\",\"outputs\":[{\"internalType\":\"contract Mangrove\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"OFR_GASREQ\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"admin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approveLender\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"outbound_tkn\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approveMangrove\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"fundMangrove\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"outbound_tkn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"inbound_tkn\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"gasreq\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"gasprice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"offerId\",\"type\":\"uint256\"}],\"name\":\"getMissingProvision\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lendingPool\",\"outputs\":[{\"internalType\":\"contract ILendingPool\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"outbound_tkn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"inbound_tkn\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"offerId\",\"type\":\"uint256\"},{\"internalType\":\"Offer.t\",\"name\":\"offer\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"wants\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"gives\",\"type\":\"uint256\"},{\"internalType\":\"OfferDetail.t\",\"name\":\"offerDetail\",\"type\":\"uint256\"},{\"internalType\":\"Global.t\",\"name\":\"global\",\"type\":\"uint256\"},{\"internalType\":\"Local.t\",\"name\":\"local\",\"type\":\"uint256\"}],\"internalType\":\"struct MgvLib.SingleOrder\",\"name\":\"order\",\"type\":\"tuple\"}],\"name\":\"makerExecute\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"ret\",\"type\":\"bytes32\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"outbound_tkn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"inbound_tkn\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"offerId\",\"type\":\"uint256\"},{\"internalType\":\"Offer.t\",\"name\":\"offer\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"wants\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"gives\",\"type\":\"uint256\"},{\"internalType\":\"OfferDetail.t\",\"name\":\"offerDetail\",\"type\":\"uint256\"},{\"internalType\":\"Global.t\",\"name\":\"global\",\"type\":\"uint256\"},{\"internalType\":\"Local.t\",\"name\":\"local\",\"type\":\"uint256\"}],\"internalType\":\"struct MgvLib.SingleOrder\",\"name\":\"order\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"makerData\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"mgvData\",\"type\":\"bytes32\"}],\"internalType\":\"struct MgvLib.OrderResult\",\"name\":\"result\",\"type\":\"tuple\"}],\"name\":\"makerPosthook\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"tryBorrow\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"onBehalf\",\"type\":\"address\"}],\"name\":\"maxGettableUnderlying\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"mgvBalanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"outbound_tkn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"inbound_tkn\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"wants\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"gives\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"gasreq\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"gasprice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"pivotId\",\"type\":\"uint256\"}],\"name\":\"newOffer\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"offerId\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"outbound_tkn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"inbound_tkn\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"fromId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxOffers\",\"type\":\"uint256\"}],\"name\":\"offerOwners\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"nextId\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"offerIds\",\"type\":\"uint256[]\"},{\"internalType\":\"address[]\",\"name\":\"__offerOwners\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"asset\",\"type\":\"address\"}],\"name\":\"overlying\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"aToken\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"outbound_tkn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"inbound_tkn\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"offerId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"priceOracle\",\"outputs\":[{\"internalType\":\"contract IPriceOracleGetter\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"redeemToken\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"outbound_tkn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"inbound_tkn\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"offerId\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"deprovision\",\"type\":\"bool\"}],\"name\":\"retractOffer\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"received\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_admin\",\"type\":\"address\"}],\"name\":\"setAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"gasreq\",\"type\":\"uint256\"}],\"name\":\"setGasreq\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"tokenBalanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferETH\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"outbound_tkn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"inbound_tkn\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"wants\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"gives\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"gasreq\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"gasprice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"pivotId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"offerId\",\"type\":\"uint256\"}],\"name\":\"updateOffer\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdrawFromMangrove\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"noRevert\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"events\":{\"PosthookFail(address,address,uint256,string)\":{\"notice\":\"Events \"}},\"kind\":\"user\",\"methods\":{\"approveLender(address,uint256)\":{\"notice\":\"approval of ctoken contract by the underlying is necessary for minting and repaying borrowuser must use this function to do so.\"},\"approveMangrove(address,uint256)\":{\"notice\":\"trader needs to approve Mangrove to let it perform outbound token transfer at the end of the `makerExecute` function Warning: anyone can approve here.\"},\"maxGettableUnderlying(address,bool,address)\":{\"notice\":\"Computes maximal maximal redeem capacity (R) and max borrow capacity (B|R) after R has been redeemed returns (R, B|R)\"},\"withdrawFromMangrove(address,uint256)\":{\"notice\":\"withdraws ETH from the bounty vault of the Mangrove. NB: `Mangrove.fund` function need not be called by `this` so is not included here. Warning: this function should not be called internally for msg.sender provision is being checked\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/Strategies/OfferLogics/MultiUsers/Deployable/OfferProxy.sol\":\"OfferProxy\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":20000},\"remappings\":[]},\"sources\":{\"contracts/AbstractMangrove.sol\":{\"content\":\"// SPDX-License-Identifier:\\tAGPL-3.0\\n\\n// AbstractMangrove.sol\\n\\n// Copyright (C) 2021 Giry SAS.\\n//\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU Affero General Public License as published\\n// by the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n//\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU Affero General Public License for more details.\\n//\\n// You should have received a copy of the GNU Affero General Public License\\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\\npragma solidity ^0.8.10;\\npragma abicoder v2;\\nimport {MgvLib as ML} from \\\"./MgvLib.sol\\\";\\n\\nimport {MgvOfferMaking} from \\\"./MgvOfferMaking.sol\\\";\\nimport {MgvOfferTakingWithPermit} from \\\"./MgvOfferTakingWithPermit.sol\\\";\\nimport {MgvGovernable} from \\\"./MgvGovernable.sol\\\";\\n\\n/* `AbstractMangrove` inherits the three contracts that implement generic Mangrove functionality (`MgvGovernable`,`MgvOfferTakingWithPermit` and `MgvOfferMaking`) but does not implement the abstract functions. */\\nabstract contract AbstractMangrove is\\n  MgvGovernable,\\n  MgvOfferTakingWithPermit,\\n  MgvOfferMaking\\n{\\n  constructor(\\n    address governance,\\n    uint gasprice,\\n    uint gasmax,\\n    string memory contractName\\n  )\\n    MgvOfferTakingWithPermit(contractName)\\n    MgvGovernable(governance, gasprice, gasmax)\\n  {}\\n}\\n\",\"keccak256\":\"0x11f25da752f9e424c3ad0455936300515658d795106f0493bdca70139b4c82b2\",\"license\":\"AGPL-3.0\"},\"contracts/IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: Unlicense\\n\\n// IERC20.sol\\n\\n// This is free and unencumbered software released into the public domain.\\n\\n// Anyone is free to copy, modify, publish, use, compile, sell, or distribute this software, either in source code form or as a compiled binary, for any purpose, commercial or non-commercial, and by any means.\\n\\n// In jurisdictions that recognize copyright laws, the author or authors of this software dedicate any and all copyright interest in the software to the public domain. We make this dedication for the benefit of the public at large and to the detriment of our heirs and successors. We intend this dedication to be an overt act of relinquishment in perpetuity of all present and future rights to this software under copyright law.\\n\\n// THE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\\n\\n// For more information, please refer to <https://unlicense.org/>\\n\\n/* `MgvLib` contains data structures returned by external calls to Mangrove and the interfaces it uses for its own external calls. */\\n\\npragma solidity ^0.8.10;\\npragma abicoder v2;\\n\\ninterface IERC20 {\\n  function totalSupply() external view returns (uint);\\n\\n  function balanceOf(address account) external view returns (uint);\\n\\n  function transfer(address recipient, uint amount) external returns (bool);\\n\\n  function allowance(address owner, address spender)\\n    external\\n    view\\n    returns (uint);\\n\\n  function approve(address spender, uint amount) external returns (bool);\\n\\n  function transferFrom(\\n    address sender,\\n    address recipient,\\n    uint amount\\n  ) external returns (bool);\\n\\n  function symbol() external view returns (string memory);\\n\\n  event Transfer(address indexed from, address indexed to, uint value);\\n  event Approval(address indexed owner, address indexed spender, uint value);\\n\\n  /// for wETH contract\\n  function deposit() external payable;\\n\\n  function withdraw(uint) external;\\n\\n  function decimals() external view returns (uint8);\\n}\\n\",\"keccak256\":\"0xad0b3300c8afaba6562a533107fa9175dcecf13c0bebe24f05a84576eb80a5e6\",\"license\":\"Unlicense\"},\"contracts/Mangrove.sol\":{\"content\":\"// SPDX-License-Identifier:\\tAGPL-3.0\\n\\n// Mangrove.sol\\n\\n// Copyright (C) 2021 Giry SAS.\\n//\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU Affero General Public License as published\\n// by the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n//\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU Affero General Public License for more details.\\n//\\n// You should have received a copy of the GNU Affero General Public License\\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\\npragma solidity ^0.8.10;\\npragma abicoder v2;\\nimport {MgvLib as ML, P} from \\\"./MgvLib.sol\\\";\\n\\nimport {AbstractMangrove} from \\\"./AbstractMangrove.sol\\\";\\n\\n/* <a id=\\\"Mangrove\\\"></a> The `Mangrove` contract implements the \\\"normal\\\" version of Mangrove, where the taker flashloans the desired amount to each maker. Each time, makers are called after the loan. When the order is complete, each maker is called once again (with the orderbook unlocked). */\\ncontract Mangrove is AbstractMangrove {\\n  using P.OfferDetail for P.OfferDetail.t;\\n\\n  constructor(\\n    address governance,\\n    uint gasprice,\\n    uint gasmax\\n  ) AbstractMangrove(governance, gasprice, gasmax, \\\"Mangrove\\\") {}\\n\\n  function executeEnd(MultiOrder memory mor, ML.SingleOrder memory sor)\\n    internal\\n    override\\n  {}\\n\\n  function beforePosthook(ML.SingleOrder memory sor) internal override {}\\n\\n  /* ## Flashloan */\\n  /*\\n     `flashloan` is for the 'normal' mode of operation. It:\\n     1. Flashloans `takerGives` `inbound_tkn` from the taker to the maker and returns false if the loan fails.\\n     2. Runs `offerDetail.maker`'s `execute` function.\\n     3. Returns the result of the operations, with optional makerData to help the maker debug.\\n   */\\n  function flashloan(ML.SingleOrder calldata sor, address taker)\\n    external\\n    override\\n    returns (uint gasused)\\n  { unchecked {\\n    /* `flashloan` must be used with a call (hence the `external` modifier) so its effect can be reverted. But a call from the outside would be fatal. */\\n    require(msg.sender == address(this), \\\"mgv/flashloan/protected\\\");\\n    /* The transfer taker -> maker is in 2 steps. First, taker->mgv. Then\\n       mgv->maker. With a direct taker->maker transfer, if one of taker/maker\\n       is blacklisted, we can't tell which one. We need to know which one:\\n       if we incorrectly blame the taker, a blacklisted maker can block a pair forever; if we incorrectly blame the maker, a blacklisted taker can unfairly make makers fail all the time. Of course we assume the Mangrove is not blacklisted. Also note that this setup doesn't not work well with tokens that take fees or recompute balances at transfer time. */\\n    if (transferTokenFrom(sor.inbound_tkn, taker, address(this), sor.gives)) {\\n      if (\\n        transferToken(\\n          sor.inbound_tkn,\\n          sor.offerDetail.maker(),\\n          sor.gives\\n        )\\n      ) {\\n        gasused = makerExecute(sor);\\n      } else {\\n        innerRevert([bytes32(\\\"mgv/makerReceiveFail\\\"), bytes32(0), \\\"\\\"]);\\n      }\\n    } else {\\n      innerRevert([bytes32(\\\"mgv/takerTransferFail\\\"), \\\"\\\", \\\"\\\"]);\\n    }\\n  }}\\n}\\n\",\"keccak256\":\"0xb3aa9775349ee7cd240cdcd7243f7f942ae61cac15c21651abf541157499b62e\",\"license\":\"AGPL-3.0\"},\"contracts/MgvGovernable.sol\":{\"content\":\"// SPDX-License-Identifier:\\tAGPL-3.0\\n\\n// MgvGovernable.sol\\n\\n// Copyright (C) 2021 Giry SAS.\\n//\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU Affero General Public License as published\\n// by the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n//\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU Affero General Public License for more details.\\n//\\n// You should have received a copy of the GNU Affero General Public License\\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\\npragma solidity ^0.8.10;\\npragma abicoder v2;\\nimport {HasMgvEvents, P} from \\\"./MgvLib.sol\\\";\\nimport {MgvRoot} from \\\"./MgvRoot.sol\\\";\\n\\ncontract MgvGovernable is MgvRoot {\\n  // using P.Offer for P.Offer.t;\\n  // using P.OfferDetail for P.OfferDetail.t;\\n  using P.Global for P.Global.t;\\n  using P.Local for P.Local.t;\\n  /* The `governance` address. Governance is the only address that can configure parameters. */\\n  address public governance;\\n\\n  constructor(\\n    address _governance,\\n    uint _gasprice,\\n    uint gasmax\\n  ) MgvRoot() { unchecked {\\n    emit NewMgv();\\n\\n    /* Initially, governance is open to anyone. */\\n\\n    /* Initialize vault to governance address, and set initial gasprice and gasmax. */\\n    setVault(_governance);\\n    setGasprice(_gasprice);\\n    setGasmax(gasmax);\\n    /* Initialize governance to `_governance` after parameter setting. */\\n    setGovernance(_governance);\\n  }}\\n\\n  /* ## `authOnly` check */\\n\\n  function authOnly() internal view { unchecked {\\n    require(\\n      msg.sender == governance ||\\n        msg.sender == address(this) ||\\n        governance == address(0),\\n      \\\"mgv/unauthorized\\\"\\n    );\\n  }}\\n\\n  /* # Set configuration and Mangrove state */\\n\\n  /* ## Locals */\\n  /* ### `active` */\\n  function activate(\\n    address outbound_tkn,\\n    address inbound_tkn,\\n    uint fee,\\n    uint density,\\n    uint offer_gasbase\\n  ) public { unchecked {\\n    authOnly();\\n    locals[outbound_tkn][inbound_tkn] = locals[outbound_tkn][inbound_tkn].active(true);\\n    emit SetActive(outbound_tkn, inbound_tkn, true);\\n    setFee(outbound_tkn, inbound_tkn, fee);\\n    setDensity(outbound_tkn, inbound_tkn, density);\\n    setGasbase(outbound_tkn, inbound_tkn, offer_gasbase);\\n  }}\\n\\n  function deactivate(address outbound_tkn, address inbound_tkn) public {\\n    authOnly();\\n    locals[outbound_tkn][inbound_tkn] = locals[outbound_tkn][inbound_tkn].active(false);\\n    emit SetActive(outbound_tkn, inbound_tkn, false);\\n  }\\n\\n  /* ### `fee` */\\n  function setFee(\\n    address outbound_tkn,\\n    address inbound_tkn,\\n    uint fee\\n  ) public { unchecked {\\n    authOnly();\\n    /* `fee` is in basis points, i.e. in percents of a percent. */\\n    require(fee <= 500, \\\"mgv/config/fee/<=500\\\"); // at most 5%\\n    locals[outbound_tkn][inbound_tkn] = locals[outbound_tkn][inbound_tkn].fee(fee);\\n    emit SetFee(outbound_tkn, inbound_tkn, fee);\\n  }}\\n\\n  /* ### `density` */\\n  /* Useless if `global.useOracle != 0` */\\n  function setDensity(\\n    address outbound_tkn,\\n    address inbound_tkn,\\n    uint density\\n  ) public { unchecked {\\n    authOnly();\\n\\n    require(checkDensity(density), \\\"mgv/config/density/112bits\\\");\\n    //+clear+\\n    locals[outbound_tkn][inbound_tkn] = locals[outbound_tkn][inbound_tkn].density(density);\\n    emit SetDensity(outbound_tkn, inbound_tkn, density);\\n  }}\\n\\n  /* ### `gasbase` */\\n  function setGasbase(\\n    address outbound_tkn,\\n    address inbound_tkn,\\n    uint offer_gasbase\\n  ) public { unchecked {\\n    authOnly();\\n    /* Checking the size of `offer_gasbase` is necessary to prevent a) data loss when copied to an `OfferDetail` struct, and b) overflow when used in calculations. */\\n    require(\\n      uint24(offer_gasbase) == offer_gasbase,\\n      \\\"mgv/config/offer_gasbase/24bits\\\"\\n    );\\n    //+clear+\\n    locals[outbound_tkn][inbound_tkn] = locals[outbound_tkn][inbound_tkn].offer_gasbase(offer_gasbase);\\n    emit SetGasbase(outbound_tkn, inbound_tkn, offer_gasbase);\\n  }}\\n\\n  /* ## Globals */\\n  /* ### `kill` */\\n  function kill() public { unchecked {\\n    authOnly();\\n    internal_global = internal_global.dead(true);\\n    emit Kill();\\n  }}\\n\\n  /* ### `gasprice` */\\n  /* Useless if `global.useOracle is != 0` */\\n  function setGasprice(uint gasprice) public { unchecked {\\n    authOnly();\\n    require(checkGasprice(gasprice), \\\"mgv/config/gasprice/16bits\\\");\\n\\n    //+clear+\\n\\n    internal_global = internal_global.gasprice(gasprice);\\n    emit SetGasprice(gasprice);\\n  }}\\n\\n  /* ### `gasmax` */\\n  function setGasmax(uint gasmax) public { unchecked {\\n    authOnly();\\n    /* Since any new `gasreq` is bounded above by `config.gasmax`, this check implies that all offers' `gasreq` is 24 bits wide at most. */\\n    require(uint24(gasmax) == gasmax, \\\"mgv/config/gasmax/24bits\\\");\\n    //+clear+\\n    internal_global = internal_global.gasmax(gasmax);\\n    emit SetGasmax(gasmax);\\n  }}\\n\\n  /* ### `governance` */\\n  function setGovernance(address governanceAddress) public { unchecked {\\n    authOnly();\\n    governance = governanceAddress;\\n    emit SetGovernance(governanceAddress);\\n  }}\\n\\n  /* ### `vault` */\\n  function setVault(address vaultAddress) public { unchecked {\\n    authOnly();\\n    vault = vaultAddress;\\n    emit SetVault(vaultAddress);\\n  }}\\n\\n  /* ### `monitor` */\\n  function setMonitor(address monitor) public { unchecked {\\n    authOnly();\\n    internal_global = internal_global.monitor(monitor);\\n    emit SetMonitor(monitor);\\n  }}\\n\\n  /* ### `useOracle` */\\n  function setUseOracle(bool useOracle) public { unchecked {\\n    authOnly();\\n    internal_global = internal_global.useOracle(useOracle);\\n    emit SetUseOracle(useOracle);\\n  }}\\n\\n  /* ### `notify` */\\n  function setNotify(bool notify) public { unchecked {\\n    authOnly();\\n    internal_global = internal_global.notify(notify);\\n    emit SetNotify(notify);\\n  }}\\n}\\n\",\"keccak256\":\"0x4c6b9cfce810d9ca1dd8e5e4fad0bf8d803b1afa5ddc28c9ee2204c37d6166a8\",\"license\":\"AGPL-3.0\"},\"contracts/MgvHasOffers.sol\":{\"content\":\"// SPDX-License-Identifier:\\tAGPL-3.0\\n\\n// MgvHasOffers.sol\\n\\n// Copyright (C) 2021 Giry SAS.\\n//\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU Affero General Public License as published\\n// by the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n//\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU Affero General Public License for more details.\\n//\\n// You should have received a copy of the GNU Affero General Public License\\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\\npragma solidity ^0.8.10;\\npragma abicoder v2;\\nimport {MgvLib as ML, HasMgvEvents, IMgvMonitor,P} from \\\"./MgvLib.sol\\\";\\nimport {MgvRoot} from \\\"./MgvRoot.sol\\\";\\n\\n/* `MgvHasOffers` contains the state variables and functions common to both market-maker operations and market-taker operations. Mostly: storing offers, removing them, updating market makers' provisions. */\\ncontract MgvHasOffers is MgvRoot {\\n  using P.Offer for P.Offer.t;\\n  using P.OfferDetail for P.OfferDetail.t;\\n  using P.Local for P.Local.t;\\n  /* # State variables */\\n  /* Given a `outbound_tkn`,`inbound_tkn` pair, the mappings `offers` and `offerDetails` associate two 256 bits words to each offer id. Those words encode information detailed in [`structs.js`](#structs.js).\\n\\n     The mappings are `outbound_tkn => inbound_tkn => offerId => P.Offer.t|P.OfferDetail.t`.\\n   */\\n  mapping(address => mapping(address => mapping(uint => P.Offer.t)))\\n    public offers;\\n  mapping(address => mapping(address => mapping(uint => P.OfferDetail.t)))\\n    public offerDetails;\\n\\n  /* Makers provision their possible penalties in the `balanceOf` mapping.\\n\\n       Offers specify the amount of gas they require for successful execution ([`gasreq`](#structs.js/gasreq)). To minimize book spamming, market makers must provision a *penalty*, which depends on their `gasreq` and on the pair's [`offer_gasbase`](#structs.js/gasbase). This provision is deducted from their `balanceOf`. If an offer fails, part of that provision is given to the taker, as retribution. The exact amount depends on the gas used by the offer before failing.\\n\\n       The Mangrove keeps track of their available balance in the `balanceOf` map, which is decremented every time a maker creates a new offer, and may be modified on offer updates/cancelations/takings.\\n     */\\n  mapping(address => uint) public balanceOf;\\n\\n  /* # Read functions */\\n  /* Convenience function to get best offer of the given pair */\\n  function best(address outbound_tkn, address inbound_tkn)\\n    external\\n    view\\n    returns (uint)\\n  { unchecked {\\n    P.Local.t local = locals[outbound_tkn][inbound_tkn];\\n    return local.best();\\n  }}\\n\\n  /* Returns information about an offer in ABI-compatible structs. Do not use internally, would be a huge memory-copying waste. Use `offers[outbound_tkn][inbound_tkn]` and `offerDetails[outbound_tkn][inbound_tkn]` instead. */\\n  function offerInfo(\\n    address outbound_tkn,\\n    address inbound_tkn,\\n    uint offerId\\n  ) external view returns (P.OfferStruct memory offer, P.OfferDetailStruct memory offerDetail) { unchecked {\\n\\n    P.Offer.t _offer = offers[outbound_tkn][inbound_tkn][offerId];\\n    offer = _offer.to_struct();\\n\\n    P.OfferDetail.t _offerDetail = offerDetails[outbound_tkn][inbound_tkn][offerId];\\n    offerDetail = _offerDetail.to_struct();\\n  }}\\n\\n  /* # Provision debit/credit utility functions */\\n  /* `balanceOf` is in wei of ETH. */\\n\\n  function debitWei(address maker, uint amount) internal { unchecked {\\n    uint makerBalance = balanceOf[maker];\\n    require(makerBalance >= amount, \\\"mgv/insufficientProvision\\\");\\n    balanceOf[maker] = makerBalance - amount;\\n    emit Debit(maker, amount);\\n  }}\\n\\n  function creditWei(address maker, uint amount) internal { unchecked {\\n    balanceOf[maker] += amount;\\n    emit Credit(maker, amount);\\n  }}\\n\\n  /* # Misc. low-level functions */\\n  /* ## Offer deletion */\\n\\n  /* When an offer is deleted, it is marked as such by setting `gives` to 0. Note that provision accounting in the Mangrove aims to minimize writes. Each maker `fund`s the Mangrove to increase its balance. When an offer is created/updated, we compute how much should be reserved to pay for possible penalties. That amount can always be recomputed with `offerDetail.gasprice * (offerDetail.gasreq + offerDetail.offer_gasbase)`. The balance is updated to reflect the remaining available ethers.\\n\\n     Now, when an offer is deleted, the offer can stay provisioned, or be `deprovision`ed. In the latter case, we set `gasprice` to 0, which induces a provision of 0. All code calling `dirtyDeleteOffer` with `deprovision` set to `true` must be careful to correctly account for where that provision is going (back to the maker's `balanceOf`, or sent to a taker as compensation). */\\n  function dirtyDeleteOffer(\\n    address outbound_tkn,\\n    address inbound_tkn,\\n    uint offerId,\\n    P.Offer.t offer,\\n    P.OfferDetail.t offerDetail,\\n    bool deprovision\\n  ) internal { unchecked {\\n    offer = offer.gives(0);\\n    if (deprovision) {\\n      offerDetail = offerDetail.gasprice(0);\\n    }\\n    offers[outbound_tkn][inbound_tkn][offerId] = offer;\\n    offerDetails[outbound_tkn][inbound_tkn][offerId] = offerDetail;\\n  }}\\n\\n  /* ## Stitching the orderbook */\\n\\n  /* Connect the offers `betterId` and `worseId` through their `next`/`prev` pointers. For more on the book structure, see [`structs.js`](#structs.js). Used after executing an offer (or a segment of offers), after removing an offer, or moving an offer.\\n\\n  **Warning**: calling with `betterId = 0` will set `worseId` as the best. So with `betterId = 0` and `worseId = 0`, it sets the book to empty and loses track of existing offers.\\n\\n  **Warning**: may make memory copy of `local.best` stale. Returns new `local`. */\\n  function stitchOffers(\\n    address outbound_tkn,\\n    address inbound_tkn,\\n    uint betterId,\\n    uint worseId,\\n    P.Local.t local\\n  ) internal returns (P.Local.t) { unchecked {\\n    if (betterId != 0) {\\n      offers[outbound_tkn][inbound_tkn][betterId] = offers[outbound_tkn][inbound_tkn][betterId].next(worseId);\\n    } else {\\n      local = local.best(worseId);\\n    }\\n\\n    if (worseId != 0) {\\n      offers[outbound_tkn][inbound_tkn][worseId] = offers[outbound_tkn][inbound_tkn][worseId].prev(betterId);\\n    }\\n\\n    return local;\\n  }}\\n\\n  /* ## Check offer is live */\\n  /* Check whether an offer is 'live', that is: inserted in the order book. The Mangrove holds a `outbound_tkn => inbound_tkn => id => P.Offer.t` mapping in storage. Offer ids that are not yet assigned or that point to since-deleted offer will point to an offer with `gives` field at 0. */\\n  function isLive(P.Offer.t offer) public pure returns (bool) { unchecked {\\n    return offer.gives() > 0;\\n  }}\\n}\\n\",\"keccak256\":\"0x3615c6503a5fa2cfe212571ff7afc2208d377fd1c996dd7074b9d7af67bceff3\",\"license\":\"AGPL-3.0\"},\"contracts/MgvLib.sol\":{\"content\":\"// SPDX-License-Identifier: Unlicense\\n\\n// MgvLib.sol\\n\\n// This is free and unencumbered software released into the public domain.\\n\\n// Anyone is free to copy, modify, publish, use, compile, sell, or distribute this software, either in source code form or as a compiled binary, for any purpose, commercial or non-commercial, and by any means.\\n\\n// In jurisdictions that recognize copyright laws, the author or authors of this software dedicate any and all copyright interest in the software to the public domain. We make this dedication for the benefit of the public at large and to the detriment of our heirs and successors. We intend this dedication to be an overt act of relinquishment in perpetuity of all present and future rights to this software under copyright law.\\n\\n// THE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\\n\\n// For more information, please refer to <https://unlicense.org/>\\n\\n/* `MgvLib` contains data structures returned by external calls to Mangrove and the interfaces it uses for its own external calls. */\\n\\npragma solidity ^0.8.10;\\npragma abicoder v2;\\n\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"./MgvPack.sol\\\" as P;\\n\\n/* # Structs\\nThe structs defined in `structs.js` have their counterpart as solidity structs that are easy to manipulate for outside contracts / callers of view functions. */\\n\\nlibrary MgvLib {\\n  /*\\n   Some miscellaneous data types useful to `Mangrove` and external contracts */\\n  //+clear+\\n\\n  /* `SingleOrder` holds data about an order-offer match in a struct. Used by `marketOrder` and `internalSnipes` (and some of their nested functions) to avoid stack too deep errors. */\\n  struct SingleOrder {\\n    address outbound_tkn;\\n    address inbound_tkn;\\n    uint offerId;\\n    P.Offer.t offer;\\n    /* `wants`/`gives` mutate over execution. Initially the `wants`/`gives` from the taker's pov, then actual `wants`/`gives` adjusted by offer's price and volume. */\\n    uint wants;\\n    uint gives;\\n    /* `offerDetail` is only populated when necessary. */\\n    P.OfferDetail.t offerDetail;\\n    P.Global.t global;\\n    P.Local.t local;\\n  }\\n\\n  /* <a id=\\\"MgvLib/OrderResult\\\"></a> `OrderResult` holds additional data for the maker and is given to them _after_ they fulfilled an offer. It gives them their own returned data from the previous call, and an `mgvData` specifying whether the Mangrove encountered an error. */\\n\\n  struct OrderResult {\\n    /* `makerdata` holds a message that was either returned by the maker or passed as revert message at the end of the trade execution*/\\n    bytes32 makerData;\\n    /* `mgvData` is an [internal Mangrove status](#MgvOfferTaking/statusCodes) code. */\\n    bytes32 mgvData;\\n  }\\n}\\n\\n/* # Events\\nThe events emitted for use by bots are listed here: */\\ncontract HasMgvEvents {\\n  /* * Emitted at the creation of the new Mangrove contract on the pair (`inbound_tkn`, `outbound_tkn`)*/\\n  event NewMgv();\\n\\n  /* Mangrove adds or removes wei from `maker`'s account */\\n  /* * Credit event occurs when an offer is removed from the Mangrove or when the `fund` function is called*/\\n  event Credit(address indexed maker, uint amount);\\n  /* * Debit event occurs when an offer is posted or when the `withdraw` function is called */\\n  event Debit(address indexed maker, uint amount);\\n\\n  /* * Mangrove reconfiguration */\\n  event SetActive(\\n    address indexed outbound_tkn,\\n    address indexed inbound_tkn,\\n    bool value\\n  );\\n  event SetFee(\\n    address indexed outbound_tkn,\\n    address indexed inbound_tkn,\\n    uint value\\n  );\\n  event SetGasbase(\\n    address indexed outbound_tkn,\\n    address indexed inbound_tkn,\\n    uint offer_gasbase\\n  );\\n  event SetGovernance(address value);\\n  event SetMonitor(address value);\\n  event SetVault(address value);\\n  event SetUseOracle(bool value);\\n  event SetNotify(bool value);\\n  event SetGasmax(uint value);\\n  event SetDensity(\\n    address indexed outbound_tkn,\\n    address indexed inbound_tkn,\\n    uint value\\n  );\\n  event SetGasprice(uint value);\\n\\n  /* Market order execution */\\n  event OrderComplete(\\n    address indexed outbound_tkn,\\n    address indexed inbound_tkn,\\n    address taker,\\n    uint takerGot,\\n    uint takerGave,\\n    uint penalty\\n  );\\n\\n  /* * Offer execution */\\n  event OfferSuccess(\\n    address indexed outbound_tkn,\\n    address indexed inbound_tkn,\\n    uint id,\\n    // `maker` is not logged because it can be retrieved from the state using `(outbound_tkn,inbound_tkn,id)`.\\n    address taker,\\n    uint takerWants,\\n    uint takerGives\\n  );\\n\\n  /* Log information when a trade execution reverts or returns a non empty bytes32 word */\\n  event OfferFail(\\n    address indexed outbound_tkn,\\n    address indexed inbound_tkn,\\n    uint id,\\n    // `maker` is not logged because it can be retrieved from the state using `(outbound_tkn,inbound_tkn,id)`.\\n    address taker,\\n    uint takerWants,\\n    uint takerGives,\\n    // `mgvData` may only be `\\\"mgv/makerRevert\\\"`, `\\\"mgv/makerAbort\\\"`, `\\\"mgv/makerTransferFail\\\"` or `\\\"mgv/makerReceiveFail\\\"`\\n    bytes32 mgvData\\n  );\\n\\n  /* Log information when a posthook reverts */\\n  event PosthookFail(\\n    address indexed outbound_tkn,\\n    address indexed inbound_tkn,\\n    uint offerId\\n  );\\n\\n  /* * After `permit` and `approve` */\\n  event Approval(\\n    address indexed outbound_tkn,\\n    address indexed inbound_tkn,\\n    address owner,\\n    address spender,\\n    uint value\\n  );\\n\\n  /* * Mangrove closure */\\n  event Kill();\\n\\n  /* * An offer was created or updated.\\n  A few words about why we include a `prev` field, and why we don't include a\\n  `next` field: in theory clients should need neither `prev` nor a `next` field.\\n  They could just 1. Read the order book state at a given block `b`.  2. On\\n  every event, update a local copy of the orderbook.  But in practice, we do not\\n  want to force clients to keep a copy of the *entire* orderbook. There may be a\\n  long tail of spam. Now if they only start with the first $N$ offers and\\n  receive a new offer that goes to the end of the book, they cannot tell if\\n  there are missing offers between the new offer and the end of the local copy\\n  of the book.\\n  \\n  So we add a prev pointer so clients with only a prefix of the book can receive\\n  out-of-prefix offers and know what to do with them. The `next` pointer is an\\n  optimization useful in Solidity (we traverse fewer memory locations) but\\n  useless in client code.\\n  */\\n  event OfferWrite(\\n    address indexed outbound_tkn,\\n    address indexed inbound_tkn,\\n    address maker,\\n    uint wants,\\n    uint gives,\\n    uint gasprice,\\n    uint gasreq,\\n    uint id,\\n    uint prev\\n  );\\n\\n  /* * `offerId` was present and is now removed from the book. */\\n  event OfferRetract(\\n    address indexed outbound_tkn,\\n    address indexed inbound_tkn,\\n    uint id\\n  );\\n}\\n\\n/* # IMaker interface */\\ninterface IMaker {\\n  /* Called upon offer execution. If the call returns normally with the first 32 bytes are 0, Mangrove will try to transfer funds; otherwise not. Returned data (truncated to leftmost 32 bytes) can be accessed during the call to `makerPosthook` in the `result.mgvData` field. To revert with a 32 bytes value, use something like:\\n     ```\\n     function tradeRevert(bytes32 data) internal pure {\\n       bytes memory revData = new bytes(32);\\n         assembly {\\n           mstore(add(revData, 32), data)\\n           revert(add(revData, 32), 32)\\n         }\\n     }\\n     ```\\n     */\\n  function makerExecute(MgvLib.SingleOrder calldata order)\\n    external\\n    returns (bytes32);\\n\\n  /* Called after all offers of an order have been executed. Posthook of the last executed order is called first and full reentrancy into the Mangrove is enabled at this time. `order` recalls key arguments of the order that was processed and `result` recalls important information for updating the current offer. (see [above](#MgvLib/OrderResult))*/\\n  function makerPosthook(\\n    MgvLib.SingleOrder calldata order,\\n    MgvLib.OrderResult calldata result\\n  ) external;\\n}\\n\\n/* # ITaker interface */\\ninterface ITaker {\\n  /* Inverted mangrove only: call to taker after loans went through */\\n  function takerTrade(\\n    address outbound_tkn,\\n    address inbound_tkn,\\n    // total amount of outbound_tkn token that was flashloaned to the taker\\n    uint totalGot,\\n    // total amount of inbound_tkn token that should be made available\\n    uint totalGives\\n  ) external;\\n}\\n\\n/* # Monitor interface\\nIf enabled, the monitor receives notification after each offer execution and is read for each pair's `gasprice` and `density`. */\\ninterface IMgvMonitor {\\n  function notifySuccess(MgvLib.SingleOrder calldata sor, address taker)\\n    external;\\n\\n  function notifyFail(MgvLib.SingleOrder calldata sor, address taker) external;\\n\\n  function read(address outbound_tkn, address inbound_tkn)\\n    external\\n    view\\n    returns (uint gasprice, uint density);\\n}\\n\",\"keccak256\":\"0x7b896c62102afb15d286a2db9df306a8dd50b9cdc462ff5a138fdae70a87d05a\",\"license\":\"Unlicense\"},\"contracts/MgvOfferMaking.sol\":{\"content\":\"// SPDX-License-Identifier:\\tAGPL-3.0\\n\\n// MgvOfferMaking.sol\\n\\n// Copyright (C) 2021 Giry SAS.\\n//\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU Affero General Public License as published\\n// by the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n//\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU Affero General Public License for more details.\\n//\\n// You should have received a copy of the GNU Affero General Public License\\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\\npragma solidity ^0.8.10;\\npragma abicoder v2;\\nimport {IMaker, HasMgvEvents, P} from \\\"./MgvLib.sol\\\";\\nimport {MgvHasOffers} from \\\"./MgvHasOffers.sol\\\";\\n\\n/* `MgvOfferMaking` contains market-making-related functions. */\\ncontract MgvOfferMaking is MgvHasOffers {\\n  using P.Offer for P.Offer.t;\\n  using P.OfferDetail for P.OfferDetail.t;\\n  using P.Global for P.Global.t;\\n  using P.Local for P.Local.t;\\n  /* # Public Maker operations\\n     ## New Offer */\\n  //+clear+\\n  /* In the Mangrove, makers and takers call separate functions. Market makers call `newOffer` to fill the book, and takers call functions such as `marketOrder` to consume it.  */\\n\\n  //+clear+\\n\\n  /* The following structs holds offer creation/update parameters in memory. This frees up stack space for local variables. */\\n  struct OfferPack {\\n    address outbound_tkn;\\n    address inbound_tkn;\\n    uint wants;\\n    uint gives;\\n    uint id;\\n    uint gasreq;\\n    uint gasprice;\\n    uint pivotId;\\n    P.Global.t global;\\n    P.Local.t local;\\n    // used on update only\\n    P.Offer.t oldOffer;\\n  }\\n\\n  /* The function `newOffer` is for market makers only; no match with the existing book is done. A maker specifies how much `inbound_tkn` it `wants` and how much `outbound_tkn` it `gives`.\\n\\n     It also specify with `gasreq` how much gas should be given when executing their offer.\\n\\n     `gasprice` indicates an upper bound on the gasprice at which the maker is ready to be penalised if their offer fails. Any value below the Mangrove's internal `gasprice` configuration value will be ignored.\\n\\n    `gasreq`, together with `gasprice`, will contribute to determining the penalty provision set aside by the Mangrove from the market maker's `balanceOf` balance.\\n\\n  Offers are always inserted at the correct place in the book. This requires walking through offers to find the correct insertion point. As in [Oasis](https://github.com/daifoundation/maker-otc/blob/f2060c5fe12fe3da71ac98e8f6acc06bca3698f5/src/matching_market.sol#L493), the maker should find the id of an offer close to its own and provide it as `pivotId`.\\n\\n  An offer cannot be inserted in a closed market, nor when a reentrancy lock for `outbound_tkn`,`inbound_tkn` is on.\\n\\n  No more than $2^{24}-1$ offers can ever be created for one `outbound_tkn`,`inbound_tkn` pair.\\n\\n  The actual contents of the function is in `writeOffer`, which is called by both `newOffer` and `updateOffer`.\\n  */\\n  function newOffer(\\n    address outbound_tkn,\\n    address inbound_tkn,\\n    uint wants,\\n    uint gives,\\n    uint gasreq,\\n    uint gasprice,\\n    uint pivotId\\n  ) external returns (uint) { unchecked {\\n    /* In preparation for calling `writeOffer`, we read the `outbound_tkn`,`inbound_tkn` pair configuration, check for reentrancy and market liveness, fill the `OfferPack` struct and increment the `outbound_tkn`,`inbound_tkn` pair's `last`. */\\n    OfferPack memory ofp;\\n    (ofp.global, ofp.local) = config(outbound_tkn, inbound_tkn);\\n    unlockedMarketOnly(ofp.local);\\n    activeMarketOnly(ofp.global, ofp.local);\\n\\n    ofp.id = 1 + ofp.local.last();\\n    require(uint32(ofp.id) == ofp.id, \\\"mgv/offerIdOverflow\\\");\\n\\n    ofp.local = ofp.local.last(ofp.id);\\n\\n    ofp.outbound_tkn = outbound_tkn;\\n    ofp.inbound_tkn = inbound_tkn;\\n    ofp.wants = wants;\\n    ofp.gives = gives;\\n    ofp.gasreq = gasreq;\\n    ofp.gasprice = gasprice;\\n    ofp.pivotId = pivotId;\\n\\n    /* The second parameter to writeOffer indicates that we are creating a new offer, not updating an existing one. */\\n    writeOffer(ofp, false);\\n\\n    /* Since we locally modified a field of the local configuration (`last`), we save the change to storage. Note that `writeOffer` may have further modified the local configuration by updating the current `best` offer. */\\n    locals[ofp.outbound_tkn][ofp.inbound_tkn] = ofp.local;\\n    return ofp.id;\\n  }}\\n\\n  /* ## Update Offer */\\n  //+clear+\\n  /* Very similar to `newOffer`, `updateOffer` prepares an `OfferPack` for `writeOffer`. Makers should use it for updating live offers, but also to save on gas by reusing old, already consumed offers.\\n\\n     A `pivotId` should still be given to minimise reads in the offer book. It is OK to give the offers' own id as a pivot.\\n\\n\\n     Gas use is minimal when:\\n     1. The offer does not move in the book\\n     2. The offer does not change its `gasreq`\\n     3. The (`outbound_tkn`,`inbound_tkn`)'s `offer_gasbase` has not changed since the offer was last written\\n     4. `gasprice` has not changed since the offer was last written\\n     5. `gasprice` is greater than the Mangrove's gasprice estimation\\n  */\\n  function updateOffer(\\n    address outbound_tkn,\\n    address inbound_tkn,\\n    uint wants,\\n    uint gives,\\n    uint gasreq,\\n    uint gasprice,\\n    uint pivotId,\\n    uint offerId\\n  ) external { unchecked {\\n    OfferPack memory ofp;\\n    (ofp.global, ofp.local) = config(outbound_tkn, inbound_tkn);\\n    unlockedMarketOnly(ofp.local);\\n    activeMarketOnly(ofp.global, ofp.local);\\n    ofp.outbound_tkn = outbound_tkn;\\n    ofp.inbound_tkn = inbound_tkn;\\n    ofp.wants = wants;\\n    ofp.gives = gives;\\n    ofp.id = offerId;\\n    ofp.gasreq = gasreq;\\n    ofp.gasprice = gasprice;\\n    ofp.pivotId = pivotId;\\n    ofp.oldOffer = offers[outbound_tkn][inbound_tkn][offerId];\\n    // Save local config\\n    P.Local.t oldLocal = ofp.local;\\n    /* The second argument indicates that we are updating an existing offer, not creating a new one. */\\n    writeOffer(ofp, true);\\n    /* We saved the current pair's configuration before calling `writeOffer`, since that function may update the current `best` offer. We now check for any change to the configuration and update it if needed. */\\n    if (!oldLocal.eq(ofp.local)) {\\n      locals[ofp.outbound_tkn][ofp.inbound_tkn] = ofp.local;\\n    }\\n  }}\\n\\n  /* ## Retract Offer */\\n  //+clear+\\n  /* `retractOffer` takes the offer `offerId` out of the book. However, `deprovision == true` also refunds the provision associated with the offer. */\\n  function retractOffer(\\n    address outbound_tkn,\\n    address inbound_tkn,\\n    uint offerId,\\n    bool deprovision\\n  ) external returns (uint provision) { unchecked {\\n    (, P.Local.t local) = config(outbound_tkn, inbound_tkn);\\n    unlockedMarketOnly(local);\\n    P.Offer.t offer = offers[outbound_tkn][inbound_tkn][offerId];\\n    P.OfferDetail.t offerDetail = offerDetails[outbound_tkn][inbound_tkn][offerId];\\n    require(\\n      msg.sender == offerDetail.maker(),\\n      \\\"mgv/retractOffer/unauthorized\\\"\\n    );\\n\\n    /* Here, we are about to un-live an offer, so we start by taking it out of the book by stitching together its previous and next offers. Note that unconditionally calling `stitchOffers` would break the book since it would connect offers that may have since moved. */\\n    if (isLive(offer)) {\\n      P.Local.t oldLocal = local;\\n      local = stitchOffers(\\n        outbound_tkn,\\n        inbound_tkn,\\n        offer.prev(),\\n        offer.next(),\\n        local\\n      );\\n      /* If calling `stitchOffers` has changed the current `best` offer, we update the storage. */\\n      if (!oldLocal.eq(local)) {\\n        locals[outbound_tkn][inbound_tkn] = local;\\n      }\\n    }\\n    /* Set `gives` to 0. Moreover, the last argument depends on whether the user wishes to get their provision back (if true, `gasprice` will be set to 0 as well). */\\n    dirtyDeleteOffer(\\n      outbound_tkn,\\n      inbound_tkn,\\n      offerId,\\n      offer,\\n      offerDetail,\\n      deprovision\\n    );\\n\\n    /* If the user wants to get their provision back, we compute its provision from the offer's `gasprice`, `offer_gasbase` and `gasreq`. */\\n    if (deprovision) {\\n      provision =\\n        10**9 *\\n        offerDetail.gasprice() * //gasprice is 0 if offer was deprovisioned\\n        (offerDetail.gasreq() + offerDetail.offer_gasbase());\\n      // credit `balanceOf` and log transfer\\n      creditWei(msg.sender, provision);\\n    }\\n    emit OfferRetract(outbound_tkn, inbound_tkn, offerId);\\n  }}\\n\\n  /* ## Provisioning\\n  Market makers must have enough provisions for possible penalties. These provisions are in ETH. Every time a new offer is created or an offer is updated, `balanceOf` is adjusted to provision the offer's maximum possible penalty (`gasprice * (gasreq + offer_gasbase)`).\\n\\n  For instance, if the current `balanceOf` of a maker is 1 ether and they create an offer that requires a provision of 0.01 ethers, their `balanceOf` will be reduced to 0.99 ethers. No ethers will move; this is just an internal accounting movement to make sure the maker cannot `withdraw` the provisioned amounts.\\n\\n  */\\n  //+clear+\\n\\n  /* Fund should be called with a nonzero value (hence the `payable` modifier). The provision will be given to `maker`, not `msg.sender`. */\\n  function fund(address maker) public payable { unchecked {\\n    (P.Global.t _global, ) = config(address(0), address(0));\\n    liveMgvOnly(_global);\\n    creditWei(maker, msg.value);\\n  }}\\n\\n  function fund() external payable { unchecked {\\n    fund(msg.sender);\\n  }}\\n\\n  /* A transfer with enough gas to the Mangrove will increase the caller's available `balanceOf` balance. _You should send enough gas to execute this function when sending money to the Mangrove._  */\\n  receive() external payable { unchecked {\\n    fund(msg.sender);\\n  }}\\n\\n  /* Any provision not currently held to secure an offer's possible penalty is available for withdrawal. */\\n  function withdraw(uint amount) external returns (bool noRevert) { unchecked {\\n    /* Since we only ever send money to the caller, we do not need to provide any particular amount of gas, the caller should manage this herself. */\\n    debitWei(msg.sender, amount);\\n    (noRevert, ) = msg.sender.call{value: amount}(\\\"\\\");\\n  }}\\n\\n  /* # Low-level Maker functions */\\n\\n  /* ## Write Offer */\\n\\n  function writeOffer(OfferPack memory ofp, bool update) internal { unchecked {\\n    /* `gasprice`'s floor is Mangrove's own gasprice estimate, `ofp.global.gasprice`. We first check that gasprice fits in 16 bits. Otherwise it could be that `uint16(gasprice) < global_gasprice < gasprice`, and the actual value we store is `uint16(gasprice)`. */\\n    require(\\n      uint16(ofp.gasprice) == ofp.gasprice,\\n      \\\"mgv/writeOffer/gasprice/16bits\\\"\\n    );\\n\\n    if (ofp.gasprice < ofp.global.gasprice()) {\\n      ofp.gasprice = ofp.global.gasprice();\\n    }\\n\\n    /* * Check `gasreq` below limit. Implies `gasreq` at most 24 bits wide, which ensures no overflow in computation of `provision` (see below). */\\n    require(\\n      ofp.gasreq <= ofp.global.gasmax(),\\n      \\\"mgv/writeOffer/gasreq/tooHigh\\\"\\n    );\\n    /* * Make sure `gives > 0` -- division by 0 would throw in several places otherwise, and `isLive` relies on it. */\\n    require(ofp.gives > 0, \\\"mgv/writeOffer/gives/tooLow\\\");\\n    /* * Make sure that the maker is posting a 'dense enough' offer: the ratio of `outbound_tkn` offered per gas consumed must be high enough. The actual gas cost paid by the taker is overapproximated by adding `offer_gasbase` to `gasreq`. */\\n    require(\\n      ofp.gives >=\\n        (ofp.gasreq + ofp.local.offer_gasbase()) * ofp.local.density(),\\n      \\\"mgv/writeOffer/density/tooLow\\\"\\n    );\\n\\n    /* The following checks are for the maker's convenience only. */\\n    require(uint96(ofp.gives) == ofp.gives, \\\"mgv/writeOffer/gives/96bits\\\");\\n    require(uint96(ofp.wants) == ofp.wants, \\\"mgv/writeOffer/wants/96bits\\\");\\n\\n    /* The position of the new or updated offer is found using `findPosition`. If the offer is the best one, `prev == 0`, and if it's the last in the book, `next == 0`.\\n\\n       `findPosition` is only ever called here, but exists as a separate function to make the code easier to read.\\n\\n    **Warning**: `findPosition` will call `better`, which may read the offer's `offerDetails`. So it is important to find the offer position _before_ we update its `offerDetail` in storage. We waste 1 (hot) read in that case but we deem that the code would get too ugly if we passed the old `offerDetail` as argument to `findPosition` and to `better`, just to save 1 hot read in that specific case.  */\\n    (uint prev, uint next) = findPosition(ofp);\\n\\n    /* Log the write offer event. */\\n    emit OfferWrite(\\n      ofp.outbound_tkn,\\n      ofp.inbound_tkn,\\n      msg.sender,\\n      ofp.wants,\\n      ofp.gives,\\n      ofp.gasprice,\\n      ofp.gasreq,\\n      ofp.id,\\n      prev\\n    );\\n\\n    /* We now write the new `offerDetails` and remember the previous provision (0 by default, for new offers) to balance out maker's `balanceOf`. */\\n    uint oldProvision;\\n    {\\n      P.OfferDetail.t offerDetail = offerDetails[ofp.outbound_tkn][ofp.inbound_tkn][\\n        ofp.id\\n      ];\\n      if (update) {\\n        require(\\n          msg.sender == offerDetail.maker(),\\n          \\\"mgv/updateOffer/unauthorized\\\"\\n        );\\n        oldProvision =\\n          10**9 *\\n          offerDetail.gasprice() *\\n          (offerDetail.gasreq() + offerDetail.offer_gasbase());\\n      }\\n\\n      /* If the offer is new, has a new `gasprice`, `gasreq`, or if the Mangrove's `offer_gasbase` configuration parameter has changed, we also update `offerDetails`. */\\n      if (\\n        !update ||\\n        offerDetail.gasreq() != ofp.gasreq ||\\n        offerDetail.gasprice() != ofp.gasprice ||\\n        offerDetail.offer_gasbase() !=\\n        ofp.local.offer_gasbase()\\n      ) {\\n        uint offer_gasbase = ofp.local.offer_gasbase();\\n        offerDetails[ofp.outbound_tkn][ofp.inbound_tkn][ofp.id] = \\n        P.OfferDetail.pack({\\n          __maker: msg.sender,\\n          __gasreq: ofp.gasreq,\\n          __offer_gasbase: offer_gasbase,\\n          __gasprice: ofp.gasprice\\n        });\\n      }\\n    }\\n\\n    /* With every change to an offer, a maker may deduct provisions from its `balanceOf` balance. It may also get provisions back if the updated offer requires fewer provisions than before. */\\n    {\\n      uint provision = (ofp.gasreq +\\n        ofp.local.offer_gasbase()) *\\n        ofp.gasprice *\\n        10**9;\\n      if (provision > oldProvision) {\\n        debitWei(msg.sender, provision - oldProvision);\\n      } else if (provision < oldProvision) {\\n        creditWei(msg.sender, oldProvision - provision);\\n      }\\n    }\\n    /* We now place the offer in the book at the position found by `findPosition`. */\\n\\n    /* First, we test if the offer has moved in the book or is not currently in the book. If `!isLive(ofp.oldOffer)`, we must update its prev/next. If it is live but its prev has changed, we must also update them. Note that checking both `prev = oldPrev` and `next == oldNext` would be redundant. If either is true, then the updated offer has not changed position and there is nothing to update.\\n\\n    As a note for future changes, there is a tricky edge case where `prev == oldPrev` yet the prev/next should be changed: a previously-used offer being brought back in the book, and ending with the same prev it had when it was in the book. In that case, the neighbor is currently pointing to _another_ offer, and thus must be updated. With the current code structure, this is taken care of as a side-effect of checking `!isLive`, but should be kept in mind. The same goes in the `next == oldNext` case. */\\n    if (!isLive(ofp.oldOffer) || prev != ofp.oldOffer.prev()) {\\n      /* * If the offer is not the best one, we update its predecessor; otherwise we update the `best` value. */\\n      if (prev != 0) {\\n        offers[ofp.outbound_tkn][ofp.inbound_tkn][prev] = offers[ofp.outbound_tkn][ofp.inbound_tkn][prev].next(ofp.id);\\n      } else {\\n        ofp.local = ofp.local.best(ofp.id);\\n      }\\n\\n      /* * If the offer is not the last one, we update its successor. */\\n      if (next != 0) {\\n        offers[ofp.outbound_tkn][ofp.inbound_tkn][next] = offers[ofp.outbound_tkn][ofp.inbound_tkn][next].prev(ofp.id);\\n      }\\n\\n      /* * Recall that in this branch, the offer has changed location, or is not currently in the book. If the offer is not new and already in the book, we must remove it from its previous location by stitching its previous prev/next. */\\n      if (update && isLive(ofp.oldOffer)) {\\n        ofp.local = stitchOffers(\\n          ofp.outbound_tkn,\\n          ofp.inbound_tkn,\\n          ofp.oldOffer.prev(),\\n          ofp.oldOffer.next(),\\n          ofp.local\\n        );\\n      }\\n    }\\n\\n    /* With the `prev`/`next` in hand, we finally store the offer in the `offers` map. */\\n    P.Offer.t ofr = P.Offer.pack({\\n      __prev: prev,\\n      __next: next,\\n      __wants: ofp.wants,\\n      __gives: ofp.gives\\n    });\\n    offers[ofp.outbound_tkn][ofp.inbound_tkn][ofp.id] = ofr;\\n  }}\\n\\n  /* ## Find Position */\\n  /* `findPosition` takes a price in the form of a (`ofp.wants`,`ofp.gives`) pair, an offer id (`ofp.pivotId`) and walks the book from that offer (backward or forward) until the right position for the price is found. The position is returned as a `(prev,next)` pair, with `prev` or `next` at 0 to mark the beginning/end of the book (no offer ever has id 0).\\n\\n  If prices are equal, `findPosition` will put the newest offer last. */\\n  function findPosition(OfferPack memory ofp)\\n    internal\\n    view\\n    returns (uint, uint)\\n  { unchecked {\\n    uint prevId;\\n    uint nextId;\\n    uint pivotId = ofp.pivotId;\\n    /* Get `pivot`, optimizing for the case where pivot info is already known */\\n    P.Offer.t pivot = pivotId == ofp.id\\n      ? ofp.oldOffer\\n      : offers[ofp.outbound_tkn][ofp.inbound_tkn][pivotId];\\n\\n    /* In case pivotId is not an active offer, it is unusable (since it is out of the book). We default to the current best offer. If the book is empty pivot will be 0. That is handled through a test in the `better` comparison function. */\\n    if (!isLive(pivot)) {\\n      pivotId = ofp.local.best();\\n      pivot = offers[ofp.outbound_tkn][ofp.inbound_tkn][pivotId];\\n    }\\n\\n    /* * Pivot is better than `wants/gives`, we follow `next`. */\\n    if (better(ofp, pivot, pivotId)) {\\n      P.Offer.t pivotNext;\\n      while (pivot.next() != 0) {\\n        uint pivotNextId = pivot.next();\\n        pivotNext = offers[ofp.outbound_tkn][ofp.inbound_tkn][pivotNextId];\\n        if (better(ofp, pivotNext, pivotNextId)) {\\n          pivotId = pivotNextId;\\n          pivot = pivotNext;\\n        } else {\\n          break;\\n        }\\n      }\\n      // gets here on empty book\\n      (prevId, nextId) = (pivotId, pivot.next());\\n\\n      /* * Pivot is strictly worse than `wants/gives`, we follow `prev`. */\\n    } else {\\n      P.Offer.t pivotPrev;\\n      while (pivot.prev() != 0) {\\n        uint pivotPrevId = pivot.prev();\\n        pivotPrev = offers[ofp.outbound_tkn][ofp.inbound_tkn][pivotPrevId];\\n        if (better(ofp, pivotPrev, pivotPrevId)) {\\n          break;\\n        } else {\\n          pivotId = pivotPrevId;\\n          pivot = pivotPrev;\\n        }\\n      }\\n\\n      (prevId, nextId) = (pivot.prev(), pivotId);\\n    }\\n\\n    return (\\n      prevId == ofp.id ? ofp.oldOffer.prev() : prevId,\\n      nextId == ofp.id ? ofp.oldOffer.next() : nextId\\n    );\\n  }}\\n\\n  /* ## Better */\\n  /* The utility method `better` takes an offer represented by `ofp` and another represented by `offer1`. It returns true iff `offer1` is better or as good as `ofp`.\\n    \\\"better\\\" is defined on the lexicographic order $\\\\textrm{price} \\\\times_{\\\\textrm{lex}} \\\\textrm{density}^{-1}$. This means that for the same price, offers that deliver more volume per gas are taken first.\\n\\n      In addition to `offer1`, we also provide its id, `offerId1` in order to save gas. If necessary (ie. if the prices `wants1/gives1` and `wants2/gives2` are the same), we read storage to get `gasreq1` at `offerDetails[...][offerId1]. */\\n  function better(\\n    OfferPack memory ofp,\\n    P.Offer.t offer1,\\n    uint offerId1\\n  ) internal view returns (bool) { unchecked {\\n    if (offerId1 == 0) {\\n      /* Happens on empty book. Returning `false` would work as well due to specifics of `findPosition` but true is more consistent. Here we just want to avoid reading `offerDetail[...][0]` for nothing. */\\n      return true;\\n    }\\n    uint wants1 = offer1.wants();\\n    uint gives1 = offer1.gives();\\n    uint wants2 = ofp.wants;\\n    uint gives2 = ofp.gives;\\n    uint weight1 = wants1 * gives2;\\n    uint weight2 = wants2 * gives1;\\n    if (weight1 == weight2) {\\n      uint gasreq1 = \\n          offerDetails[ofp.outbound_tkn][ofp.inbound_tkn][offerId1].gasreq();\\n      uint gasreq2 = ofp.gasreq;\\n      return (gives1 * gasreq2 >= gives2 * gasreq1);\\n    } else {\\n      return weight1 < weight2;\\n    }\\n  }}\\n}\\n\",\"keccak256\":\"0x4540f2d3684a4393bd9927f2c3a6e3ae848e91b301aaa3eab361d69d7eaa8151\",\"license\":\"AGPL-3.0\"},\"contracts/MgvOfferTaking.sol\":{\"content\":\"// SPDX-License-Identifier:\\tAGPL-3.0\\n\\n// MgvOfferTaking.sol\\n\\n// Copyright (C) 2021 Giry SAS.\\n//\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU Affero General Public License as published\\n// by the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n//\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU Affero General Public License for more details.\\n//\\n// You should have received a copy of the GNU Affero General Public License\\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\\npragma solidity ^0.8.10;\\npragma abicoder v2;\\nimport {IERC20, HasMgvEvents, IMaker, IMgvMonitor, MgvLib as ML, P} from \\\"./MgvLib.sol\\\";\\nimport {MgvHasOffers} from \\\"./MgvHasOffers.sol\\\";\\n\\nabstract contract MgvOfferTaking is MgvHasOffers {\\n  using P.Offer for P.Offer.t;\\n  using P.OfferDetail for P.OfferDetail.t;\\n  using P.Global for P.Global.t;\\n  using P.Local for P.Local.t;\\n  /* # MultiOrder struct */\\n  /* The `MultiOrder` struct is used by market orders and snipes. Some of its fields are only used by market orders (`initialWants, initialGives`). We need a common data structure for both since low-level calls are shared between market orders and snipes. The struct is helpful in decreasing stack use. */\\n  struct MultiOrder {\\n    uint initialWants; // used globally by market order, not used by snipes\\n    uint initialGives; // used globally by market order, not used by snipes\\n    uint totalGot; // used globally by market order, per-offer by snipes\\n    uint totalGave; // used globally by market order, per-offer by snipes\\n    uint totalPenalty; // used globally\\n    address taker; // used globally\\n    bool fillWants; // used globally\\n  }\\n\\n  /* # Market Orders */\\n\\n  /* ## Market Order */\\n  //+clear+\\n\\n  /* A market order specifies a (`outbound_tkn`,`inbound_tkn`) pair, a desired total amount of `outbound_tkn` (`takerWants`), and an available total amount of `inbound_tkn` (`takerGives`). It returns two `uint`s: the total amount of `outbound_tkn` received and the total amount of `inbound_tkn` spent.\\n\\n     The `takerGives/takerWants` ratio induces a maximum average price that the taker is ready to pay across all offers that will be executed during the market order. It is thus possible to execute an offer with a price worse than the initial (`takerGives`/`takerWants`) ratio given as argument to `marketOrder` if some cheaper offers were executed earlier in the market order.\\n\\n  The market order stops when the price has become too high, or when the end of the book has been reached, or:\\n  * If `fillWants` is true, the market order stops when `takerWants` units of `outbound_tkn` have been obtained. With `fillWants` set to true, to buy a specific volume of `outbound_tkn` at any price, set `takerWants` to the amount desired and `takerGives` to $2^{160}-1$.\\n  * If `fillWants` is false, the taker is filling `gives` instead: the market order stops when `takerGives` units of `inbound_tkn` have been sold. With `fillWants` set to false, to sell a specific volume of `inbound_tkn` at any price, set `takerGives` to the amount desired and `takerWants` to $0$. */\\n  function marketOrder(\\n    address outbound_tkn,\\n    address inbound_tkn,\\n    uint takerWants,\\n    uint takerGives,\\n    bool fillWants\\n  )\\n    external\\n    returns (\\n      uint,\\n      uint,\\n      uint\\n    )\\n  { unchecked {\\n    return\\n      generalMarketOrder(\\n        outbound_tkn,\\n        inbound_tkn,\\n        takerWants,\\n        takerGives,\\n        fillWants,\\n        msg.sender\\n      );\\n  }}\\n\\n  /* # General Market Order */\\n  //+clear+\\n  /* General market orders set up the market order with a given `taker` (`msg.sender` in the most common case). Returns `(totalGot, totalGave)`.\\n  Note that the `taker` can be anyone. This is safe when `taker == msg.sender`, but `generalMarketOrder` must not be called with `taker != msg.sender` unless a security check is done after (see [`MgvOfferTakingWithPermit`](#mgvoffertakingwithpermit.sol)`. */\\n  function generalMarketOrder(\\n    address outbound_tkn,\\n    address inbound_tkn,\\n    uint takerWants,\\n    uint takerGives,\\n    bool fillWants,\\n    address taker\\n  )\\n    internal\\n    returns (\\n      uint,\\n      uint,\\n      uint\\n    )\\n  { unchecked {\\n    /* Since amounts stored in offers are 96 bits wide, checking that `takerWants` and `takerGives` fit in 160 bits prevents overflow during the main market order loop. */\\n    require(uint160(takerWants) == takerWants, \\\"mgv/mOrder/takerWants/160bits\\\");\\n    require(uint160(takerGives) == takerGives, \\\"mgv/mOrder/takerGives/160bits\\\");\\n\\n    /* `SingleOrder` is defined in `MgvLib.sol` and holds information for ordering the execution of one offer. */\\n    ML.SingleOrder memory sor;\\n    sor.outbound_tkn = outbound_tkn;\\n    sor.inbound_tkn = inbound_tkn;\\n    (sor.global, sor.local) = config(outbound_tkn, inbound_tkn);\\n    /* Throughout the execution of the market order, the `sor`'s offer id and other parameters will change. We start with the current best offer id (0 if the book is empty). */\\n    sor.offerId = sor.local.best();\\n    sor.offer = offers[outbound_tkn][inbound_tkn][sor.offerId];\\n    /* `sor.wants` and `sor.gives` may evolve, but they are initially however much remains in the market order. */\\n    sor.wants = takerWants;\\n    sor.gives = takerGives;\\n\\n    /* `MultiOrder` (defined above) maintains information related to the entire market order. During the order, initial `wants`/`gives` values minus the accumulated amounts traded so far give the amounts that remain to be traded. */\\n    MultiOrder memory mor;\\n    mor.initialWants = takerWants;\\n    mor.initialGives = takerGives;\\n    mor.taker = taker;\\n    mor.fillWants = fillWants;\\n\\n    /* For the market order to even start, the market needs to be both active, and not currently protected from reentrancy. */\\n    activeMarketOnly(sor.global, sor.local);\\n    unlockedMarketOnly(sor.local);\\n\\n    /* ### Initialization */\\n    /* The market order will operate as follows : it will go through offers from best to worse, starting from `offerId`, and: */\\n    /* * will maintain remaining `takerWants` and `takerGives` values. The initial `takerGives/takerWants` ratio is the average price the taker will accept. Better prices may be found early in the book, and worse ones later.\\n     * will not set `prev`/`next` pointers to their correct locations at each offer taken (this is an optimization enabled by forbidding reentrancy).\\n     * after consuming a segment of offers, will update the current `best` offer to be the best remaining offer on the book. */\\n\\n    /* We start be enabling the reentrancy lock for this (`outbound_tkn`,`inbound_tkn`) pair. */\\n    sor.local = sor.local.lock(true);\\n    locals[outbound_tkn][inbound_tkn] = sor.local;\\n\\n    /* Call recursive `internalMarketOrder` function.*/\\n    internalMarketOrder(mor, sor, true);\\n\\n    /* Over the course of the market order, a penalty reserved for `msg.sender` has accumulated in `mor.totalPenalty`. No actual transfers have occured yet -- all the ethers given by the makers as provision are owned by the Mangrove. `sendPenalty` finally gives the accumulated penalty to `msg.sender`. */\\n    sendPenalty(mor.totalPenalty);\\n\\n    emit OrderComplete(\\n      outbound_tkn,\\n      inbound_tkn,\\n      taker,\\n      mor.totalGot,\\n      mor.totalGave,\\n      mor.totalPenalty\\n    );\\n\\n    //+clear+\\n    return (mor.totalGot, mor.totalGave, mor.totalPenalty);\\n  }}\\n\\n  /* ## Internal market order */\\n  //+clear+\\n  /* `internalMarketOrder` works recursively. Going downward, each successive offer is executed until the market order stops (due to: volume exhausted, bad price, or empty book). Then the [reentrancy lock is lifted](#internalMarketOrder/liftReentrancy). Going upward, each offer's `maker` contract is called again with its remaining gas and given the chance to update its offers on the book.\\n\\n    The last argument is a boolean named `proceed`. If an offer was not executed, it means the price has become too high. In that case, we notify the next recursive call that the market order should end. In this initial call, no offer has been executed yet so `proceed` is true. */\\n  function internalMarketOrder(\\n    MultiOrder memory mor,\\n    ML.SingleOrder memory sor,\\n    bool proceed\\n  ) internal { unchecked {\\n    /* #### Case 1 : End of order */\\n    /* We execute the offer currently stored in `sor`. */\\n    if (\\n      proceed &&\\n      (mor.fillWants ? sor.wants > 0 : sor.gives > 0) &&\\n      sor.offerId > 0\\n    ) {\\n      uint gasused; // gas used by `makerExecute`\\n      bytes32 makerData; // data returned by maker\\n\\n      /* <a id=\\\"MgvOfferTaking/statusCodes\\\"></a> `mgvData` is an internal Mangrove status code. It may appear in an [`OrderResult`](#MgvLib/OrderResult). Its possible values are:\\n      * `\\\"mgv/notExecuted\\\"`: offer was not executed.\\n      * `\\\"mgv/tradeSuccess\\\"`: offer execution succeeded. Will appear in `OrderResult`.\\n      * `\\\"mgv/notEnoughGasForMakerTrade\\\"`: cannot give maker close enough to `gasreq`. Triggers a revert of the entire order.\\n      * `\\\"mgv/makerRevert\\\"`: execution of `makerExecute` reverted. Will appear in `OrderResult`.\\n      * `\\\"mgv/makerAbort\\\"`: execution of `makerExecute` returned normally, but returndata did not start with 32 bytes of 0s. Will appear in `OrderResult`.\\n      * `\\\"mgv/makerTransferFail\\\"`: maker could not send outbound_tkn tokens. Will appear in `OrderResult`.\\n      * `\\\"mgv/makerReceiveFail\\\"`: maker could not receive inbound_tkn tokens. Will appear in `OrderResult`.\\n      * `\\\"mgv/takerTransferFail\\\"`: taker could not send inbound_tkn tokens. Triggers a revert of the entire order.\\n\\n      `mgvData` should not be exploitable by the maker! */\\n      bytes32 mgvData;\\n\\n      /* Load additional information about the offer. We don't do it earlier to save one storage read in case `proceed` was false. */\\n      sor.offerDetail = offerDetails[sor.outbound_tkn][sor.inbound_tkn][\\n        sor.offerId\\n      ];\\n\\n      /* `execute` will adjust `sor.wants`,`sor.gives`, and may attempt to execute the offer if its price is low enough. It is crucial that an error due to `taker` triggers a revert. That way, [`mgvData`](#MgvOfferTaking/statusCodes) not in `[\\\"mgv/notExecuted\\\",\\\"mgv/tradeSuccess\\\"]` means the failure is the maker's fault. */\\n      /* Post-execution, `sor.wants`/`sor.gives` reflect how much was sent/taken by the offer. We will need it after the recursive call, so we save it in local variables. Same goes for `offerId`, `sor.offer` and `sor.offerDetail`. */\\n\\n      (gasused, makerData, mgvData) = execute(mor, sor);\\n\\n      /* Keep cached copy of current `sor` values. */\\n      uint takerWants = sor.wants;\\n      uint takerGives = sor.gives;\\n      uint offerId = sor.offerId;\\n      P.Offer.t offer = sor.offer;\\n      P.OfferDetail.t offerDetail = sor.offerDetail;\\n\\n      /* If an execution was attempted, we move `sor` to the next offer. Note that the current state is inconsistent, since we have not yet updated `sor.offerDetails`. */\\n      if (mgvData != \\\"mgv/notExecuted\\\") {\\n        sor.wants = mor.initialWants > mor.totalGot\\n          ? mor.initialWants - mor.totalGot\\n          : 0;\\n        /* It is known statically that `mor.initialGives - mor.totalGave` does not underflow since\\n           1. `mor.totalGave` was increased by `sor.gives` during `execute`,\\n           2. `sor.gives` was at most `mor.initialGives - mor.totalGave` from earlier step,\\n           3. `sor.gives` may have been clamped _down_ during `execute` (to \\\"`offer.wants`\\\" if the offer is entirely consumed, or to `makerWouldWant`, cf. code of `execute`).\\n        */\\n        sor.gives = mor.initialGives - mor.totalGave;\\n        sor.offerId = sor.offer.next();\\n        sor.offer = offers[sor.outbound_tkn][sor.inbound_tkn][sor.offerId];\\n      }\\n\\n      /* note that internalMarketOrder may be called twice with same offerId, but in that case `proceed` will be false! */\\n      internalMarketOrder(\\n        mor,\\n        sor,\\n        /* `proceed` value for next call. Currently, when an offer did not execute, it's because the offer's price was too high. In that case we interrupt the loop and let the taker leave with less than they asked for (but at a correct price). We could also revert instead of breaking; this could be a configurable flag for the taker to pick. */\\n        mgvData != \\\"mgv/notExecuted\\\"\\n      );\\n\\n      /* Restore `sor` values from to before recursive call */\\n      sor.offerId = offerId;\\n      sor.wants = takerWants;\\n      sor.gives = takerGives;\\n      sor.offer = offer;\\n      sor.offerDetail = offerDetail;\\n\\n      /* After an offer execution, we may run callbacks and increase the total penalty. As that part is common to market orders and snipes, it lives in its own `postExecute` function. */\\n      if (mgvData != \\\"mgv/notExecuted\\\") {\\n        postExecute(mor, sor, gasused, makerData, mgvData);\\n      }\\n\\n      /* #### Case 2 : End of market order */\\n      /* If `proceed` is false, the taker has gotten its requested volume, or we have reached the end of the book, we conclude the market order. */\\n    } else {\\n      /* During the market order, all executed offers have been removed from the book. We end by stitching together the `best` offer pointer and the new best offer. */\\n      sor.local = stitchOffers(\\n        sor.outbound_tkn,\\n        sor.inbound_tkn,\\n        0,\\n        sor.offerId,\\n        sor.local\\n      );\\n      /* <a id=\\\"internalMarketOrder/liftReentrancy\\\"></a>Now that the market order is over, we can lift the lock on the book. In the same operation we\\n\\n      * lift the reentrancy lock, and\\n      * update the storage\\n\\n      so we are free from out of order storage writes.\\n      */\\n      sor.local = sor.local.lock(false);\\n      locals[sor.outbound_tkn][sor.inbound_tkn] = sor.local;\\n\\n      /* `payTakerMinusFees` sends the fee to the vault, proportional to the amount purchased, and gives the rest to the taker */\\n      payTakerMinusFees(mor, sor);\\n\\n      /* In an inverted Mangrove, amounts have been lent by each offer's maker to the taker. We now call the taker. This is a noop in a normal Mangrove. */\\n      executeEnd(mor, sor);\\n    }\\n  }}\\n\\n  /* # Sniping */\\n  /* ## Snipes */\\n  //+clear+\\n\\n  /* `snipes` executes multiple offers. It takes a `uint[4][]` as penultimate argument, with each array element of the form `[offerId,takerWants,takerGives,offerGasreq]`. The return parameters are of the form `(successes,snipesGot,snipesGave,bounty)`. \\n  Note that we do not distinguish further between mismatched arguments/offer fields on the one hand, and an execution failure on the other. Still, a failed offer has to pay a penalty, and ultimately transaction logs explicitly mention execution failures (see `MgvLib.sol`). */\\n  function snipes(\\n    address outbound_tkn,\\n    address inbound_tkn,\\n    uint[4][] calldata targets,\\n    bool fillWants\\n  )\\n    external\\n    returns (\\n      uint,\\n      uint,\\n      uint,\\n      uint\\n    )\\n  { unchecked {\\n    return\\n      generalSnipes(outbound_tkn, inbound_tkn, targets, fillWants, msg.sender);\\n  }}\\n\\n  /*\\n     From an array of _n_ `[offerId, takerWants,takerGives,gasreq]` elements, execute each snipe in sequence. Returns `(successes, takerGot, takerGave, bounty)`. \\n\\n     Note that if this function is not internal, anyone can make anyone use Mangrove.\\n     Note that unlike general market order, the returned total values are _not_ `mor.totalGot` and `mor.totalGave`, since those are reset at every iteration of the `targets` array. Instead, accumulators `snipesGot` and `snipesGave` are used. */\\n  function generalSnipes(\\n    address outbound_tkn,\\n    address inbound_tkn,\\n    uint[4][] calldata targets,\\n    bool fillWants,\\n    address taker\\n  )\\n    internal\\n    returns (\\n      uint,\\n      uint,\\n      uint,\\n      uint\\n    )\\n  { unchecked {\\n    ML.SingleOrder memory sor;\\n    sor.outbound_tkn = outbound_tkn;\\n    sor.inbound_tkn = inbound_tkn;\\n    (sor.global, sor.local) = config(outbound_tkn, inbound_tkn);\\n\\n    MultiOrder memory mor;\\n    mor.taker = taker;\\n    mor.fillWants = fillWants;\\n\\n    /* For the snipes to even start, the market needs to be both active and not currently protected from reentrancy. */\\n    activeMarketOnly(sor.global, sor.local);\\n    unlockedMarketOnly(sor.local);\\n\\n    /* ### Main loop */\\n    //+clear+\\n\\n    /* Call `internalSnipes` function. */\\n    (uint successCount, uint snipesGot, uint snipesGave) = internalSnipes(mor, sor, targets);\\n\\n    /* Over the course of the snipes order, a penalty reserved for `msg.sender` has accumulated in `mor.totalPenalty`. No actual transfers have occured yet -- all the ethers given by the makers as provision are owned by the Mangrove. `sendPenalty` finally gives the accumulated penalty to `msg.sender`. */\\n    sendPenalty(mor.totalPenalty);\\n    //+clear+\\n\\n    emit OrderComplete(\\n      outbound_tkn,\\n      inbound_tkn,\\n      taker,\\n      snipesGot,\\n      snipesGave,\\n      mor.totalPenalty\\n    );\\n\\n    return (successCount, snipesGot, snipesGave, mor.totalPenalty);\\n  }}\\n\\n  /* ## Internal snipes */\\n  //+clear+\\n  /* `internalSnipes` works by looping over targets. Each successive offer is executed under a [reentrancy lock](#internalSnipes/liftReentrancy), then its posthook is called.y lock [is lifted](). Going upward, each offer's `maker` contract is called again with its remaining gas and given the chance to update its offers on the book. */\\n  function internalSnipes(\\n    MultiOrder memory mor,\\n    ML.SingleOrder memory sor,\\n    uint[4][] calldata targets\\n  ) internal returns (uint successCount, uint snipesGot, uint snipesGave) { unchecked {\\n    for (uint i = 0; i < targets.length; i++) {\\n      /* Reset these amounts since every snipe is treated individually. Only the total penalty is sent at the end of all snipes. */\\n      mor.totalGot = 0;\\n      mor.totalGave = 0;\\n\\n      /* Initialize single order struct. */\\n      sor.offerId = targets[i][0];\\n      sor.offer = offers[sor.outbound_tkn][sor.inbound_tkn][sor.offerId];\\n      sor.offerDetail = offerDetails[sor.outbound_tkn][sor.inbound_tkn][\\n        sor.offerId\\n      ];\\n\\n      /* If we removed the `isLive` conditional, a single expired or nonexistent offer in `targets` would revert the entire transaction (by the division by `offer.gives` below since `offer.gives` would be 0). We also check that `gasreq` is not worse than specified. A taker who does not care about `gasreq` can specify any amount larger than $2^{24}-1$. A mismatched price will be detected by `execute`. */\\n      if (\\n        !isLive(sor.offer) ||\\n        sor.offerDetail.gasreq() > targets[i][3]\\n      ) {\\n        /* We move on to the next offer in the array. */\\n        continue;\\n      } else {\\n        require(\\n          uint96(targets[i][1]) == targets[i][1],\\n          \\\"mgv/snipes/takerWants/96bits\\\"\\n        );\\n        require(\\n          uint96(targets[i][2]) == targets[i][2],\\n          \\\"mgv/snipes/takerGives/96bits\\\"\\n        );\\n        sor.wants = targets[i][1];\\n        sor.gives = targets[i][2];\\n\\n        /* We start be enabling the reentrancy lock for this (`outbound_tkn`,`inbound_tkn`) pair. */\\n        sor.local = sor.local.lock(true);\\n        locals[sor.outbound_tkn][sor.inbound_tkn] = sor.local;\\n\\n        /* `execute` will adjust `sor.wants`,`sor.gives`, and may attempt to execute the offer if its price is low enough. It is crucial that an error due to `taker` triggers a revert. That way [`mgvData`](#MgvOfferTaking/statusCodes) not in `[\\\"mgv/tradeSuccess\\\",\\\"mgv/notExecuted\\\"]` means the failure is the maker's fault. */\\n        /* Post-execution, `sor.wants`/`sor.gives` reflect how much was sent/taken by the offer. */\\n        (uint gasused, bytes32 makerData, bytes32 mgvData) = execute(mor, sor);\\n\\n        if (mgvData == \\\"mgv/tradeSuccess\\\") {\\n          successCount += 1;\\n        }\\n\\n        /* In the market order, we were able to avoid stitching back offers after every `execute` since we knew a continuous segment starting at best would be consumed. Here, we cannot do this optimisation since offers in the `targets` array may be anywhere in the book. So we stitch together offers immediately after each `execute`. */\\n        if (mgvData != \\\"mgv/notExecuted\\\") {\\n          sor.local = stitchOffers(\\n            sor.outbound_tkn,\\n            sor.inbound_tkn,\\n            sor.offer.prev(),\\n            sor.offer.next(),\\n            sor.local\\n          );\\n        }\\n\\n        /* <a id=\\\"internalSnipes/liftReentrancy\\\"></a> Now that the current snipe is over, we can lift the lock on the book. In the same operation we\\n        * lift the reentrancy lock, and\\n        * update the storage\\n\\n        so we are free from out of order storage writes.\\n        */\\n        sor.local = sor.local.lock(false);\\n        locals[sor.outbound_tkn][sor.inbound_tkn] = sor.local;\\n\\n        /* `payTakerMinusFees` sends the fee to the vault, proportional to the amount purchased, and gives the rest to the taker */\\n        payTakerMinusFees(mor, sor);\\n\\n        /* In an inverted Mangrove, amounts have been lent by each offer's maker to the taker. We now call the taker. This is a noop in a normal Mangrove. */\\n        executeEnd(mor, sor);\\n\\n        /* After an offer execution, we may run callbacks and increase the total penalty. As that part is common to market orders and snipes, it lives in its own `postExecute` function. */\\n        if (mgvData != \\\"mgv/notExecuted\\\") {\\n          postExecute(mor, sor, gasused, makerData, mgvData);\\n        }\\n\\n\\n        snipesGot += mor.totalGot;\\n        snipesGave += mor.totalGave;\\n      }\\n    }\\n  }}\\n\\n  /* # General execution */\\n  /* During a market order or a snipes, offers get executed. The following code takes care of executing a single offer with parameters given by a `SingleOrder` within a larger context given by a `MultiOrder`. */\\n\\n  /* ## Execute */\\n  /* This function will compare `sor.wants` `sor.gives` with `sor.offer.wants` and `sor.offer.gives`. If the price of the offer is low enough, an execution will be attempted (with volume limited by the offer's advertised volume).\\n\\n     Summary of the meaning of the return values:\\n    * `gasused` is the gas consumed by the execution\\n    * `makerData` is the data returned after executing the offer\\n    * `mgvData` is an [internal Mangrove status code](#MgvOfferTaking/statusCodes).\\n  */\\n  function execute(MultiOrder memory mor, ML.SingleOrder memory sor)\\n    internal\\n    returns (\\n      uint gasused,\\n      bytes32 makerData,\\n      bytes32 mgvData\\n    )\\n  { unchecked {\\n    /* #### `Price comparison` */\\n    //+clear+\\n    /* The current offer has a price `p = offerWants \\u00f7 offerGives` and the taker is ready to accept a price up to `p' = takerGives \\u00f7 takerWants`. Comparing `offerWants * takerWants` and `offerGives * takerGives` tels us whether `p < p'`.\\n     */\\n    {\\n      uint offerWants = sor.offer.wants();\\n      uint offerGives = sor.offer.gives();\\n      uint takerWants = sor.wants;\\n      uint takerGives = sor.gives;\\n      /* <a id=\\\"MgvOfferTaking/checkPrice\\\"></a>If the price is too high, we return early.\\n\\n         Otherwise we now know we'll execute the offer. */\\n      if (offerWants * takerWants > offerGives * takerGives) {\\n        return (0, bytes32(0), \\\"mgv/notExecuted\\\");\\n      }\\n\\n      /* ### Specification of value transfers:\\n\\n      Let $o_w$ be `offerWants`, $o_g$ be `offerGives`, $t_w$ be `takerWants`, $t_g$ be `takerGives`, and `f \\u2208 {w,g}` be $w$ if `fillWants` is true, $g$ otherwise.\\n\\n      Let $\\\\textrm{got}$ be the amount that the taker will receive, and $\\\\textrm{gave}$ be the amount that the taker will pay.\\n\\n      #### Case $f = w$\\n\\n      If $f = w$, let $\\\\textrm{got} = \\\\min(o_g,t_w)$, and let $\\\\textrm{gave} = \\\\left\\\\lceil\\\\dfrac{o_w \\\\textrm{got}}{o_g}\\\\right\\\\rceil$. This is well-defined since, for live offers, $o_g > 0$.\\n\\n      In plain english, we only give to the taker up to what they wanted (or what the offer has to give), and follow the offer price to determine what the taker will give.\\n\\n      Since $\\\\textrm{gave}$ is rounded up, the price might be overevaluated. Still, we cannot spend more than what the taker specified as `takerGives`. At this point [we know](#MgvOfferTaking/checkPrice) that $o_w t_w \\\\leq o_g t_g$, so since $t_g$ is an integer we have\\n      \\n      $t_g \\\\geq \\\\left\\\\lceil\\\\dfrac{o_w t_w}{o_g}\\\\right\\\\rceil \\\\geq \\\\left\\\\lceil\\\\dfrac{o_w \\\\textrm{got}}{o_g}\\\\right\\\\rceil = \\\\textrm{gave}$.\\n\\n\\n      #### Case $f = g$\\n\\n      If $f = g$, let $\\\\textrm{gave} = \\\\min(o_w,t_g)$, and $\\\\textrm{got} = o_g$ if $o_w = 0$, $\\\\textrm{got} = \\\\left\\\\lfloor\\\\dfrac{o_g \\\\textrm{gave}}{o_w}\\\\right\\\\rfloor$ otherwise.\\n\\n      In plain english, we spend up to what the taker agreed to pay (or what the offer wants), and follow the offer price to determine what the taker will get. This may exceed $t_w$.\\n\\n      #### Price adjustment\\n\\n      Prices are rounded up to ensure maker is not drained on small amounts. It's economically unlikely, but `density` protects the taker from being drained anyway so it is better to default towards protecting the maker here.\\n      */\\n\\n      /*\\n      ### Implementation\\n\\n      First we check the cases $(f=w \\\\wedge o_g < t_w)\\\\vee(f_g \\\\wedge o_w < t_g)$, in which case the above spec simplifies to $\\\\textrm{got} = o_g, \\\\textrm{gave} = o_w$.\\n\\n      Otherwise the offer may be partially consumed.\\n      \\n      In the case $f=w$ we don't touch $\\\\textrm{got}$ (which was initialized to $t_w$) and compute $\\\\textrm{gave} = \\\\left\\\\lceil\\\\dfrac{o_w t_w}{o_g}\\\\right\\\\rceil$. As shown above we have $\\\\textrm{gave} \\\\leq t_g$.\\n\\n      In the case $f=g$ we don't touch $\\\\textrm{gave}$ (which was initialized to $t_g$) and compute $\\\\textrm{got} = o_g$ if $o_w = 0$, and $\\\\textrm{got} = \\\\left\\\\lfloor\\\\dfrac{o_g t_g}{o_w}\\\\right\\\\rfloor$ otherwise.\\n      */\\n      if (\\n        (mor.fillWants && offerGives < takerWants) ||\\n        (!mor.fillWants && offerWants < takerGives)\\n      ) {\\n        sor.wants = offerGives;\\n        sor.gives = offerWants;\\n      } else {\\n        if (mor.fillWants) {\\n          uint product = offerWants * takerWants;\\n          sor.gives =\\n            product /\\n            offerGives +\\n            (product % offerGives == 0 ? 0 : 1);\\n        } else {\\n          if (offerWants == 0) {\\n            sor.wants = offerGives;\\n          } else {\\n            sor.wants = (offerGives * takerGives) / offerWants;\\n          }\\n        }\\n      }\\n    }\\n    /* The flashloan is executed by call to `flashloan`. If the call reverts, it means the maker failed to send back `sor.wants` `outbound_tkn` to the taker. Notes :\\n     * `msg.sender` is the Mangrove itself in those calls -- all operations related to the actual caller should be done outside of this call.\\n     * any spurious exception due to an error in Mangrove code will be falsely blamed on the Maker, and its provision for the offer will be unfairly taken away.\\n     */\\n    (bool success, bytes memory retdata) = address(this).call(\\n      abi.encodeWithSelector(this.flashloan.selector, sor, mor.taker)\\n    );\\n\\n    /* `success` is true: trade is complete */\\n    if (success) {\\n      /* In case of success, `retdata` encodes the gas used by the offer. */\\n      gasused = abi.decode(retdata, (uint));\\n      /* `mgvData` indicates trade success */\\n      mgvData = bytes32(\\\"mgv/tradeSuccess\\\");\\n      emit OfferSuccess(\\n        sor.outbound_tkn,\\n        sor.inbound_tkn,\\n        sor.offerId,\\n        mor.taker,\\n        sor.wants,\\n        sor.gives\\n      );\\n\\n      /* If configured to do so, the Mangrove notifies an external contract that a successful trade has taken place. */\\n      if (sor.global.notify()) {\\n        IMgvMonitor(sor.global.monitor()).notifySuccess(\\n          sor,\\n          mor.taker\\n        );\\n      }\\n\\n      /* We update the totals in the multiorder based on the adjusted `sor.wants`/`sor.gives`. */\\n      /* overflow: sor.{wants,gives} are on 96bits, sor.total{Got,Gave} are on 256 bits. */\\n      mor.totalGot += sor.wants;\\n      mor.totalGave += sor.gives;\\n    } else {\\n      /* In case of failure, `retdata` encodes a short [status code](#MgvOfferTaking/statusCodes), the gas used by the offer, and an arbitrary 256 bits word sent by the maker.  */\\n      (mgvData, gasused, makerData) = innerDecode(retdata);\\n      /* Note that in the `if`s, the literals are bytes32 (stack values), while as revert arguments, they are strings (memory pointers). */\\n      if (\\n        mgvData == \\\"mgv/makerRevert\\\" ||\\n        mgvData == \\\"mgv/makerAbort\\\" ||\\n        mgvData == \\\"mgv/makerTransferFail\\\" ||\\n        mgvData == \\\"mgv/makerReceiveFail\\\"\\n      ) {\\n\\n        emit OfferFail(\\n          sor.outbound_tkn,\\n          sor.inbound_tkn,\\n          sor.offerId,\\n          mor.taker,\\n          sor.wants,\\n          sor.gives,\\n          mgvData\\n        );\\n\\n        /* If configured to do so, the Mangrove notifies an external contract that a failed trade has taken place. */\\n        if (sor.global.notify()) {\\n          IMgvMonitor(sor.global.monitor()).notifyFail(\\n            sor,\\n            mor.taker\\n          );\\n        }\\n        /* It is crucial that any error code which indicates an error caused by the taker triggers a revert, because functions that call `execute` consider that `mgvData` not in `[\\\"mgv/notExecuted\\\",\\\"mgv/tradeSuccess\\\"]` should be blamed on the maker. */\\n      } else if (mgvData == \\\"mgv/notEnoughGasForMakerTrade\\\") {\\n        revert(\\\"mgv/notEnoughGasForMakerTrade\\\");\\n      } else if (mgvData == \\\"mgv/takerTransferFail\\\") {\\n        revert(\\\"mgv/takerTransferFail\\\");\\n      } else {\\n        /* This code must be unreachable. **Danger**: if a well-crafted offer/maker pair can force a revert of `flashloan`, the Mangrove will be stuck. */\\n        revert(\\\"mgv/swapError\\\");\\n      }\\n    }\\n\\n    /* Delete the offer. The last argument indicates whether the offer should be stripped of its provision (yes if execution failed, no otherwise). We delete offers whether the amount remaining on offer is > density or not for the sake of uniformity (code is much simpler). We also expect prices to move often enough that the maker will want to update their price anyway. To simulate leaving the remaining volume in the offer, the maker can program their `makerPosthook` to `updateOffer` and put the remaining volume back in. */\\n    dirtyDeleteOffer(\\n      sor.outbound_tkn,\\n      sor.inbound_tkn,\\n      sor.offerId,\\n      sor.offer,\\n      sor.offerDetail,\\n      mgvData != \\\"mgv/tradeSuccess\\\"\\n    );\\n  }}\\n\\n  /* ## flashloan (abstract) */\\n  /* Externally called by `execute`, flashloan lends money (from the taker to the maker, or from the maker to the taker, depending on the implementation) then calls `makerExecute` to run the maker liquidity fetching code. If `makerExecute` is unsuccessful, `flashloan` reverts (but the larger orderbook traversal will continue). \\n\\n  All `flashloan` implementations must `require(msg.sender) == address(this))`. */\\n  function flashloan(ML.SingleOrder calldata sor, address taker)\\n    external\\n    virtual\\n    returns (uint gasused);\\n\\n  /* ## Maker Execute */\\n  /* Called by `flashloan`, `makerExecute` runs the maker code and checks that it can safely send the desired assets to the taker. */\\n\\n  function makerExecute(ML.SingleOrder calldata sor)\\n    internal\\n    returns (uint gasused)\\n  { unchecked {\\n    bytes memory cd = abi.encodeWithSelector(IMaker.makerExecute.selector, sor);\\n\\n    uint gasreq = sor.offerDetail.gasreq();\\n    address maker = sor.offerDetail.maker();\\n    uint oldGas = gasleft();\\n    /* We let the maker pay for the overhead of checking remaining gas and making the call, as well as handling the return data (constant gas since only the first 32 bytes of return data are read). So the `require` below is just an approximation: if the overhead of (`require` + cost of `CALL`) is $h$, the maker will receive at worst $\\\\textrm{gasreq} - \\\\frac{63h}{64}$ gas. */\\n    /* Note : as a possible future feature, we could stop an order when there's not enough gas left to continue processing offers. This could be done safely by checking, as soon as we start processing an offer, whether `63/64(gasleft-offer_gasbase) > gasreq`. If no, we could stop and know by induction that there is enough gas left to apply fees, stitch offers, etc for the offers already executed. */\\n    if (!(oldGas - oldGas / 64 >= gasreq)) {\\n      innerRevert([bytes32(\\\"mgv/notEnoughGasForMakerTrade\\\"), \\\"\\\", \\\"\\\"]);\\n    }\\n\\n    (bool callSuccess, bytes32 makerData) = controlledCall(maker, gasreq, cd);\\n\\n    gasused = oldGas - gasleft();\\n\\n    if (!callSuccess) {\\n      innerRevert([bytes32(\\\"mgv/makerRevert\\\"), bytes32(gasused), makerData]);\\n    }\\n\\n    /* Successful execution must have a returndata that begins with `bytes32(\\\"\\\")`.\\n     */\\n    if (makerData != \\\"\\\") {\\n      innerRevert([bytes32(\\\"mgv/makerAbort\\\"), bytes32(gasused), makerData]);\\n    }\\n\\n    bool transferSuccess = transferTokenFrom(\\n      sor.outbound_tkn,\\n      maker,\\n      address(this),\\n      sor.wants\\n    );\\n\\n    if (!transferSuccess) {\\n      innerRevert(\\n        [bytes32(\\\"mgv/makerTransferFail\\\"), bytes32(gasused), makerData]\\n      );\\n    }\\n  }}\\n\\n  /* ## executeEnd (abstract) */\\n  /* Called by `internalSnipes` and `internalMarketOrder`, `executeEnd` may run implementation-specific code after all makers have been called once. In [`InvertedMangrove`](#InvertedMangrove), the function calls the taker once so they can act on their flashloan. In [`Mangrove`], it does nothing. */\\n  function executeEnd(MultiOrder memory mor, ML.SingleOrder memory sor)\\n    internal\\n    virtual;\\n\\n  /* ## Post execute */\\n  /* At this point, we know `mgvData != \\\"mgv/notExecuted\\\"`. After executing an offer (whether in a market order or in snipes), we\\n     1. Call the maker's posthook and sum the total gas used.\\n     2. If offer failed: sum total penalty due to taker and give remainder to maker.\\n   */\\n  function postExecute(\\n    MultiOrder memory mor,\\n    ML.SingleOrder memory sor,\\n    uint gasused,\\n    bytes32 makerData,\\n    bytes32 mgvData\\n  ) internal { unchecked {\\n    if (mgvData == \\\"mgv/tradeSuccess\\\") {\\n      beforePosthook(sor);\\n    }\\n\\n    uint gasreq = sor.offerDetail.gasreq();\\n\\n    /* We are about to call back the maker, giving it its unused gas (`gasreq - gasused`). Since the gas used so far may exceed `gasreq`, we prevent underflow in the subtraction below by bounding `gasused` above with `gasreq`. We could have decided not to call back the maker at all when there is no gas left, but we do it for uniformity. */\\n    if (gasused > gasreq) {\\n      gasused = gasreq;\\n    }\\n\\n    gasused =\\n      gasused +\\n      makerPosthook(sor, gasreq - gasused, makerData, mgvData);\\n\\n    if (mgvData != \\\"mgv/tradeSuccess\\\") {\\n      mor.totalPenalty += applyPenalty(sor, gasused);\\n    }\\n  }}\\n\\n  /* ## beforePosthook (abstract) */\\n  /* Called by `makerPosthook`, this function can run implementation-specific code before calling the maker has been called a second time. In [`InvertedMangrove`](#InvertedMangrove), all makers are called once so the taker gets all of its money in one shot. Then makers are traversed again and the money is sent back to each taker using `beforePosthook`. In [`Mangrove`](#Mangrove), `beforePosthook` does nothing. */\\n\\n  function beforePosthook(ML.SingleOrder memory sor) internal virtual;\\n\\n  /* ## Maker Posthook */\\n  function makerPosthook(\\n    ML.SingleOrder memory sor,\\n    uint gasLeft,\\n    bytes32 makerData,\\n    bytes32 mgvData\\n  ) internal returns (uint gasused) { unchecked {\\n    /* At this point, mgvData can only be `\\\"mgv/tradeSuccess\\\"`, `\\\"mgv/makerAbort\\\"`, `\\\"mgv/makerRevert\\\"`, `\\\"mgv/makerTransferFail\\\"` or `\\\"mgv/makerReceiveFail\\\"` */\\n    bytes memory cd = abi.encodeWithSelector(\\n      IMaker.makerPosthook.selector,\\n      sor,\\n      ML.OrderResult({makerData: makerData, mgvData: mgvData})\\n    );\\n\\n    address maker = sor.offerDetail.maker();\\n\\n    uint oldGas = gasleft();\\n    /* We let the maker pay for the overhead of checking remaining gas and making the call. So the `require` below is just an approximation: if the overhead of (`require` + cost of `CALL`) is $h$, the maker will receive at worst $\\\\textrm{gasreq} - \\\\frac{63h}{64}$ gas. */\\n    if (!(oldGas - oldGas / 64 >= gasLeft)) {\\n      revert(\\\"mgv/notEnoughGasForMakerPosthook\\\");\\n    }\\n\\n    (bool callSuccess, ) = controlledCall(maker, gasLeft, cd);\\n\\n    gasused = oldGas - gasleft();\\n\\n    if (!callSuccess) {\\n      emit PosthookFail(sor.outbound_tkn, sor.inbound_tkn, sor.offerId);\\n    }\\n  }}\\n\\n  /* ## `controlledCall` */\\n  /* Calls an external function with controlled gas expense. A direct call of the form `(,bytes memory retdata) = maker.call{gas}(selector,...args)` enables a griefing attack: the maker uses half its gas to write in its memory, then reverts with that memory segment as argument. After a low-level call, solidity automaticaly copies `returndatasize` bytes of `returndata` into memory. So the total gas consumed to execute a failing offer could exceed `gasreq + offer_gasbase` where `n` is the number of failing offers. This yul call only retrieves the first 32 bytes of the maker's `returndata`. */\\n  function controlledCall(\\n    address callee,\\n    uint gasreq,\\n    bytes memory cd\\n  ) internal returns (bool success, bytes32 data) { unchecked {\\n    bytes32[1] memory retdata;\\n\\n    assembly {\\n      success := call(gasreq, callee, 0, add(cd, 32), mload(cd), retdata, 32)\\n    }\\n\\n    data = retdata[0];\\n  }}\\n\\n  /* # Penalties */\\n  /* Offers are just promises. They can fail. Penalty provisioning discourages from failing too much: we ask makers to provision more ETH than the expected gas cost of executing their offer and penalize them accoridng to wasted gas.\\n\\n     Under normal circumstances, we should expect to see bots with a profit expectation dry-running offers locally and executing `snipe` on failing offers, collecting the penalty. The result should be a mostly clean book for actual takers (i.e. a book with only successful offers).\\n\\n     **Incentive issue**: if the gas price increases enough after an offer has been created, there may not be an immediately profitable way to remove the fake offers. In that case, we count on 3 factors to keep the book clean:\\n     1. Gas price eventually comes down.\\n     2. Other market makers want to keep the Mangrove attractive and maintain their offer flow.\\n     3. Mangrove governance (who may collect a fee) wants to keep the Mangrove attractive and maximize exchange volume. */\\n\\n  //+clear+\\n  /* After an offer failed, part of its provision is given back to the maker and the rest is stored to be sent to the taker after the entire order completes. In `applyPenalty`, we _only_ credit the maker with its excess provision. So it looks like the maker is gaining something. In fact they're just getting back a fraction of what they provisioned earlier. */\\n  /*\\n     Penalty application summary:\\n\\n   * If the transaction was a success, we entirely refund the maker and send nothing to the taker.\\n   * Otherwise, the maker loses the cost of `gasused + offer_gasbase` gas. The gas price is estimated by `gasprice`.\\n   * To create the offer, the maker had to provision for `gasreq + offer_gasbase` gas at a price of `offerDetail.gasprice`.\\n   * We do not consider the tx.gasprice.\\n   * `offerDetail.gasbase` and `offerDetail.gasprice` are the values of the Mangrove parameters `config.offer_gasbase` and `config.gasprice` when the offer was created. Without caching those values, the provision set aside could end up insufficient to reimburse the maker (or to retribute the taker).\\n   */\\n  function applyPenalty(\\n    ML.SingleOrder memory sor,\\n    uint gasused\\n  ) internal returns (uint) { unchecked {\\n    uint gasreq = sor.offerDetail.gasreq();\\n\\n    uint provision = 10**9 *\\n      sor.offerDetail.gasprice() * \\n      (gasreq + sor.offerDetail.offer_gasbase());\\n\\n    /* We set `gasused = min(gasused,gasreq)` since `gasreq < gasused` is possible e.g. with `gasreq = 0` (all calls consume nonzero gas). */\\n    if (gasused > gasreq) {\\n      gasused = gasreq;\\n    }\\n\\n    /* As an invariant, `applyPenalty` is only called when `mgvData` is not in `[\\\"mgv/notExecuted\\\",\\\"mgv/tradeSuccess\\\"]` */\\n    uint penalty = 10**9 *\\n      sor.global.gasprice() *\\n      (gasused +\\n        sor.local.offer_gasbase());\\n\\n    if (penalty > provision) {\\n      penalty = provision;\\n    }\\n\\n    /* Here we write to storage the new maker balance. This occurs _after_ possible reentrant calls. How do we know we're not crediting twice the same amounts? Because the `offer`'s provision was set to 0 in storage (through `dirtyDeleteOffer`) before the reentrant calls. In this function, we are working with cached copies of the offer as it was before it was consumed. */\\n    creditWei(sor.offerDetail.maker(), provision - penalty);\\n\\n    return penalty;\\n  }}\\n\\n  function sendPenalty(uint amount) internal { unchecked {\\n    if (amount > 0) {\\n      (bool noRevert, ) = msg.sender.call{value: amount}(\\\"\\\");\\n      require(noRevert, \\\"mgv/sendPenaltyReverted\\\");\\n    }\\n  }}\\n\\n  /* Post-trade, `payTakerMinusFees` sends what's due to the taker and the rest (the fees) to the vault. Routing through the Mangrove like that also deals with blacklisting issues (separates the maker-blacklisted and the taker-blacklisted cases). */\\n  function payTakerMinusFees(MultiOrder memory mor, ML.SingleOrder memory sor)\\n    internal\\n  { unchecked {\\n    /* Should be statically provable that the 2 transfers below cannot return false under well-behaved ERC20s and a non-blacklisted, non-0 target. */\\n\\n    uint concreteFee = (mor.totalGot * sor.local.fee()) / 10_000;\\n    if (concreteFee > 0) {\\n      mor.totalGot -= concreteFee;\\n      require(\\n        transferToken(sor.outbound_tkn, vault, concreteFee),\\n        \\\"mgv/feeTransferFail\\\"\\n      );\\n    }\\n    if (mor.totalGot > 0) {\\n      require(\\n        transferToken(sor.outbound_tkn, mor.taker, mor.totalGot),\\n        \\\"mgv/MgvFailToPayTaker\\\"\\n      );\\n    }\\n  }}\\n\\n  /* # Misc. functions */\\n\\n  /* Regular solidity reverts prepend the string argument with a [function signature](https://docs.soliditylang.org/en/v0.7.6/control-structures.html#revert). Since we wish to transfer data through a revert, the `innerRevert` function does a low-level revert with only the required data. `innerCode` decodes this data. */\\n  function innerDecode(bytes memory data)\\n    internal\\n    pure\\n    returns (\\n      bytes32 mgvData,\\n      uint gasused,\\n      bytes32 makerData\\n    )\\n  { unchecked {\\n    /* The `data` pointer is of the form `[mgvData,gasused,makerData]` where each array element is contiguous and has size 256 bits. */\\n    assembly {\\n      mgvData := mload(add(data, 32))\\n      gasused := mload(add(data, 64))\\n      makerData := mload(add(data, 96))\\n    }\\n  }}\\n\\n  /* <a id=\\\"MgvOfferTaking/innerRevert\\\"></a>`innerRevert` reverts a raw triple of values to be interpreted by `innerDecode`.    */\\n  function innerRevert(bytes32[3] memory data) internal pure { unchecked {\\n    assembly {\\n      revert(data, 96)\\n    }\\n  }}\\n\\n  /* `transferTokenFrom` is adapted from [existing code](https://soliditydeveloper.com/safe-erc20) and in particular avoids the\\n  \\\"no return value\\\" bug. It never throws and returns true iff the transfer was successful according to `tokenAddress`.\\n\\n    Note that any spurious exception due to an error in Mangrove code will be falsely blamed on `from`.\\n  */\\n  function transferTokenFrom(\\n    address tokenAddress,\\n    address from,\\n    address to,\\n    uint value\\n  ) internal returns (bool) { unchecked {\\n    bytes memory cd = abi.encodeWithSelector(\\n      IERC20.transferFrom.selector,\\n      from,\\n      to,\\n      value\\n    );\\n    (bool noRevert, bytes memory data) = tokenAddress.call(cd);\\n    return (noRevert && (data.length == 0 || abi.decode(data, (bool))));\\n  }}\\n\\n  function transferToken(\\n    address tokenAddress,\\n    address to,\\n    uint value\\n  ) internal returns (bool) { unchecked {\\n    bytes memory cd = abi.encodeWithSelector(\\n      IERC20.transfer.selector,\\n      to,\\n      value\\n    );\\n    (bool noRevert, bytes memory data) = tokenAddress.call(cd);\\n    return (noRevert && (data.length == 0 || abi.decode(data, (bool))));\\n  }}\\n}\\n\",\"keccak256\":\"0x76d002a66df90ac306d27e6e91e58b6305f6c4165584591f17db3629af7e9825\",\"license\":\"AGPL-3.0\"},\"contracts/MgvOfferTakingWithPermit.sol\":{\"content\":\"// SPDX-License-Identifier:\\tAGPL-3.0\\n\\n// MgvOfferTakingWithPermit.sol\\n\\n// Copyright (C) 2021 Giry SAS.\\n//\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU Affero General Public License as published\\n// by the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n//\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU Affero General Public License for more details.\\n//\\n// You should have received a copy of the GNU Affero General Public License\\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.8.10;\\npragma abicoder v2;\\nimport {HasMgvEvents} from \\\"./MgvLib.sol\\\";\\n\\nimport {MgvOfferTaking} from \\\"./MgvOfferTaking.sol\\\";\\n\\nabstract contract MgvOfferTakingWithPermit is MgvOfferTaking {\\n  /* Takers may provide allowances on specific pairs, so other addresses can execute orders in their name. Allowance may be set using the usual `approve` function, or through an [EIP712](https://eips.ethereum.org/EIPS/eip-712) `permit`.\\n\\n  The mapping is `outbound_tkn => inbound_tkn => owner => spender => allowance` */\\n  mapping(address => mapping(address => mapping(address => mapping(address => uint))))\\n    public allowances;\\n  /* Storing nonces avoids replay attacks. */\\n  mapping(address => uint) public nonces;\\n  /* Following [EIP712](https://eips.ethereum.org/EIPS/eip-712), structured data signing has `keccak256(\\\"Permit(address outbound_tkn,address inbound_tkn,address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\\\")` in its prefix. */\\n  bytes32 public constant PERMIT_TYPEHASH =\\n    0xb7bf278e51ab1478b10530c0300f911d9ed3562fc93ab5e6593368fe23c077a2;\\n  /* Initialized in the constructor, `DOMAIN_SEPARATOR` avoids cross-application permit reuse. */\\n  bytes32 public immutable DOMAIN_SEPARATOR;\\n\\n  constructor(string memory contractName) {\\n    /* Initialize [EIP712](https://eips.ethereum.org/EIPS/eip-712) `DOMAIN_SEPARATOR`. */\\n    DOMAIN_SEPARATOR = keccak256(\\n      abi.encode(\\n        keccak256(\\n          \\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\"\\n        ),\\n        keccak256(bytes(contractName)),\\n        keccak256(bytes(\\\"1\\\")),\\n        block.chainid,\\n        address(this)\\n      )\\n    );\\n  }\\n\\n  /* # Delegation public functions */\\n\\n  /* Adapted from [Uniswap v2 contract](https://github.com/Uniswap/uniswap-v2-core/blob/55ae25109b7918565867e5c39f1e84b7edd19b2a/contracts/UniswapV2ERC20.sol#L81) */\\n  function permit(\\n    address outbound_tkn,\\n    address inbound_tkn,\\n    address owner,\\n    address spender,\\n    uint value,\\n    uint deadline,\\n    uint8 v,\\n    bytes32 r,\\n    bytes32 s\\n  ) external {\\n    unchecked {\\n      require(deadline >= block.timestamp, \\\"mgv/permit/expired\\\");\\n\\n      uint nonce = nonces[owner]++;\\n      bytes32 digest = keccak256(\\n        abi.encodePacked(\\n          \\\"\\\\x19\\\\x01\\\",\\n          DOMAIN_SEPARATOR,\\n          keccak256(\\n            abi.encode(\\n              PERMIT_TYPEHASH,\\n              outbound_tkn,\\n              inbound_tkn,\\n              owner,\\n              spender,\\n              value,\\n              nonce,\\n              deadline\\n            )\\n          )\\n        )\\n      );\\n      address recoveredAddress = ecrecover(digest, v, r, s);\\n      require(\\n        recoveredAddress != address(0) && recoveredAddress == owner,\\n        \\\"mgv/permit/invalidSignature\\\"\\n      );\\n\\n      allowances[outbound_tkn][inbound_tkn][owner][spender] = value;\\n      emit Approval(outbound_tkn, inbound_tkn, owner, spender, value);\\n    }\\n  }\\n\\n  function approve(\\n    address outbound_tkn,\\n    address inbound_tkn,\\n    address spender,\\n    uint value\\n  ) external returns (bool) {\\n    unchecked {\\n      allowances[outbound_tkn][inbound_tkn][msg.sender][spender] = value;\\n      emit Approval(outbound_tkn, inbound_tkn, msg.sender, spender, value);\\n      return true;\\n    }\\n  }\\n\\n  /* The delegate version of `marketOrder` is `marketOrderFor`, which takes a `taker` address as additional argument. Penalties incurred by failed offers will still be sent to `msg.sender`, but exchanged amounts will be transferred from and to the `taker`. If the `msg.sender`'s allowance for the given `outbound_tkn`,`inbound_tkn` and `taker` are strictly less than the total amount eventually spent by `taker`, the call will fail. */\\n\\n  /* *Note:* `marketOrderFor` and `snipesFor` may emit ERC20 `Transfer` events of value 0 from `taker`, but that's already the case with common ERC20 implementations. */\\n  function marketOrderFor(\\n    address outbound_tkn,\\n    address inbound_tkn,\\n    uint takerWants,\\n    uint takerGives,\\n    bool fillWants,\\n    address taker\\n  )\\n    external\\n    returns (\\n      uint takerGot,\\n      uint takerGave,\\n      uint bounty\\n    )\\n  {\\n    unchecked {\\n      (takerGot, takerGave, bounty) = generalMarketOrder(\\n        outbound_tkn,\\n        inbound_tkn,\\n        takerWants,\\n        takerGives,\\n        fillWants,\\n        taker\\n      );\\n      /* The sender's allowance is verified after the order complete so that `takerGave` rather than `takerGives` is checked against the allowance. The former may be lower. */\\n      deductSenderAllowance(outbound_tkn, inbound_tkn, taker, takerGave);\\n    }\\n  }\\n\\n  /* The delegate version of `snipes` is `snipesFor`, which takes a `taker` address as additional argument. */\\n  function snipesFor(\\n    address outbound_tkn,\\n    address inbound_tkn,\\n    uint[4][] calldata targets,\\n    bool fillWants,\\n    address taker\\n  )\\n    external\\n    returns (\\n      uint successes,\\n      uint takerGot,\\n      uint takerGave,\\n      uint bounty\\n    )\\n  {\\n    unchecked {\\n      (successes, takerGot, takerGave, bounty) = generalSnipes(\\n        outbound_tkn,\\n        inbound_tkn,\\n        targets,\\n        fillWants,\\n        taker\\n      );\\n      /* The sender's allowance is verified after the order complete so that the actual amounts are checked against the allowance, instead of the declared `takerGives`. The former may be lower.\\n    \\n    An immediate consequence is that any funds availale to Mangrove through `approve` can be used to clean offers. After a `snipesFor` where all offers have failed, all token transfers have been reverted, so `takerGave=0` and the check will succeed -- but the sender will still have received the bounty of the failing offers. */\\n      deductSenderAllowance(outbound_tkn, inbound_tkn, taker, takerGave);\\n    }\\n  }\\n\\n  /* # Misc. low-level functions */\\n\\n  /* Used by `*For` functions, its both checks that `msg.sender` was allowed to use the taker's funds, and decreases the former's allowance. */\\n  function deductSenderAllowance(\\n    address outbound_tkn,\\n    address inbound_tkn,\\n    address owner,\\n    uint amount\\n  ) internal {\\n    unchecked {\\n      uint allowed = allowances[outbound_tkn][inbound_tkn][owner][msg.sender];\\n      require(allowed >= amount, \\\"mgv/lowAllowance\\\");\\n      allowances[outbound_tkn][inbound_tkn][owner][msg.sender] =\\n        allowed -\\n        amount;\\n    }\\n  }\\n}\\n\",\"keccak256\":\"0xdb9ee43fec82b3ef992fbbd0556ad8f2cc0965151d4324230c66fbff6ba80288\",\"license\":\"AGPL-3.0\"},\"contracts/MgvPack.sol\":{\"content\":\"pragma solidity ^0.8.10;\\n\\n// SPDX-License-Identifier: Unlicense\\n\\n// MgvPack.sol\\n\\n// This is free and unencumbered software released into the public domain.\\n\\n// Anyone is free to copy, modify, publish, use, compile, sell, or distribute this software, either in source code form or as a compiled binary, for any purpose, commercial or non-commercial, and by any means.\\n\\n// In jurisdictions that recognize copyright laws, the author or authors of this software dedicate any and all copyright interest in the software to the public domain. We make this dedication for the benefit of the public at large and to the detriment of our heirs and successors. We intend this dedication to be an overt act of relinquishment in perpetuity of all present and future rights to this software under copyright law.\\n\\n// THE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\\n\\n// For more information, please refer to <https://unlicense.org/>\\n\\n/* ************************************************** *\\n            GENERATED FILE. DO NOT EDIT.\\n * ************************************************** */\\n\\n/* since you can't convert bool to uint in an expression without conditionals,\\n * we add a file-level function and rely on compiler optimization\\n */\\nfunction uint_of_bool(bool b) pure returns (uint u) {\\n  assembly { u := b }\\n}\\n\\n// fields are of the form [name,bits,type]\\n\\n// Can't put all structs under a 'Structs' library due to bad variable shadowing rules in Solidity\\n// (would generate lots of spurious warnings about a nameclash between Structs.Offer and library Offer for instance)\\n// struct_defs are of the form [name,obj]\\nstruct OfferStruct {\\n  uint prev;\\n  uint next;\\n  uint wants;\\n  uint gives;\\n}\\nstruct OfferDetailStruct {\\n  address maker;\\n  uint gasreq;\\n  uint offer_gasbase;\\n  uint gasprice;\\n}\\nstruct GlobalStruct {\\n  address monitor;\\n  bool useOracle;\\n  bool notify;\\n  uint gasprice;\\n  uint gasmax;\\n  bool dead;\\n}\\nstruct LocalStruct {\\n  bool active;\\n  uint fee;\\n  uint density;\\n  uint offer_gasbase;\\n  bool lock;\\n  uint best;\\n  uint last;\\n}\\n\\nlibrary Offer {\\n  //some type safety for each struct\\n  type t is uint;\\n\\n  uint constant prev_bits  = 32;\\n  uint constant next_bits  = 32;\\n  uint constant wants_bits = 96;\\n  uint constant gives_bits = 96;\\n\\n  uint constant prev_before  = 0;\\n  uint constant next_before  = prev_before  + prev_bits ;\\n  uint constant wants_before = next_before  + next_bits ;\\n  uint constant gives_before = wants_before + wants_bits;\\n\\n  uint constant prev_mask  = 0x00000000ffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\\n  uint constant next_mask  = 0xffffffff00000000ffffffffffffffffffffffffffffffffffffffffffffffff;\\n  uint constant wants_mask = 0xffffffffffffffff000000000000000000000000ffffffffffffffffffffffff;\\n  uint constant gives_mask = 0xffffffffffffffffffffffffffffffffffffffff000000000000000000000000;\\n\\n  function to_struct(t __packed) internal pure returns (OfferStruct memory __s) { unchecked {\\n    __s.prev = (t.unwrap(__packed) << prev_before) >> (256-prev_bits);\\n    __s.next = (t.unwrap(__packed) << next_before) >> (256-next_bits);\\n    __s.wants = (t.unwrap(__packed) << wants_before) >> (256-wants_bits);\\n    __s.gives = (t.unwrap(__packed) << gives_before) >> (256-gives_bits);\\n  }}\\n\\n  function t_of_struct(OfferStruct memory __s) internal pure returns (t) { unchecked {\\n    return pack(__s.prev, __s.next, __s.wants, __s.gives);\\n  }}\\n\\n  function eq(t __packed1, t __packed2) internal pure returns (bool) { unchecked {\\n    return t.unwrap(__packed1) == t.unwrap(__packed2);\\n  }}\\n\\n  function pack(uint __prev, uint __next, uint __wants, uint __gives) internal pure returns (t) { unchecked {\\n    return t.wrap(((((0\\n                  | ((__prev << (256-prev_bits)) >> prev_before))\\n                  | ((__next << (256-next_bits)) >> next_before))\\n                  | ((__wants << (256-wants_bits)) >> wants_before))\\n                  | ((__gives << (256-gives_bits)) >> gives_before)));\\n  }}\\n\\n  function unpack(t __packed) internal pure returns (uint __prev, uint __next, uint __wants, uint __gives) { unchecked {\\n    __prev = (t.unwrap(__packed) << prev_before) >> (256-prev_bits);\\n    __next = (t.unwrap(__packed) << next_before) >> (256-next_bits);\\n    __wants = (t.unwrap(__packed) << wants_before) >> (256-wants_bits);\\n    __gives = (t.unwrap(__packed) << gives_before) >> (256-gives_bits);\\n  }}\\n\\n  function prev(t __packed) internal pure returns(uint) { unchecked {\\n    return (t.unwrap(__packed) << prev_before) >> (256-prev_bits);\\n  }}\\n  function prev(t __packed,uint val) internal pure returns(t) { unchecked {\\n    return t.wrap((t.unwrap(__packed) & prev_mask)\\n                  | ((val << (256-prev_bits) >> prev_before)));\\n  }}\\n  function next(t __packed) internal pure returns(uint) { unchecked {\\n    return (t.unwrap(__packed) << next_before) >> (256-next_bits);\\n  }}\\n  function next(t __packed,uint val) internal pure returns(t) { unchecked {\\n    return t.wrap((t.unwrap(__packed) & next_mask)\\n                  | ((val << (256-next_bits) >> next_before)));\\n  }}\\n  function wants(t __packed) internal pure returns(uint) { unchecked {\\n    return (t.unwrap(__packed) << wants_before) >> (256-wants_bits);\\n  }}\\n  function wants(t __packed,uint val) internal pure returns(t) { unchecked {\\n    return t.wrap((t.unwrap(__packed) & wants_mask)\\n                  | ((val << (256-wants_bits) >> wants_before)));\\n  }}\\n  function gives(t __packed) internal pure returns(uint) { unchecked {\\n    return (t.unwrap(__packed) << gives_before) >> (256-gives_bits);\\n  }}\\n  function gives(t __packed,uint val) internal pure returns(t) { unchecked {\\n    return t.wrap((t.unwrap(__packed) & gives_mask)\\n                  | ((val << (256-gives_bits) >> gives_before)));\\n  }}\\n}\\n\\nlibrary OfferDetail {\\n  //some type safety for each struct\\n  type t is uint;\\n\\n  uint constant maker_bits         = 160;\\n  uint constant gasreq_bits        = 24;\\n  uint constant offer_gasbase_bits = 24;\\n  uint constant gasprice_bits      = 16;\\n\\n  uint constant maker_before         = 0;\\n  uint constant gasreq_before        = maker_before         + maker_bits        ;\\n  uint constant offer_gasbase_before = gasreq_before        + gasreq_bits       ;\\n  uint constant gasprice_before      = offer_gasbase_before + offer_gasbase_bits;\\n\\n  uint constant maker_mask         = 0x0000000000000000000000000000000000000000ffffffffffffffffffffffff;\\n  uint constant gasreq_mask        = 0xffffffffffffffffffffffffffffffffffffffff000000ffffffffffffffffff;\\n  uint constant offer_gasbase_mask = 0xffffffffffffffffffffffffffffffffffffffffffffff000000ffffffffffff;\\n  uint constant gasprice_mask      = 0xffffffffffffffffffffffffffffffffffffffffffffffffffff0000ffffffff;\\n\\n  function to_struct(t __packed) internal pure returns (OfferDetailStruct memory __s) { unchecked {\\n    __s.maker = address(uint160((t.unwrap(__packed) << maker_before) >> (256-maker_bits)));\\n    __s.gasreq = (t.unwrap(__packed) << gasreq_before) >> (256-gasreq_bits);\\n    __s.offer_gasbase = (t.unwrap(__packed) << offer_gasbase_before) >> (256-offer_gasbase_bits);\\n    __s.gasprice = (t.unwrap(__packed) << gasprice_before) >> (256-gasprice_bits);\\n  }}\\n\\n  function t_of_struct(OfferDetailStruct memory __s) internal pure returns (t) { unchecked {\\n    return pack(__s.maker, __s.gasreq, __s.offer_gasbase, __s.gasprice);\\n  }}\\n\\n  function eq(t __packed1, t __packed2) internal pure returns (bool) { unchecked {\\n    return t.unwrap(__packed1) == t.unwrap(__packed2);\\n  }}\\n\\n  function pack(address __maker, uint __gasreq, uint __offer_gasbase, uint __gasprice) internal pure returns (t) { unchecked {\\n    return t.wrap(((((0\\n                  | ((uint(uint160(__maker)) << (256-maker_bits)) >> maker_before))\\n                  | ((__gasreq << (256-gasreq_bits)) >> gasreq_before))\\n                  | ((__offer_gasbase << (256-offer_gasbase_bits)) >> offer_gasbase_before))\\n                  | ((__gasprice << (256-gasprice_bits)) >> gasprice_before)));\\n  }}\\n\\n  function unpack(t __packed) internal pure returns (address __maker, uint __gasreq, uint __offer_gasbase, uint __gasprice) { unchecked {\\n    __maker = address(uint160((t.unwrap(__packed) << maker_before) >> (256-maker_bits)));\\n    __gasreq = (t.unwrap(__packed) << gasreq_before) >> (256-gasreq_bits);\\n    __offer_gasbase = (t.unwrap(__packed) << offer_gasbase_before) >> (256-offer_gasbase_bits);\\n    __gasprice = (t.unwrap(__packed) << gasprice_before) >> (256-gasprice_bits);\\n  }}\\n\\n  function maker(t __packed) internal pure returns(address) { unchecked {\\n    return address(uint160((t.unwrap(__packed) << maker_before) >> (256-maker_bits)));\\n  }}\\n  function maker(t __packed,address val) internal pure returns(t) { unchecked {\\n    return t.wrap((t.unwrap(__packed) & maker_mask)\\n                  | ((uint(uint160(val)) << (256-maker_bits) >> maker_before)));\\n  }}\\n  function gasreq(t __packed) internal pure returns(uint) { unchecked {\\n    return (t.unwrap(__packed) << gasreq_before) >> (256-gasreq_bits);\\n  }}\\n  function gasreq(t __packed,uint val) internal pure returns(t) { unchecked {\\n    return t.wrap((t.unwrap(__packed) & gasreq_mask)\\n                  | ((val << (256-gasreq_bits) >> gasreq_before)));\\n  }}\\n  function offer_gasbase(t __packed) internal pure returns(uint) { unchecked {\\n    return (t.unwrap(__packed) << offer_gasbase_before) >> (256-offer_gasbase_bits);\\n  }}\\n  function offer_gasbase(t __packed,uint val) internal pure returns(t) { unchecked {\\n    return t.wrap((t.unwrap(__packed) & offer_gasbase_mask)\\n                  | ((val << (256-offer_gasbase_bits) >> offer_gasbase_before)));\\n  }}\\n  function gasprice(t __packed) internal pure returns(uint) { unchecked {\\n    return (t.unwrap(__packed) << gasprice_before) >> (256-gasprice_bits);\\n  }}\\n  function gasprice(t __packed,uint val) internal pure returns(t) { unchecked {\\n    return t.wrap((t.unwrap(__packed) & gasprice_mask)\\n                  | ((val << (256-gasprice_bits) >> gasprice_before)));\\n  }}\\n}\\n\\nlibrary Global {\\n  //some type safety for each struct\\n  type t is uint;\\n\\n  uint constant monitor_bits   = 160;\\n  uint constant useOracle_bits = 8;\\n  uint constant notify_bits    = 8;\\n  uint constant gasprice_bits  = 16;\\n  uint constant gasmax_bits    = 24;\\n  uint constant dead_bits      = 8;\\n\\n  uint constant monitor_before   = 0;\\n  uint constant useOracle_before = monitor_before   + monitor_bits  ;\\n  uint constant notify_before    = useOracle_before + useOracle_bits;\\n  uint constant gasprice_before  = notify_before    + notify_bits   ;\\n  uint constant gasmax_before    = gasprice_before  + gasprice_bits ;\\n  uint constant dead_before      = gasmax_before    + gasmax_bits   ;\\n\\n  uint constant monitor_mask   = 0x0000000000000000000000000000000000000000ffffffffffffffffffffffff;\\n  uint constant useOracle_mask = 0xffffffffffffffffffffffffffffffffffffffff00ffffffffffffffffffffff;\\n  uint constant notify_mask    = 0xffffffffffffffffffffffffffffffffffffffffff00ffffffffffffffffffff;\\n  uint constant gasprice_mask  = 0xffffffffffffffffffffffffffffffffffffffffffff0000ffffffffffffffff;\\n  uint constant gasmax_mask    = 0xffffffffffffffffffffffffffffffffffffffffffffffff000000ffffffffff;\\n  uint constant dead_mask      = 0xffffffffffffffffffffffffffffffffffffffffffffffffffffff00ffffffff;\\n\\n  function to_struct(t __packed) internal pure returns (GlobalStruct memory __s) { unchecked {\\n    __s.monitor = address(uint160((t.unwrap(__packed) << monitor_before) >> (256-monitor_bits)));\\n    __s.useOracle = (((t.unwrap(__packed) << useOracle_before) >> (256-useOracle_bits)) > 0);\\n    __s.notify = (((t.unwrap(__packed) << notify_before) >> (256-notify_bits)) > 0);\\n    __s.gasprice = (t.unwrap(__packed) << gasprice_before) >> (256-gasprice_bits);\\n    __s.gasmax = (t.unwrap(__packed) << gasmax_before) >> (256-gasmax_bits);\\n    __s.dead = (((t.unwrap(__packed) << dead_before) >> (256-dead_bits)) > 0);\\n  }}\\n\\n  function t_of_struct(GlobalStruct memory __s) internal pure returns (t) { unchecked {\\n    return pack(__s.monitor, __s.useOracle, __s.notify, __s.gasprice, __s.gasmax, __s.dead);\\n  }}\\n\\n  function eq(t __packed1, t __packed2) internal pure returns (bool) { unchecked {\\n    return t.unwrap(__packed1) == t.unwrap(__packed2);\\n  }}\\n\\n  function pack(address __monitor, bool __useOracle, bool __notify, uint __gasprice, uint __gasmax, bool __dead) internal pure returns (t) { unchecked {\\n    return t.wrap(((((((0\\n                  | ((uint(uint160(__monitor)) << (256-monitor_bits)) >> monitor_before))\\n                  | ((uint_of_bool(__useOracle) << (256-useOracle_bits)) >> useOracle_before))\\n                  | ((uint_of_bool(__notify) << (256-notify_bits)) >> notify_before))\\n                  | ((__gasprice << (256-gasprice_bits)) >> gasprice_before))\\n                  | ((__gasmax << (256-gasmax_bits)) >> gasmax_before))\\n                  | ((uint_of_bool(__dead) << (256-dead_bits)) >> dead_before)));\\n  }}\\n\\n  function unpack(t __packed) internal pure returns (address __monitor, bool __useOracle, bool __notify, uint __gasprice, uint __gasmax, bool __dead) { unchecked {\\n    __monitor = address(uint160((t.unwrap(__packed) << monitor_before) >> (256-monitor_bits)));\\n    __useOracle = (((t.unwrap(__packed) << useOracle_before) >> (256-useOracle_bits)) > 0);\\n    __notify = (((t.unwrap(__packed) << notify_before) >> (256-notify_bits)) > 0);\\n    __gasprice = (t.unwrap(__packed) << gasprice_before) >> (256-gasprice_bits);\\n    __gasmax = (t.unwrap(__packed) << gasmax_before) >> (256-gasmax_bits);\\n    __dead = (((t.unwrap(__packed) << dead_before) >> (256-dead_bits)) > 0);\\n  }}\\n\\n  function monitor(t __packed) internal pure returns(address) { unchecked {\\n    return address(uint160((t.unwrap(__packed) << monitor_before) >> (256-monitor_bits)));\\n  }}\\n  function monitor(t __packed,address val) internal pure returns(t) { unchecked {\\n    return t.wrap((t.unwrap(__packed) & monitor_mask)\\n                  | ((uint(uint160(val)) << (256-monitor_bits) >> monitor_before)));\\n  }}\\n  function useOracle(t __packed) internal pure returns(bool) { unchecked {\\n    return (((t.unwrap(__packed) << useOracle_before) >> (256-useOracle_bits)) > 0);\\n  }}\\n  function useOracle(t __packed,bool val) internal pure returns(t) { unchecked {\\n    return t.wrap((t.unwrap(__packed) & useOracle_mask)\\n                  | ((uint_of_bool(val) << (256-useOracle_bits) >> useOracle_before)));\\n  }}\\n  function notify(t __packed) internal pure returns(bool) { unchecked {\\n    return (((t.unwrap(__packed) << notify_before) >> (256-notify_bits)) > 0);\\n  }}\\n  function notify(t __packed,bool val) internal pure returns(t) { unchecked {\\n    return t.wrap((t.unwrap(__packed) & notify_mask)\\n                  | ((uint_of_bool(val) << (256-notify_bits) >> notify_before)));\\n  }}\\n  function gasprice(t __packed) internal pure returns(uint) { unchecked {\\n    return (t.unwrap(__packed) << gasprice_before) >> (256-gasprice_bits);\\n  }}\\n  function gasprice(t __packed,uint val) internal pure returns(t) { unchecked {\\n    return t.wrap((t.unwrap(__packed) & gasprice_mask)\\n                  | ((val << (256-gasprice_bits) >> gasprice_before)));\\n  }}\\n  function gasmax(t __packed) internal pure returns(uint) { unchecked {\\n    return (t.unwrap(__packed) << gasmax_before) >> (256-gasmax_bits);\\n  }}\\n  function gasmax(t __packed,uint val) internal pure returns(t) { unchecked {\\n    return t.wrap((t.unwrap(__packed) & gasmax_mask)\\n                  | ((val << (256-gasmax_bits) >> gasmax_before)));\\n  }}\\n  function dead(t __packed) internal pure returns(bool) { unchecked {\\n    return (((t.unwrap(__packed) << dead_before) >> (256-dead_bits)) > 0);\\n  }}\\n  function dead(t __packed,bool val) internal pure returns(t) { unchecked {\\n    return t.wrap((t.unwrap(__packed) & dead_mask)\\n                  | ((uint_of_bool(val) << (256-dead_bits) >> dead_before)));\\n  }}\\n}\\n\\nlibrary Local {\\n  //some type safety for each struct\\n  type t is uint;\\n\\n  uint constant active_bits        = 8;\\n  uint constant fee_bits           = 16;\\n  uint constant density_bits       = 112;\\n  uint constant offer_gasbase_bits = 24;\\n  uint constant lock_bits          = 8;\\n  uint constant best_bits          = 32;\\n  uint constant last_bits          = 32;\\n\\n  uint constant active_before        = 0;\\n  uint constant fee_before           = active_before        + active_bits       ;\\n  uint constant density_before       = fee_before           + fee_bits          ;\\n  uint constant offer_gasbase_before = density_before       + density_bits      ;\\n  uint constant lock_before          = offer_gasbase_before + offer_gasbase_bits;\\n  uint constant best_before          = lock_before          + lock_bits         ;\\n  uint constant last_before          = best_before          + best_bits         ;\\n\\n  uint constant active_mask        = 0x00ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\\n  uint constant fee_mask           = 0xff0000ffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\\n  uint constant density_mask       = 0xffffff0000000000000000000000000000ffffffffffffffffffffffffffffff;\\n  uint constant offer_gasbase_mask = 0xffffffffffffffffffffffffffffffffff000000ffffffffffffffffffffffff;\\n  uint constant lock_mask          = 0xffffffffffffffffffffffffffffffffffffffff00ffffffffffffffffffffff;\\n  uint constant best_mask          = 0xffffffffffffffffffffffffffffffffffffffffff00000000ffffffffffffff;\\n  uint constant last_mask          = 0xffffffffffffffffffffffffffffffffffffffffffffffffff00000000ffffff;\\n\\n  function to_struct(t __packed) internal pure returns (LocalStruct memory __s) { unchecked {\\n    __s.active = (((t.unwrap(__packed) << active_before) >> (256-active_bits)) > 0);\\n    __s.fee = (t.unwrap(__packed) << fee_before) >> (256-fee_bits);\\n    __s.density = (t.unwrap(__packed) << density_before) >> (256-density_bits);\\n    __s.offer_gasbase = (t.unwrap(__packed) << offer_gasbase_before) >> (256-offer_gasbase_bits);\\n    __s.lock = (((t.unwrap(__packed) << lock_before) >> (256-lock_bits)) > 0);\\n    __s.best = (t.unwrap(__packed) << best_before) >> (256-best_bits);\\n    __s.last = (t.unwrap(__packed) << last_before) >> (256-last_bits);\\n  }}\\n\\n  function t_of_struct(LocalStruct memory __s) internal pure returns (t) { unchecked {\\n    return pack(__s.active, __s.fee, __s.density, __s.offer_gasbase, __s.lock, __s.best, __s.last);\\n  }}\\n\\n  function eq(t __packed1, t __packed2) internal pure returns (bool) { unchecked {\\n    return t.unwrap(__packed1) == t.unwrap(__packed2);\\n  }}\\n\\n  function pack(bool __active, uint __fee, uint __density, uint __offer_gasbase, bool __lock, uint __best, uint __last) internal pure returns (t) { unchecked {\\n    return t.wrap((((((((0\\n                  | ((uint_of_bool(__active) << (256-active_bits)) >> active_before))\\n                  | ((__fee << (256-fee_bits)) >> fee_before))\\n                  | ((__density << (256-density_bits)) >> density_before))\\n                  | ((__offer_gasbase << (256-offer_gasbase_bits)) >> offer_gasbase_before))\\n                  | ((uint_of_bool(__lock) << (256-lock_bits)) >> lock_before))\\n                  | ((__best << (256-best_bits)) >> best_before))\\n                  | ((__last << (256-last_bits)) >> last_before)));\\n  }}\\n\\n  function unpack(t __packed) internal pure returns (bool __active, uint __fee, uint __density, uint __offer_gasbase, bool __lock, uint __best, uint __last) { unchecked {\\n    __active = (((t.unwrap(__packed) << active_before) >> (256-active_bits)) > 0);\\n    __fee = (t.unwrap(__packed) << fee_before) >> (256-fee_bits);\\n    __density = (t.unwrap(__packed) << density_before) >> (256-density_bits);\\n    __offer_gasbase = (t.unwrap(__packed) << offer_gasbase_before) >> (256-offer_gasbase_bits);\\n    __lock = (((t.unwrap(__packed) << lock_before) >> (256-lock_bits)) > 0);\\n    __best = (t.unwrap(__packed) << best_before) >> (256-best_bits);\\n    __last = (t.unwrap(__packed) << last_before) >> (256-last_bits);\\n  }}\\n\\n  function active(t __packed) internal pure returns(bool) { unchecked {\\n    return (((t.unwrap(__packed) << active_before) >> (256-active_bits)) > 0);\\n  }}\\n  function active(t __packed,bool val) internal pure returns(t) { unchecked {\\n    return t.wrap((t.unwrap(__packed) & active_mask)\\n                  | ((uint_of_bool(val) << (256-active_bits) >> active_before)));\\n  }}\\n  function fee(t __packed) internal pure returns(uint) { unchecked {\\n    return (t.unwrap(__packed) << fee_before) >> (256-fee_bits);\\n  }}\\n  function fee(t __packed,uint val) internal pure returns(t) { unchecked {\\n    return t.wrap((t.unwrap(__packed) & fee_mask)\\n                  | ((val << (256-fee_bits) >> fee_before)));\\n  }}\\n  function density(t __packed) internal pure returns(uint) { unchecked {\\n    return (t.unwrap(__packed) << density_before) >> (256-density_bits);\\n  }}\\n  function density(t __packed,uint val) internal pure returns(t) { unchecked {\\n    return t.wrap((t.unwrap(__packed) & density_mask)\\n                  | ((val << (256-density_bits) >> density_before)));\\n  }}\\n  function offer_gasbase(t __packed) internal pure returns(uint) { unchecked {\\n    return (t.unwrap(__packed) << offer_gasbase_before) >> (256-offer_gasbase_bits);\\n  }}\\n  function offer_gasbase(t __packed,uint val) internal pure returns(t) { unchecked {\\n    return t.wrap((t.unwrap(__packed) & offer_gasbase_mask)\\n                  | ((val << (256-offer_gasbase_bits) >> offer_gasbase_before)));\\n  }}\\n  function lock(t __packed) internal pure returns(bool) { unchecked {\\n    return (((t.unwrap(__packed) << lock_before) >> (256-lock_bits)) > 0);\\n  }}\\n  function lock(t __packed,bool val) internal pure returns(t) { unchecked {\\n    return t.wrap((t.unwrap(__packed) & lock_mask)\\n                  | ((uint_of_bool(val) << (256-lock_bits) >> lock_before)));\\n  }}\\n  function best(t __packed) internal pure returns(uint) { unchecked {\\n    return (t.unwrap(__packed) << best_before) >> (256-best_bits);\\n  }}\\n  function best(t __packed,uint val) internal pure returns(t) { unchecked {\\n    return t.wrap((t.unwrap(__packed) & best_mask)\\n                  | ((val << (256-best_bits) >> best_before)));\\n  }}\\n  function last(t __packed) internal pure returns(uint) { unchecked {\\n    return (t.unwrap(__packed) << last_before) >> (256-last_bits);\\n  }}\\n  function last(t __packed,uint val) internal pure returns(t) { unchecked {\\n    return t.wrap((t.unwrap(__packed) & last_mask)\\n                  | ((val << (256-last_bits) >> last_before)));\\n  }}\\n}\\n\",\"keccak256\":\"0x4a8144510dd78a509a164e5e33bf5d7224346b5c43ec8133a13b19633602e754\",\"license\":\"Unlicense\"},\"contracts/MgvRoot.sol\":{\"content\":\"// SPDX-License-Identifier:\\tAGPL-3.0\\n\\n// MgvRoot.sol\\n\\n// Copyright (C) 2021 Giry SAS.\\n//\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU Affero General Public License as published\\n// by the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n//\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU Affero General Public License for more details.\\n//\\n// You should have received a copy of the GNU Affero General Public License\\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\\n\\n/* `MgvRoot` and its descendants describe an orderbook-based exchange (\\\"the Mangrove\\\") where market makers *do not have to provision their offer*. See `structs.js` for a longer introduction. In a nutshell: each offer created by a maker specifies an address (`maker`) to call upon offer execution by a taker. In the normal mode of operation, the Mangrove transfers the amount to be paid by the taker to the maker, calls the maker, attempts to transfer the amount promised by the maker to the taker, and reverts if it cannot.\\n\\n   There is one Mangrove contract that manages all tradeable pairs. This reduces deployment costs for new pairs and lets market makers have all their provision for all pairs in the same place.\\n\\n   The interaction map between the different actors is as follows:\\n   <img src=\\\"./contactMap.png\\\" width=\\\"190%\\\"></img>\\n\\n   The sequence diagram of a market order is as follows:\\n   <img src=\\\"./sequenceChart.png\\\" width=\\\"190%\\\"></img>\\n\\n   There is a secondary mode of operation in which the _maker_ flashloans the sold amount to the taker.\\n\\n   The Mangrove contract is `abstract` and accomodates both modes. Two contracts, `Mangrove` and `InvertedMangrove` inherit from it, one per mode of operation.\\n\\n   The contract structure is as follows:\\n   <img src=\\\"./modular_mangrove.svg\\\" width=\\\"180%\\\"> </img>\\n */\\n\\npragma solidity ^0.8.10;\\npragma abicoder v2;\\nimport {MgvLib as ML, HasMgvEvents, IMgvMonitor, P} from \\\"./MgvLib.sol\\\";\\n\\n/* `MgvRoot` contains state variables used everywhere in the operation of the Mangrove and their related function. */\\ncontract MgvRoot is HasMgvEvents {\\n  using P.Global for P.Global.t;\\n  using P.Local for P.Local.t;\\n\\n\\n  /* # State variables */\\n  //+clear+\\n  /* The `vault` address. If a pair has fees >0, those fees are sent to the vault. */\\n  address public vault;\\n\\n  /* Global mgv configuration, encoded in a 256 bits word. The information encoded is detailed in [`structs.js`](#structs.js). */\\n  P.Global.t internal internal_global;\\n  /* Configuration mapping for each token pair of the form `outbound_tkn => inbound_tkn => P.Local.t`. The structure of each `P.Local.t` value is detailed in [`structs.js`](#structs.js). It fits in one word. */\\n  mapping(address => mapping(address => P.Local.t)) internal locals;\\n\\n  /* Checking the size of `density` is necessary to prevent overflow when `density` is used in calculations. */\\n  function checkDensity(uint density) internal pure returns (bool) { unchecked {\\n    return uint112(density) == density;\\n  }}\\n\\n  /* Checking the size of `gasprice` is necessary to prevent a) data loss when `gasprice` is copied to an `OfferDetail` struct, and b) overflow when `gasprice` is used in calculations. */\\n  function checkGasprice(uint gasprice) internal pure returns (bool) { unchecked {\\n    return uint16(gasprice) == gasprice;\\n  }}\\n\\n  /* # Configuration Reads */\\n  /* Reading the configuration for a pair involves reading the config global to all pairs and the local one. In addition, a global parameter (`gasprice`) and a local one (`density`) may be read from the oracle. */\\n  function config(address outbound_tkn, address inbound_tkn)\\n    public\\n    view\\n    returns (P.Global.t _global, P.Local.t _local)\\n  { unchecked {\\n    _global = internal_global;\\n    _local = locals[outbound_tkn][inbound_tkn];\\n    if (_global.useOracle()) {\\n      (uint gasprice, uint density) = IMgvMonitor(_global.monitor())\\n        .read(outbound_tkn, inbound_tkn);\\n      if (checkGasprice(gasprice)) {\\n        _global = _global.gasprice(gasprice);\\n      }\\n      if (checkDensity(density)) {\\n        _local = _local.density(density);\\n      }\\n    }\\n  }}\\n\\n  /* Returns the configuration in an ABI-compatible struct. Should not be called internally, would be a huge memory copying waste. Use `config` instead. */\\n  function configInfo(address outbound_tkn, address inbound_tkn)\\n    external\\n    view\\n    returns (P.GlobalStruct memory global, P.LocalStruct memory local)\\n  { unchecked {\\n    (P.Global.t _global, P.Local.t _local) = config(outbound_tkn, inbound_tkn);\\n    global = _global.to_struct();\\n    local = _local.to_struct();\\n  }}\\n\\n  /* Convenience function to check whether given pair is locked */\\n  function locked(address outbound_tkn, address inbound_tkn)\\n    external\\n    view\\n    returns (bool)\\n  {\\n    P.Local.t local = locals[outbound_tkn][inbound_tkn];\\n    return local.lock();\\n  }\\n\\n  /*\\n  # Gatekeeping\\n\\n  Gatekeeping functions are safety checks called in various places.\\n  */\\n\\n  /* `unlockedMarketOnly` protects modifying the market while an order is in progress. Since external contracts are called during orders, allowing reentrancy would, for instance, let a market maker replace offers currently on the book with worse ones. Note that the external contracts _will_ be called again after the order is complete, this time without any lock on the market.  */\\n  function unlockedMarketOnly(P.Local.t local) internal pure {\\n    require(!local.lock(), \\\"mgv/reentrancyLocked\\\");\\n  }\\n\\n  /* <a id=\\\"Mangrove/definition/liveMgvOnly\\\"></a>\\n     In case of emergency, the Mangrove can be `kill`ed. It cannot be resurrected. When a Mangrove is dead, the following operations are disabled :\\n       * Executing an offer\\n       * Sending ETH to the Mangrove the normal way. Usual [shenanigans](https://medium.com/@alexsherbuck/two-ways-to-force-ether-into-a-contract-1543c1311c56) are possible.\\n       * Creating a new offer\\n   */\\n  function liveMgvOnly(P.Global.t _global) internal pure {\\n    require(!_global.dead(), \\\"mgv/dead\\\");\\n  }\\n\\n  /* When the Mangrove is deployed, all pairs are inactive by default (since `locals[outbound_tkn][inbound_tkn]` is 0 by default). Offers on inactive pairs cannot be taken or created. They can be updated and retracted. */\\n  function activeMarketOnly(P.Global.t _global, P.Local.t _local) internal pure {\\n    liveMgvOnly(_global);\\n    require(_local.active(), \\\"mgv/inactive\\\");\\n  }\\n}\\n\",\"keccak256\":\"0x351d647a7a5a4a4d1dd1947bfd85dde77029304f3c35b43b23e66d09e6cdff40\",\"license\":\"AGPL-3.0\"},\"contracts/Strategies/OfferLogics/AaveModule.sol\":{\"content\":\"// SPDX-License-Identifier:\\tBSD-2-Clause\\n\\n//AaveLender.sol\\n\\n// Copyright (c) 2021 Giry SAS. All rights reserved.\\n\\n// Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\\n\\n// 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\\n// 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \\\"AS IS\\\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\\n\\npragma solidity ^0.8.10;\\npragma abicoder v2;\\nimport \\\"../interfaces/Aave/ILendingPool.sol\\\";\\nimport \\\"../interfaces/Aave/ILendingPoolAddressesProvider.sol\\\";\\nimport \\\"../interfaces/Aave/IPriceOracleGetter.sol\\\";\\nimport \\\"../lib/Exponential.sol\\\";\\nimport \\\"../../IERC20.sol\\\";\\nimport \\\"../../MgvLib.sol\\\";\\n\\n//import \\\"hardhat/console.sol\\\";\\n\\ncontract AaveModule is Exponential {\\n  event ErrorOnRedeem(\\n    address indexed outbound_tkn,\\n    address indexed inbound_tkn,\\n    uint indexed offerId,\\n    uint amount,\\n    string errorCode\\n  );\\n  event ErrorOnMint(\\n    address indexed outbound_tkn,\\n    address indexed inbound_tkn,\\n    uint indexed offerId,\\n    uint amount,\\n    string errorCode\\n  );\\n\\n  // address of the lendingPool\\n  ILendingPool public immutable lendingPool;\\n  IPriceOracleGetter public immutable priceOracle;\\n  uint16 referralCode;\\n\\n  constructor(address _addressesProvider, uint _referralCode) {\\n    require(\\n      uint16(_referralCode) == _referralCode,\\n      \\\"Referral code should be uint16\\\"\\n    );\\n    referralCode = uint16(referralCode); // for aave reference, put 0 for tests\\n    address _lendingPool = ILendingPoolAddressesProvider(_addressesProvider)\\n      .getLendingPool();\\n    address _priceOracle = ILendingPoolAddressesProvider(_addressesProvider)\\n      .getPriceOracle();\\n    require(_lendingPool != address(0), \\\"Invalid lendingPool address\\\");\\n    require(_priceOracle != address(0), \\\"Invalid priceOracle address\\\");\\n    lendingPool = ILendingPool(_lendingPool);\\n    priceOracle = IPriceOracleGetter(_priceOracle);\\n  }\\n\\n  /**************************************************************************/\\n  ///@notice Required functions to let `this` contract interact with Aave\\n  /**************************************************************************/\\n\\n  ///@notice approval of ctoken contract by the underlying is necessary for minting and repaying borrow\\n  ///@notice user must use this function to do so.\\n  function _approveLender(address token, uint amount) internal {\\n    IERC20(token).approve(address(lendingPool), amount);\\n  }\\n\\n  ///@notice exits markets\\n  function _exitMarket(IERC20 underlying) internal {\\n    lendingPool.setUserUseReserveAsCollateral(address(underlying), false);\\n  }\\n\\n  function _enterMarkets(IERC20[] calldata underlyings) internal {\\n    for (uint i = 0; i < underlyings.length; i++) {\\n      lendingPool.setUserUseReserveAsCollateral(address(underlyings[i]), true);\\n    }\\n  }\\n\\n  function overlying(IERC20 asset) public view returns (IERC20 aToken) {\\n    aToken = IERC20(lendingPool.getReserveData(address(asset)).aTokenAddress);\\n  }\\n\\n  // structs to avoir stack too deep in maxGettableUnderlying\\n  struct Underlying {\\n    uint ltv;\\n    uint liquidationThreshold;\\n    uint decimals;\\n    uint price;\\n  }\\n\\n  struct Account {\\n    uint collateral;\\n    uint debt;\\n    uint borrowPower;\\n    uint redeemPower;\\n    uint ltv;\\n    uint liquidationThreshold;\\n    uint health;\\n    uint balanceOfUnderlying;\\n  }\\n\\n  /// @notice Computes maximal maximal redeem capacity (R) and max borrow capacity (B|R) after R has been redeemed\\n  /// returns (R, B|R)\\n\\n  function maxGettableUnderlying(\\n    address asset,\\n    bool tryBorrow,\\n    address onBehalf\\n  ) public view returns (uint, uint) {\\n    Underlying memory underlying; // asset parameters\\n    Account memory account; // accound parameters\\n    (\\n      account.collateral,\\n      account.debt,\\n      account.borrowPower, // avgLtv * sumCollateralEth - sumDebtEth\\n      account.liquidationThreshold,\\n      account.ltv,\\n      account.health // avgLiquidityThreshold * sumCollateralEth / sumDebtEth  -- should be less than 10**18\\n    ) = lendingPool.getUserAccountData(onBehalf);\\n    DataTypes.ReserveData memory reserveData = lendingPool.getReserveData(\\n      asset\\n    );\\n    (\\n      underlying.ltv, // collateral factor for lending\\n      underlying.liquidationThreshold, // collateral factor for borrowing\\n      ,\\n      /*liquidationBonus*/\\n      underlying.decimals,\\n      /*reserveFactor*/\\n\\n    ) = DataTypes.getParams(reserveData.configuration);\\n    account.balanceOfUnderlying = IERC20(reserveData.aTokenAddress).balanceOf(\\n      onBehalf\\n    );\\n\\n    underlying.price = priceOracle.getAssetPrice(asset); // divided by 10**underlying.decimals\\n\\n    // account.redeemPower = account.liquidationThreshold * account.collateral - account.debt\\n    account.redeemPower = sub_(\\n      div_(mul_(account.liquidationThreshold, account.collateral), 10**4),\\n      account.debt\\n    );\\n    // max redeem capacity = account.redeemPower/ underlying.liquidationThreshold * underlying.price\\n    // unless account doesn't have enough collateral in asset token (hence the min())\\n\\n    uint maxRedeemableUnderlying = div_( // in 10**underlying.decimals\\n      account.redeemPower * 10**(underlying.decimals) * 10**4,\\n      mul_(underlying.liquidationThreshold, underlying.price)\\n    );\\n\\n    maxRedeemableUnderlying = min(\\n      maxRedeemableUnderlying,\\n      account.balanceOfUnderlying\\n    );\\n\\n    if (!tryBorrow) {\\n      //gas saver\\n      return (maxRedeemableUnderlying, 0);\\n    }\\n    // computing max borrow capacity on the premisses that maxRedeemableUnderlying has been redeemed.\\n    // max borrow capacity = (account.borrowPower - (ltv*redeemed)) / underlying.ltv * underlying.price\\n\\n    uint borrowPowerImpactOfRedeemInUnderlying = div_(\\n      mul_(maxRedeemableUnderlying, underlying.ltv),\\n      10**4\\n    );\\n    uint borrowPowerInUnderlying = div_(\\n      mul_(account.borrowPower, 10**underlying.decimals),\\n      underlying.price\\n    );\\n\\n    if (borrowPowerImpactOfRedeemInUnderlying > borrowPowerInUnderlying) {\\n      // no more borrowPower left after max redeem operation\\n      return (maxRedeemableUnderlying, 0);\\n    }\\n\\n    uint maxBorrowAfterRedeemInUnderlying = sub_( // max borrow power in underlying after max redeem has been withdrawn\\n      borrowPowerInUnderlying,\\n      borrowPowerImpactOfRedeemInUnderlying\\n    );\\n    return (maxRedeemableUnderlying, maxBorrowAfterRedeemInUnderlying);\\n  }\\n\\n  function aaveRedeem(\\n    uint amountToRedeem,\\n    address onBehalf,\\n    MgvLib.SingleOrder calldata order\\n  ) internal returns (uint) {\\n    try\\n      lendingPool.withdraw(order.outbound_tkn, amountToRedeem, onBehalf)\\n    returns (uint withdrawn) {\\n      //aave redeem was a success\\n      if (amountToRedeem == withdrawn) {\\n        return 0;\\n      } else {\\n        return (amountToRedeem - withdrawn);\\n      }\\n    } catch Error(string memory message) {\\n      emit ErrorOnRedeem(\\n        order.outbound_tkn,\\n        order.inbound_tkn,\\n        order.offerId,\\n        amountToRedeem,\\n        message\\n      );\\n      return amountToRedeem;\\n    }\\n  }\\n\\n  function _mint(\\n    uint amount,\\n    address token,\\n    address onBehalf\\n  ) internal {\\n    lendingPool.deposit(token, amount, onBehalf, referralCode);\\n  }\\n\\n  // adapted from https://medium.com/compound-finance/supplying-assets-to-the-compound-protocol-ec2cf5df5aa#afff\\n  // utility to supply erc20 to compound\\n  // NB `ctoken` contract MUST be approved to perform `transferFrom token` by `this` contract.\\n  /// @notice user need to approve ctoken in order to mint\\n  function aaveMint(\\n    uint amount,\\n    address onBehalf,\\n    MgvLib.SingleOrder calldata order\\n  ) internal returns (uint) {\\n    // contract must haveallowance()to spend funds on behalf ofmsg.sender for at-leastamount for the asset being deposited. This can be done via the standard ERC20 approve() method.\\n    try lendingPool.deposit(order.inbound_tkn, amount, onBehalf, referralCode) {\\n      return 0;\\n    } catch Error(string memory message) {\\n      emit ErrorOnMint(\\n        order.outbound_tkn,\\n        order.inbound_tkn,\\n        order.offerId,\\n        amount,\\n        message\\n      );\\n    } catch {\\n      emit ErrorOnMint(\\n        order.outbound_tkn,\\n        order.inbound_tkn,\\n        order.offerId,\\n        amount,\\n        \\\"unexpected\\\"\\n      );\\n    }\\n    return amount;\\n  }\\n}\\n\",\"keccak256\":\"0x7dddcd5ac8471b07c278ae181ca7924b4d494db603ba4e734e81fa972a8e915b\",\"license\":\"BSD-2-Clause\"},\"contracts/Strategies/OfferLogics/MangroveOffer.sol\":{\"content\":\"// SPDX-License-Identifier:\\tBSD-2-Clause\\n\\n// MangroveOffer.sol\\n\\n// Copyright (c) 2021 Giry SAS. All rights reserved.\\n\\n// Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\\n\\n// 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\\n// 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \\\"AS IS\\\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\\npragma solidity ^0.8.10;\\npragma abicoder v2;\\nimport \\\"../lib/AccessControlled.sol\\\";\\nimport \\\"../lib/Exponential.sol\\\";\\nimport \\\"../lib/TradeHandler.sol\\\";\\nimport \\\"../lib/consolerr/consolerr.sol\\\";\\nimport \\\"../interfaces/IOfferLogic.sol\\\";\\n\\n/// MangroveOffer is the basic building block to implement a reactive offer that interfaces with the Mangrove\\nabstract contract MangroveOffer is\\n  AccessControlled,\\n  IOfferLogic,\\n  TradeHandler,\\n  Exponential\\n{\\n  Mangrove public immutable MGV; // Address of the deployed Mangrove contract\\n\\n  // default values\\n  uint public override OFR_GASREQ = 100_000;\\n\\n  constructor(address payable _mgv) {\\n    MGV = Mangrove(_mgv);\\n  }\\n\\n  function setGasreq(uint gasreq) public override internalOrAdmin {\\n    require(uint24(gasreq) == gasreq, \\\"MangroveOffer/gasreq/overflow\\\");\\n    OFR_GASREQ = gasreq;\\n  }\\n\\n  function _transferToken(\\n    address token,\\n    address recipient,\\n    uint amount\\n  ) internal returns (bool success) {\\n    success = IERC20(token).transfer(recipient, amount);\\n  }\\n\\n  // get back any ETH that might linger in the contract\\n  function transferETH(address recipient, uint amount)\\n    external\\n    onlyAdmin\\n    returns (bool success)\\n  {\\n    (success, ) = recipient.call{value: amount}(\\\"\\\");\\n  }\\n\\n  /// trader needs to approve Mangrove to let it perform outbound token transfer at the end of the `makerExecute` function\\n  function _approveMangrove(address outbound_tkn, uint amount) internal {\\n    require(\\n      IERC20(outbound_tkn).approve(address(MGV), amount),\\n      \\\"mgvOffer/approve/Fail\\\"\\n    );\\n  }\\n\\n  /// withdraws ETH from the bounty vault of the Mangrove.\\n  /// NB: `Mangrove.fund` function need not be called by `this` so is not included here.\\n  function _withdrawFromMangrove(address receiver, uint amount)\\n    internal\\n    returns (bool noRevert)\\n  {\\n    require(MGV.withdraw(amount));\\n    (noRevert, ) = receiver.call{value: amount}(\\\"\\\");\\n  }\\n\\n  /////// Mandatory callback functions\\n\\n  // `makerExecute` is the callback function to execute all offers that were posted on Mangrove by `this` contract.\\n  // it may not be overriden although it can be customized using `__lastLook__`, `__put__` and `__get__` hooks.\\n  // NB #1: When overriding the above hooks, the Offer Maker SHOULD make sure they do not revert in order to be able to post logs in case of bad executions.\\n  // NB #2: if `makerExecute` does revert, the offer will be considered to be refusing the trade.\\n  function makerExecute(MgvLib.SingleOrder calldata order)\\n    external\\n    override\\n    onlyCaller(address(MGV))\\n    returns (bytes32 ret)\\n  {\\n    if (!__lastLook__(order)) {\\n      // hook to check order details and decide whether `this` contract should renege on the offer.\\n      emit Reneged(order.outbound_tkn, order.inbound_tkn, order.offerId);\\n      return RENEGED;\\n    }\\n    uint missingPut = __put__(order.gives, order); // implements what should be done with the liquidity that is flashswapped by the offer taker to `this` contract\\n    if (missingPut > 0) {\\n      emit PutFail(\\n        order.outbound_tkn,\\n        order.inbound_tkn,\\n        order.offerId,\\n        missingPut\\n      );\\n      return PUTFAILURE;\\n    }\\n    uint missingGet = __get__(order.wants, order); // implements how `this` contract should make the outbound tokens available\\n    if (missingGet > 0) {\\n      emit GetFail(\\n        order.outbound_tkn,\\n        order.inbound_tkn,\\n        order.offerId,\\n        missingGet\\n      );\\n      return OUTOFLIQUIDITY;\\n    }\\n  }\\n\\n  // `makerPosthook` is the callback function that is called by Mangrove *after* the offer execution.\\n  // It may not be overriden although it can be customized via the post-hooks `__posthookSuccess__`, `__posthookGetFailure__`, `__posthookReneged__` and `__posthookFallback__` (see below).\\n  // Offer Maker SHOULD make sure the overriden posthooks do not revert in order to be able to post logs in case of bad executions.\\n  function makerPosthook(\\n    MgvLib.SingleOrder calldata order,\\n    MgvLib.OrderResult calldata result\\n  ) external override onlyCaller(address(MGV)) {\\n    if (result.mgvData == \\\"mgv/tradeSuccess\\\") {\\n      // if trade was a success\\n      __posthookSuccess__(order);\\n      return;\\n    }\\n    // if trade was aborted because of a lack of liquidity\\n    if (result.makerData == OUTOFLIQUIDITY) {\\n      __posthookGetFailure__(order);\\n      return;\\n    }\\n    // if trade was reneged on during lastLook\\n    if (result.makerData == RENEGED) {\\n      __posthookReneged__(order);\\n      return;\\n    }\\n    // if trade failed unexpectedly (`makerExecute` reverted or Mangrove failed to transfer the outbound tokens to the Offer Taker)\\n    __posthookFallback__(order, result);\\n    return;\\n  }\\n\\n  ////// Customizable hooks for Taker Order'execution\\n\\n  // Override this hook to describe where the inbound token, which are flashswapped by the Offer Taker, should go during Taker Order's execution.\\n  // `amount` is the quantity of outbound tokens whose destination is to be resolved.\\n  // All tokens that are not transfered to a different contract remain listed in the balance of `this` contract\\n  function __put__(uint amount, MgvLib.SingleOrder calldata order)\\n    internal\\n    virtual\\n    returns (uint);\\n\\n  // Override this hook to implement fetching `amount` of outbound tokens, possibly from another source than `this` contract during Taker Order's execution.\\n  // For composability, return value MUST be the remaining quantity (i.e <= `amount`) of tokens remaining to be fetched.\\n  function __get__(uint amount, MgvLib.SingleOrder calldata order)\\n    internal\\n    virtual\\n    returns (uint);\\n\\n  // Override this hook to implement a last look check during Taker Order's execution.\\n  // Return value should be `true` if Taker Order is acceptable.\\n  function __lastLook__(MgvLib.SingleOrder calldata order)\\n    internal\\n    virtual\\n    returns (bool proceed)\\n  {\\n    order; //shh\\n    proceed = true;\\n  }\\n\\n  ////// Customizable post-hooks.\\n\\n  // Override this post-hook to implement what `this` contract should do when called back after a successfully executed order.\\n  function __posthookSuccess__(MgvLib.SingleOrder calldata order)\\n    internal\\n    virtual\\n  {\\n    order; // shh\\n  }\\n\\n  // Override this post-hook to implement what `this` contract should do when called back after an order that failed to be executed because of a lack of liquidity (not enough outbound tokens).\\n  function __posthookGetFailure__(MgvLib.SingleOrder calldata order)\\n    internal\\n    virtual\\n  {\\n    order;\\n  }\\n\\n  // Override this post-hook to implement what `this` contract should do when called back after an order that did not pass its last look (see `__lastLook__` hook).\\n  function __posthookReneged__(MgvLib.SingleOrder calldata order)\\n    internal\\n    virtual\\n  {\\n    order; //shh\\n  }\\n\\n  // Override this post-hook to implement fallback behavior when Taker Order's execution failed unexpectedly. Information from Mangrove is accessible in `result.mgvData` for logging purpose.\\n  function __posthookFallback__(\\n    MgvLib.SingleOrder calldata order,\\n    MgvLib.OrderResult calldata result\\n  ) internal virtual {\\n    order;\\n    result;\\n  }\\n}\\n\",\"keccak256\":\"0xdaaa65a6cb7c5299ed3d8886823f664ab2db099dfceb21d516762de761b968f4\",\"license\":\"BSD-2-Clause\"},\"contracts/Strategies/OfferLogics/MultiUsers/AaveLender.sol\":{\"content\":\"// SPDX-License-Identifier:\\tBSD-2-Clause\\n\\n//AaveLender.sol\\n\\n// Copyright (c) 2021 Giry SAS. All rights reserved.\\n\\n// Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\\n\\n// 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\\n// 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \\\"AS IS\\\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\\n\\npragma solidity ^0.8.10;\\npragma abicoder v2;\\nimport \\\"./MultiUser.sol\\\";\\nimport \\\"../AaveModule.sol\\\";\\n\\nabstract contract MultiUserAaveLender is MultiUser, AaveModule {\\n  /**************************************************************************/\\n  ///@notice Required functions to let `this` contract interact with Aave\\n  /**************************************************************************/\\n\\n  ///@notice approval of ctoken contract by the underlying is necessary for minting and repaying borrow\\n  ///@notice user must use this function to do so.\\n  function approveLender(address token, uint amount) external onlyAdmin {\\n    _approveLender(token, amount);\\n  }\\n\\n  // function mint(\\n  //   uint amount,\\n  //   address asset,\\n  //   address onBehalf\\n  // ) external onlyAdmin {\\n  //   _mint(amount, asset, onBehalf);\\n  // }\\n\\n  // tokens are fetched on Aave (on behalf of offer owner)\\n  function __get__(uint amount, MgvLib.SingleOrder calldata order)\\n    internal\\n    virtual\\n    override\\n    returns (uint)\\n  {\\n    address owner = ownerOf(\\n      order.outbound_tkn,\\n      order.inbound_tkn,\\n      order.offerId\\n    );\\n    (\\n      uint redeemable, /*maxBorrowAfterRedeem*/\\n\\n    ) = maxGettableUnderlying(order.outbound_tkn, false, owner);\\n    if (amount > redeemable) {\\n      return amount; // give up if amount is not redeemable (anti flashloan manipulation of AAVE)\\n    }\\n    // need to retreive overlyings from msg.sender (we suppose `this` is approved for that)\\n    IERC20 aToken = overlying(IERC20(order.outbound_tkn));\\n    try aToken.transferFrom(owner, address(this), amount) returns (\\n      bool \\n    ) {\\n      if (aaveRedeem(amount, address(this), order) == 0) {\\n        // amount was transfered to `owner`\\n        return 0;\\n      }\\n      emit ErrorOnRedeem(\\n        order.outbound_tkn,\\n        order.inbound_tkn,\\n        order.offerId,\\n        amount,\\n        \\\"lender/multi/redeemFailed\\\"\\n      );\\n    } catch {\\n      emit ErrorOnRedeem(\\n        order.outbound_tkn,\\n        order.inbound_tkn,\\n        order.offerId,\\n        amount,\\n        \\\"lender/multi/transferFromFail\\\"\\n      );\\n    }\\n    return amount; // nothing was fetched\\n  }\\n\\n  // received inbound token are put on Aave on behalf of offer owner\\n  function __put__(uint amount, MgvLib.SingleOrder calldata order)\\n    internal\\n    virtual\\n    override\\n    returns (uint)\\n  {\\n    //optim\\n    if (amount == 0) {\\n      return 0;\\n    }\\n    address owner = ownerOf(\\n      order.outbound_tkn,\\n      order.inbound_tkn,\\n      order.offerId\\n    );\\n    // minted Atokens are sent to owner\\n    return aaveMint(amount, owner, order);\\n  }\\n}\\n\",\"keccak256\":\"0x837234704d80b4abdc53afc0e5d4f2db015a6ea4beb99be64a9468fa0e70c89b\",\"license\":\"BSD-2-Clause\"},\"contracts/Strategies/OfferLogics/MultiUsers/Deployable/OfferProxy.sol\":{\"content\":\"// SPDX-License-Identifier:\\tBSD-2-Clause\\n\\n// AdvancedCompoundRetail.sol\\n\\n// Copyright (c) 2021 Giry SAS. All rights reserved.\\n\\n// Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\\n\\n// 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\\n// 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \\\"AS IS\\\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\\npragma solidity ^0.8.10;\\npragma abicoder v2;\\nimport \\\"../AaveLender.sol\\\";\\nimport \\\"../Persistent.sol\\\";\\n\\ncontract OfferProxy is MultiUserAaveLender, MultiUserPersistent {\\n  constructor(\\n    address _addressesProvider,\\n    address _MgvReader,\\n    address payable _MGV\\n  )\\n    AaveModule(_addressesProvider, 0)\\n    MultiUser(_MgvReader)\\n    MangroveOffer(_MGV)\\n  {\\n    setGasreq(800_000); // Offer proxy requires AAVE interactions\\n  }\\n\\n  // overrides AaveLender.__put__ with MutliUser's one in order to put inbound token directly to user account\\n  function __put__(uint amount, MgvLib.SingleOrder calldata order)\\n    internal\\n    override(MultiUser, MultiUserAaveLender)\\n    returns (uint missing)\\n  {\\n    // puts amount inbound_tkn in `this`\\n    missing = MultiUser.__put__(amount, order);\\n    // transfers the deposited tokens to owner\\n    address owner = ownerOf(\\n      order.outbound_tkn,\\n      order.inbound_tkn,\\n      order.offerId\\n    );\\n    // NOTE this could be done off chain by the owner\\n    transferToken(order.inbound_tkn, owner, amount);\\n  }\\n\\n  function __get__(uint amount, MgvLib.SingleOrder calldata order)\\n    internal\\n    override(MultiUser, MultiUserAaveLender)\\n    returns (uint)\\n  {\\n    // gets tokens from AAVE's owner deposit -- will transfer aTokens from owner first\\n    return MultiUserAaveLender.__get__(amount, order);\\n  }\\n\\n  function __posthookSuccess__(MgvLib.SingleOrder calldata order)\\n    internal\\n    override(MangroveOffer, MultiUserPersistent)\\n  {\\n    MultiUserPersistent.__posthookSuccess__(order);\\n  }\\n}\\n\",\"keccak256\":\"0x1523a85960f6353546eb009c8961378042a54944638d4f3494d6f2f5aa22cdc9\",\"license\":\"BSD-2-Clause\"},\"contracts/Strategies/OfferLogics/MultiUsers/MultiUser.sol\":{\"content\":\"// SPDX-License-Identifier:\\tBSD-2-Clause\\n\\n// MangroveOffer.sol\\n\\n// Copyright (c) 2021 Giry SAS. All rights reserved.\\n\\n// Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\\n\\n// 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\\n// 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \\\"AS IS\\\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\\npragma solidity ^0.8.10;\\npragma abicoder v2;\\nimport \\\"../MangroveOffer.sol\\\";\\nimport \\\"../../../periphery/MgvReader.sol\\\";\\n\\nabstract contract MultiUser is MangroveOffer {\\n  mapping(address => mapping(address => mapping(uint => address)))\\n    internal _offerOwners; // outbound_tkn => inbound_tkn => offerId => ownerAddress\\n\\n  mapping(address => uint) public mgvBalanceOf; // owner => WEI balance on mangrove\\n  mapping(address => mapping(address => uint)) public tokenBalanceOf; // erc20 => owner => balance on `this`\\n\\n  MgvReader immutable reader;\\n\\n  constructor(address _reader) {\\n    reader = MgvReader(_reader);\\n  }\\n\\n  // Offer management\\n  event NewOffer(\\n    address indexed outbound_tkn,\\n    address indexed inbound_tkn,\\n    uint indexed offerId,\\n    address owner\\n  );\\n\\n  function offerOwners(\\n    address outbound_tkn,\\n    address inbound_tkn,\\n    uint fromId,\\n    uint maxOffers\\n  )\\n    public\\n    view\\n    returns (\\n      uint nextId,\\n      uint[] memory offerIds,\\n      address[] memory __offerOwners\\n    )\\n  {\\n    (\\n      nextId,\\n      offerIds, /*offers*/ /*offerDetails*/\\n      ,\\n\\n    ) = reader.offerList(outbound_tkn, inbound_tkn, fromId, maxOffers);\\n    __offerOwners = new address[](offerIds.length);\\n    for (uint i = 0; i < offerIds.length; i++) {\\n      __offerOwners[i] = ownerOf(outbound_tkn, inbound_tkn, offerIds[i]);\\n    }\\n  }\\n\\n  function creditOnMgv(address owner, uint balance) internal {\\n    mgvBalanceOf[owner] += balance;\\n  }\\n\\n  function debitOnMgv(address owner, uint amount) internal {\\n    require(\\n      mgvBalanceOf[owner] >= amount,\\n      \\\"MultiOwner/debitOnMgv/insufficient\\\"\\n    );\\n    mgvBalanceOf[owner] -= amount;\\n  }\\n\\n  function creditToken(\\n    address token,\\n    address owner,\\n    uint balance\\n  ) internal {\\n    tokenBalanceOf[token][owner] += balance;\\n  }\\n\\n  function debitToken(\\n    address token,\\n    address owner,\\n    uint amount\\n  ) internal {\\n    require(\\n      tokenBalanceOf[token][owner] >= amount,\\n      \\\"MultiOwner/debitToken/insufficient\\\"\\n    );\\n    tokenBalanceOf[token][owner] -= amount;\\n  }\\n\\n  function redeemToken(address token, uint amount)\\n    external\\n    override\\n    returns (bool success)\\n  {\\n    require(msg.sender != address(this), \\\"MutliUser/noReentrancy\\\");\\n    debitToken(token, msg.sender, amount);\\n    success = _transferToken(token, msg.sender, amount);\\n  }\\n\\n  function transferToken(\\n    address token,\\n    address owner,\\n    uint amount\\n  ) internal returns (bool success) {\\n    debitToken(token, owner, amount);\\n    success = _transferToken(token, owner, amount);\\n  }\\n\\n  function addOwner(\\n    address outbound_tkn,\\n    address inbound_tkn,\\n    uint offerId,\\n    address owner\\n  ) internal {\\n    _offerOwners[outbound_tkn][inbound_tkn][offerId] = owner;\\n    emit NewOffer(outbound_tkn, inbound_tkn, offerId, owner);\\n  }\\n\\n  function ownerOf(\\n    address outbound_tkn,\\n    address inbound_tkn,\\n    uint offerId\\n  ) public view returns (address owner) {\\n    owner = _offerOwners[outbound_tkn][inbound_tkn][offerId];\\n    require(owner != address(0), \\\"multiUser/unkownOffer\\\");\\n  }\\n\\n  /// trader needs to approve Mangrove to let it perform outbound token transfer at the end of the `makerExecute` function\\n  /// Warning: anyone can approve here.\\n  function approveMangrove(address outbound_tkn, uint amount)\\n    external\\n    override\\n  {\\n    _approveMangrove(outbound_tkn, amount);\\n  }\\n\\n  /// withdraws ETH from the bounty vault of the Mangrove.\\n  /// NB: `Mangrove.fund` function need not be called by `this` so is not included here.\\n  /// Warning: this function should not be called internally for msg.sender provision is being checked\\n  function withdrawFromMangrove(address receiver, uint amount)\\n    external\\n    override\\n    returns (bool noRevert)\\n  {\\n    require(msg.sender != address(this), \\\"MutliUser/noReentrancy\\\");\\n    debitOnMgv(msg.sender, amount);\\n    return _withdrawFromMangrove(receiver, amount);\\n  }\\n\\n  function fundMangrove() external payable override {\\n    require(msg.sender != address(this), \\\"MutliUser/noReentrancy\\\");\\n    // increasing the provision of `this` contract\\n    MGV.fund{value: msg.value}();\\n    // increasing the virtual provision of owner\\n    creditOnMgv(msg.sender, msg.value);\\n  }\\n\\n  function updateUserBalanceOnMgv(address user, uint mgvBalanceBefore)\\n    internal\\n  {\\n    uint mgvBalanceAfter = MGV.balanceOf(address(this));\\n    if (mgvBalanceAfter == mgvBalanceBefore) {\\n      return;\\n    }\\n    if (mgvBalanceAfter > mgvBalanceBefore) {\\n      creditOnMgv(user, mgvBalanceAfter - mgvBalanceBefore);\\n    } else {\\n      debitOnMgv(user, mgvBalanceBefore - mgvBalanceAfter);\\n    }\\n  }\\n\\n  function newOffer(\\n    address outbound_tkn, // address of the ERC20 contract managing outbound tokens\\n    address inbound_tkn, // address of the ERC20 contract managing outbound tokens\\n    uint wants, // amount of `inbound_tkn` required for full delivery\\n    uint gives, // max amount of `outbound_tkn` promised by the offer\\n    uint gasreq, // max gas required by the offer when called. If maxUint256 is used here, default `OFR_GASREQ` will be considered instead\\n    uint gasprice, // gasprice that should be consider to compute the bounty (Mangrove's gasprice will be used if this value is lower)\\n    uint pivotId // identifier of an offer in the (`outbound_tkn,inbound_tkn`) Offer List after which the new offer should be inserted (gas cost of insertion will increase if the `pivotId` is far from the actual position of the new offer)\\n  ) external payable override returns (uint offerId) {\\n    require(msg.sender != address(this), \\\"MutliUser/noReentrancy\\\");\\n    uint weiBalanceBefore = MGV.balanceOf(address(this));\\n    if (msg.value > 0) {\\n      MGV.fund{value: msg.value}();\\n    }\\n    // this call could revert if this contract does not have the provision to cover the bounty\\n    offerId = MGV.newOffer(\\n      outbound_tkn,\\n      inbound_tkn,\\n      wants,\\n      gives,\\n      gasreq,\\n      gasprice,\\n      pivotId\\n    );\\n    //setting owner of offerId\\n    addOwner(outbound_tkn, inbound_tkn, offerId, msg.sender);\\n    //updating wei balance of owner will revert if msg.sender does not have the funds\\n    updateUserBalanceOnMgv(msg.sender, weiBalanceBefore);\\n  }\\n\\n  function updateOffer(\\n    address outbound_tkn,\\n    address inbound_tkn,\\n    uint wants,\\n    uint gives,\\n    uint gasreq,\\n    uint gasprice,\\n    uint pivotId,\\n    uint offerId\\n  ) external payable override {\\n    address owner = ownerOf(outbound_tkn, inbound_tkn, offerId);\\n    require(owner == msg.sender, \\\"mgvOffer/MultiOwner/unauthorized\\\");\\n    if (msg.value > 0) {\\n      MGV.fund{value: msg.value}();\\n    }\\n    MGV.updateOffer(\\n      outbound_tkn,\\n      inbound_tkn,\\n      wants,\\n      gives,\\n      gasreq,\\n      gasprice,\\n      pivotId,\\n      offerId\\n    );\\n    uint weiBalanceAfter = MGV.balanceOf(address(this));\\n    updateUserBalanceOnMgv(owner, weiBalanceAfter);\\n  }\\n\\n  // Retracts `offerId` from the (`outbound_tkn`,`inbound_tkn`) Offer list of Mangrove. Function call will throw if `this` contract is not the owner of `offerId`.\\n  function retractOffer(\\n    address outbound_tkn,\\n    address inbound_tkn,\\n    uint offerId,\\n    bool deprovision // if set to `true`, `this` contract will receive the remaining provision (in WEI) associated to `offerId`.\\n  ) external override returns (uint received) {\\n    require(\\n      _offerOwners[outbound_tkn][inbound_tkn][offerId] == msg.sender,\\n      \\\"mgvOffer/MultiOwner/unauthorized\\\"\\n    );\\n    received = MGV.retractOffer(\\n      outbound_tkn,\\n      inbound_tkn,\\n      offerId,\\n      deprovision\\n    );\\n    if (received > 0) {\\n      creditOnMgv(msg.sender, received);\\n    }\\n  }\\n\\n  function getMissingProvision(\\n    address outbound_tkn,\\n    address inbound_tkn,\\n    uint gasreq,\\n    uint gasprice,\\n    uint offerId\\n  ) public view override returns (uint) {\\n    uint balance;\\n    address owner = ownerOf(outbound_tkn, inbound_tkn, offerId);\\n    if (owner == address(0)) {\\n      balance = 0;\\n    } else {\\n      balance = mgvBalanceOf[owner];\\n    }\\n    return\\n      _getMissingProvision(\\n        MGV,\\n        balance,\\n        outbound_tkn,\\n        inbound_tkn,\\n        gasreq,\\n        gasprice,\\n        offerId\\n      );\\n  }\\n\\n  // put received inbound tokens on offer owner account\\n  function __put__(uint amount, MgvLib.SingleOrder calldata order)\\n    internal\\n    virtual\\n    override\\n    returns (uint)\\n  {\\n    address owner = ownerOf(\\n      order.outbound_tkn,\\n      order.inbound_tkn,\\n      order.offerId\\n    );\\n    creditToken(order.inbound_tkn, owner, amount);\\n    return 0;\\n  }\\n\\n  // get outbound tokens from offer owner account\\n  function __get__(uint amount, MgvLib.SingleOrder calldata order)\\n    internal\\n    virtual\\n    override\\n    returns (uint)\\n  {\\n    address owner = ownerOf(\\n      order.outbound_tkn,\\n      order.inbound_tkn,\\n      order.offerId\\n    );\\n    uint ownerBalance = tokenBalanceOf[order.outbound_tkn][owner];\\n    if (ownerBalance < amount) {\\n      debitToken(order.outbound_tkn, owner, ownerBalance);\\n      return (amount - ownerBalance);\\n    } else {\\n      debitToken(order.outbound_tkn, owner, amount);\\n      return 0;\\n    }\\n  }\\n}\\n\",\"keccak256\":\"0x08d6ea2e11af4cd61726d2cf4de8188217b2a9e5554ad1af0ba3e1a7b7c0fd82\",\"license\":\"BSD-2-Clause\"},\"contracts/Strategies/OfferLogics/MultiUsers/Persistent.sol\":{\"content\":\"// SPDX-License-Identifier:\\tBSD-2-Clause\\n\\n// Persistent.sol\\n\\n// Copyright (c) 2021 Giry SAS. All rights reserved.\\n\\n// Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\\n\\n// 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\\n// 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \\\"AS IS\\\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\\npragma solidity ^0.8.10;\\npragma abicoder v2;\\nimport \\\"./MultiUser.sol\\\";\\n\\n//import \\\"hardhat/console.sol\\\";\\n\\n/// MangroveOffer is the basic building block to implement a reactive offer that interfaces with the Mangrove\\nabstract contract MultiUserPersistent is MultiUser {\\n  using P.Offer for P.Offer.t;\\n  using P.OfferDetail for P.OfferDetail.t;\\n  function __posthookSuccess__(MgvLib.SingleOrder calldata order)\\n    internal\\n    virtual\\n    override\\n  {\\n    uint new_gives = order.offer.gives() - order.wants;\\n    uint new_wants = order.offer.wants() - order.gives;\\n    try\\n      MGV.updateOffer(\\n        order.outbound_tkn,\\n        order.inbound_tkn,\\n        new_wants,\\n        new_gives,\\n        order.offerDetail.gasreq(),\\n        order.offerDetail.gasprice(),\\n        order.offer.next(),\\n        order.offerId\\n      )\\n    {} catch Error(string memory message) {\\n      // density could be too low, or offer provision be insufficient\\n      emit PosthookFail(\\n        order.outbound_tkn,\\n        order.inbound_tkn,\\n        order.offerId,\\n        message\\n      );\\n    }\\n  }\\n}\\n\",\"keccak256\":\"0xf9d0e2c8ee76aff60328337b0bd579109ddccbab40c9f5ed300d934ae53a0768\",\"license\":\"BSD-2-Clause\"},\"contracts/Strategies/interfaces/Aave/DataTypes.sol\":{\"content\":\"// SPDX-License-Identifier: agpl-3.0\\n// Copyright (C) 2020 Aave\\n\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU Affero General Public License as\\n// published by the Free Software Foundation, either version 3 of the\\n// License, or any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\\n// [GNU Affero General Public License](https://www.gnu.org/licenses/agpl-3.0.en.html)\\n//for more details\\npragma solidity >=0.6.12;\\n\\nlibrary DataTypes {\\n  // refer to the whitepaper, section 1.1 basic concepts for a formal description of these properties.\\n  struct ReserveData {\\n    //stores the reserve configuration\\n    ReserveConfigurationMap configuration;\\n    //the liquidity index. Expressed in ray\\n    uint128 liquidityIndex;\\n    //variable borrow index. Expressed in ray\\n    uint128 variableBorrowIndex;\\n    //the current supply rate. Expressed in ray\\n    uint128 currentLiquidityRate;\\n    //the current variable borrow rate. Expressed in ray\\n    uint128 currentVariableBorrowRate;\\n    //the current stable borrow rate. Expressed in ray\\n    uint128 currentStableBorrowRate;\\n    uint40 lastUpdateTimestamp;\\n    //tokens addresses\\n    address aTokenAddress;\\n    address stableDebtTokenAddress;\\n    address variableDebtTokenAddress;\\n    //address of the interest rate strategy\\n    address interestRateStrategyAddress;\\n    //the id of the reserve. Represents the position in the list of the active reserves\\n    uint8 id;\\n  }\\n\\n  struct ReserveConfigurationMap {\\n    //bit 0-15: LTV\\n    //bit 16-31: Liq. threshold\\n    //bit 32-47: Liq. bonus\\n    //bit 48-55: Decimals\\n    //bit 56: Reserve is active\\n    //bit 57: reserve is frozen\\n    //bit 58: borrowing is enabled\\n    //bit 59: stable rate borrowing enabled\\n    //bit 60-63: reserved\\n    //bit 64-79: reserve factor\\n    uint data;\\n  }\\n\\n  struct UserConfigurationMap {\\n    uint data;\\n  }\\n\\n  enum InterestRateMode {\\n    NONE,\\n    STABLE,\\n    VARIABLE\\n  }\\n\\n  uint256 constant LTV_MASK =                   0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0000; // prettier-ignore\\n  uint256 constant LIQUIDATION_THRESHOLD_MASK = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0000FFFF; // prettier-ignore\\n  uint256 constant LIQUIDATION_BONUS_MASK =     0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0000FFFFFFFF; // prettier-ignore\\n  uint256 constant DECIMALS_MASK =              0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF00FFFFFFFFFFFF; // prettier-ignore\\n  uint256 constant ACTIVE_MASK =                0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFF; // prettier-ignore\\n  uint256 constant FROZEN_MASK =                0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFDFFFFFFFFFFFFFF; // prettier-ignore\\n  uint256 constant BORROWING_MASK =             0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFBFFFFFFFFFFFFFF; // prettier-ignore\\n  uint256 constant STABLE_BORROWING_MASK =      0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF7FFFFFFFFFFFFFF; // prettier-ignore\\n  uint256 constant RESERVE_FACTOR_MASK =        0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0000FFFFFFFFFFFFFFFF; // prettier-ignore\\n\\n  /// @dev For the LTV, the start bit is 0 (up to 15), hence no bitshifting is needed\\n  uint constant LIQUIDATION_THRESHOLD_START_BIT_POSITION = 16;\\n  uint constant LIQUIDATION_BONUS_START_BIT_POSITION = 32;\\n  uint constant RESERVE_DECIMALS_START_BIT_POSITION = 48;\\n  uint constant IS_ACTIVE_START_BIT_POSITION = 56;\\n  uint constant IS_FROZEN_START_BIT_POSITION = 57;\\n  uint constant BORROWING_ENABLED_START_BIT_POSITION = 58;\\n  uint constant STABLE_BORROWING_ENABLED_START_BIT_POSITION = 59;\\n  uint constant RESERVE_FACTOR_START_BIT_POSITION = 64;\\n\\n  function getParams(ReserveConfigurationMap memory configMap)\\n    internal\\n    pure\\n    returns (\\n      uint,\\n      uint,\\n      uint,\\n      uint,\\n      uint\\n    )\\n  {\\n    uint dataLocal = configMap.data;\\n    return (\\n      dataLocal & ~LTV_MASK,\\n      (dataLocal & ~LIQUIDATION_THRESHOLD_MASK) >>\\n        LIQUIDATION_THRESHOLD_START_BIT_POSITION,\\n      (dataLocal & ~LIQUIDATION_BONUS_MASK) >>\\n        LIQUIDATION_BONUS_START_BIT_POSITION,\\n      (dataLocal & ~DECIMALS_MASK) >> RESERVE_DECIMALS_START_BIT_POSITION,\\n      (dataLocal & ~RESERVE_FACTOR_MASK) >> RESERVE_FACTOR_START_BIT_POSITION\\n    );\\n  }\\n\\n  function isUsingAsCollateral(\\n    DataTypes.UserConfigurationMap memory configMap,\\n    uint reserveIndex\\n  ) internal pure returns (bool) {\\n    require(reserveIndex < 128, \\\"Invalid index\\\");\\n    return (configMap.data >> (reserveIndex * 2 + 1)) & 1 != 0;\\n  }\\n}\\n\",\"keccak256\":\"0xfc3878fa0fb4fc4a418b1971e998f268638b196cb48f4f3b0ee1e5721fc6d419\",\"license\":\"agpl-3.0\"},\"contracts/Strategies/interfaces/Aave/ILendingPool.sol\":{\"content\":\"// SPDX-License-Identifier: agpl-3.0\\n// Copyright (C) 2020 Aave\\n\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU Affero General Public License as\\n// published by the Free Software Foundation, either version 3 of the\\n// License, or any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\\n// [GNU Affero General Public License](https://www.gnu.org/licenses/agpl-3.0.en.html)\\npragma solidity >=0.6.12;\\npragma abicoder v2;\\n\\nimport {ILendingPoolAddressesProvider} from './ILendingPoolAddressesProvider.sol';\\nimport {DataTypes} from './DataTypes.sol';\\n\\ninterface ILendingPool {\\n  /**\\n   * @dev Emitted on deposit()\\n   * @param reserve The address of the underlying asset of the reserve\\n   * @param user The address initiating the deposit\\n   * @param onBehalfOf The beneficiary of the deposit, receiving the aTokens\\n   * @param amount The amount deposited\\n   * @param referral The referral code used\\n   **/\\n  event Deposit(\\n    address indexed reserve,\\n    address user,\\n    address indexed onBehalfOf,\\n    uint256 amount,\\n    uint16 indexed referral\\n  );\\n\\n  /**\\n   * @dev Emitted on withdraw()\\n   * @param reserve The address of the underlyng asset being withdrawn\\n   * @param user The address initiating the withdrawal, owner of aTokens\\n   * @param to Address that will receive the underlying\\n   * @param amount The amount to be withdrawn\\n   **/\\n  event Withdraw(address indexed reserve, address indexed user, address indexed to, uint256 amount);\\n\\n  /**\\n   * @dev Emitted on borrow() and flashLoan() when debt needs to be opened\\n   * @param reserve The address of the underlying asset being borrowed\\n   * @param user The address of the user initiating the borrow(), receiving the funds on borrow() or just\\n   * initiator of the transaction on flashLoan()\\n   * @param onBehalfOf The address that will be getting the debt\\n   * @param amount The amount borrowed out\\n   * @param borrowRateMode The rate mode: 1 for Stable, 2 for Variable\\n   * @param borrowRate The numeric rate at which the user has borrowed\\n   * @param referral The referral code used\\n   **/\\n  event Borrow(\\n    address indexed reserve,\\n    address user,\\n    address indexed onBehalfOf,\\n    uint256 amount,\\n    uint256 borrowRateMode,\\n    uint256 borrowRate,\\n    uint16 indexed referral\\n  );\\n\\n  /**\\n   * @dev Emitted on repay()\\n   * @param reserve The address of the underlying asset of the reserve\\n   * @param user The beneficiary of the repayment, getting his debt reduced\\n   * @param repayer The address of the user initiating the repay(), providing the funds\\n   * @param amount The amount repaid\\n   **/\\n  event Repay(\\n    address indexed reserve,\\n    address indexed user,\\n    address indexed repayer,\\n    uint256 amount\\n  );\\n\\n  /**\\n   * @dev Emitted on swapBorrowRateMode()\\n   * @param reserve The address of the underlying asset of the reserve\\n   * @param user The address of the user swapping his rate mode\\n   * @param rateMode The rate mode that the user wants to swap to\\n   **/\\n  event Swap(address indexed reserve, address indexed user, uint256 rateMode);\\n\\n  /**\\n   * @dev Emitted on setUserUseReserveAsCollateral()\\n   * @param reserve The address of the underlying asset of the reserve\\n   * @param user The address of the user enabling the usage as collateral\\n   **/\\n  event ReserveUsedAsCollateralEnabled(address indexed reserve, address indexed user);\\n\\n  /**\\n   * @dev Emitted on setUserUseReserveAsCollateral()\\n   * @param reserve The address of the underlying asset of the reserve\\n   * @param user The address of the user enabling the usage as collateral\\n   **/\\n  event ReserveUsedAsCollateralDisabled(address indexed reserve, address indexed user);\\n\\n  /**\\n   * @dev Emitted on rebalanceStableBorrowRate()\\n   * @param reserve The address of the underlying asset of the reserve\\n   * @param user The address of the user for which the rebalance has been executed\\n   **/\\n  event RebalanceStableBorrowRate(address indexed reserve, address indexed user);\\n\\n  /**\\n   * @dev Emitted on flashLoan()\\n   * @param target The address of the flash loan receiver contract\\n   * @param initiator The address initiating the flash loan\\n   * @param asset The address of the asset being flash borrowed\\n   * @param amount The amount flash borrowed\\n   * @param premium The fee flash borrowed\\n   * @param referralCode The referral code used\\n   **/\\n  event FlashLoan(\\n    address indexed target,\\n    address indexed initiator,\\n    address indexed asset,\\n    uint256 amount,\\n    uint256 premium,\\n    uint16 referralCode\\n  );\\n\\n  /**\\n   * @dev Emitted when the pause is triggered.\\n   */\\n  event Paused();\\n\\n  /**\\n   * @dev Emitted when the pause is lifted.\\n   */\\n  event Unpaused();\\n\\n  /**\\n   * @dev Emitted when a borrower is liquidated. This event is emitted by the LendingPool via\\n   * LendingPoolCollateral manager using a DELEGATECALL\\n   * This allows to have the events in the generated ABI for LendingPool.\\n   * @param collateralAsset The address of the underlying asset used as collateral, to receive as result of the liquidation\\n   * @param debtAsset The address of the underlying borrowed asset to be repaid with the liquidation\\n   * @param user The address of the borrower getting liquidated\\n   * @param debtToCover The debt amount of borrowed `asset` the liquidator wants to cover\\n   * @param liquidatedCollateralAmount The amount of collateral received by the liiquidator\\n   * @param liquidator The address of the liquidator\\n   * @param receiveAToken `true` if the liquidators wants to receive the collateral aTokens, `false` if he wants\\n   * to receive the underlying collateral asset directly\\n   **/\\n  event LiquidationCall(\\n    address indexed collateralAsset,\\n    address indexed debtAsset,\\n    address indexed user,\\n    uint256 debtToCover,\\n    uint256 liquidatedCollateralAmount,\\n    address liquidator,\\n    bool receiveAToken\\n  );\\n\\n  /**\\n   * @dev Emitted when the state of a reserve is updated. NOTE: This event is actually declared\\n   * in the ReserveLogic library and emitted in the updateInterestRates() function. Since the function is internal,\\n   * the event will actually be fired by the LendingPool contract. The event is therefore replicated here so it\\n   * gets added to the LendingPool ABI\\n   * @param reserve The address of the underlying asset of the reserve\\n   * @param liquidityRate The new liquidity rate\\n   * @param stableBorrowRate The new stable borrow rate\\n   * @param variableBorrowRate The new variable borrow rate\\n   * @param liquidityIndex The new liquidity index\\n   * @param variableBorrowIndex The new variable borrow index\\n   **/\\n  event ReserveDataUpdated(\\n    address indexed reserve,\\n    uint256 liquidityRate,\\n    uint256 stableBorrowRate,\\n    uint256 variableBorrowRate,\\n    uint256 liquidityIndex,\\n    uint256 variableBorrowIndex\\n  );\\n\\n  /**\\n   * @dev Deposits an `amount` of underlying asset into the reserve, receiving in return overlying aTokens.\\n   * - E.g. User deposits 100 USDC and gets in return 100 aUSDC\\n   * @param asset The address of the underlying asset to deposit\\n   * @param amount The amount to be deposited\\n   * @param onBehalfOf The address that will receive the aTokens, same as msg.sender if the user\\n   *   wants to receive them on his own wallet, or a different address if the beneficiary of aTokens\\n   *   is a different wallet\\n   * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\\n   *   0 if the action is executed directly by the user, without any middle-man\\n   **/\\n  function deposit(\\n    address asset,\\n    uint256 amount,\\n    address onBehalfOf,\\n    uint16 referralCode\\n  ) external;\\n\\n  /**\\n   * @dev Withdraws an `amount` of underlying asset from the reserve, burning the equivalent aTokens owned\\n   * E.g. User has 100 aUSDC, calls withdraw() and receives 100 USDC, burning the 100 aUSDC\\n   * @param asset The address of the underlying asset to withdraw\\n   * @param amount The underlying amount to be withdrawn\\n   *   - Send the value type(uint256).max in order to withdraw the whole aToken balance\\n   * @param to Address that will receive the underlying, same as msg.sender if the user\\n   *   wants to receive it on his own wallet, or a different address if the beneficiary is a\\n   *   different wallet\\n   * @return The final amount withdrawn\\n   **/\\n  function withdraw(\\n    address asset,\\n    uint256 amount,\\n    address to\\n  ) external returns (uint256);\\n\\n  /**\\n   * @dev Allows users to borrow a specific `amount` of the reserve underlying asset, provided that the borrower\\n   * already deposited enough collateral, or he was given enough allowance by a credit delegator on the\\n   * corresponding debt token (StableDebtToken or VariableDebtToken)\\n   * - E.g. User borrows 100 USDC passing as `onBehalfOf` his own address, receiving the 100 USDC in his wallet\\n   *   and 100 stable/variable debt tokens, depending on the `interestRateMode`\\n   * @param asset The address of the underlying asset to borrow\\n   * @param amount The amount to be borrowed\\n   * @param interestRateMode The interest rate mode at which the user wants to borrow: 1 for Stable, 2 for Variable\\n   * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\\n   *   0 if the action is executed directly by the user, without any middle-man\\n   * @param onBehalfOf Address of the user who will receive the debt. Should be the address of the borrower itself\\n   * calling the function if he wants to borrow against his own collateral, or the address of the credit delegator\\n   * if he has been given credit delegation allowance\\n   **/\\n  function borrow(\\n    address asset,\\n    uint256 amount,\\n    uint256 interestRateMode,\\n    uint16 referralCode,\\n    address onBehalfOf\\n  ) external;\\n\\n  /**\\n   * @notice Repays a borrowed `amount` on a specific reserve, burning the equivalent debt tokens owned\\n   * - E.g. User repays 100 USDC, burning 100 variable/stable debt tokens of the `onBehalfOf` address\\n   * @param asset The address of the borrowed underlying asset previously borrowed\\n   * @param amount The amount to repay\\n   * - Send the value type(uint256).max in order to repay the whole debt for `asset` on the specific `debtMode`\\n   * @param rateMode The interest rate mode at of the debt the user wants to repay: 1 for Stable, 2 for Variable\\n   * @param onBehalfOf Address of the user who will get his debt reduced/removed. Should be the address of the\\n   * user calling the function if he wants to reduce/remove his own debt, or the address of any other\\n   * other borrower whose debt should be removed\\n   * @return The final amount repaid\\n   **/\\n  function repay(\\n    address asset,\\n    uint256 amount,\\n    uint256 rateMode,\\n    address onBehalfOf\\n  ) external returns (uint256);\\n\\n  /**\\n   * @dev Allows a borrower to swap his debt between stable and variable mode, or viceversa\\n   * @param asset The address of the underlying asset borrowed\\n   * @param rateMode The rate mode that the user wants to swap to\\n   **/\\n  function swapBorrowRateMode(address asset, uint256 rateMode) external;\\n\\n  /**\\n   * @dev Rebalances the stable interest rate of a user to the current stable rate defined on the reserve.\\n   * - Users can be rebalanced if the following conditions are satisfied:\\n   *     1. Usage ratio is above 95%\\n   *     2. the current deposit APY is below REBALANCE_UP_THRESHOLD * maxVariableBorrowRate, which means that too much has been\\n   *        borrowed at a stable rate and depositors are not earning enough\\n   * @param asset The address of the underlying asset borrowed\\n   * @param user The address of the user to be rebalanced\\n   **/\\n  function rebalanceStableBorrowRate(address asset, address user) external;\\n\\n  /**\\n   * @dev Allows depositors to enable/disable a specific deposited asset as collateral\\n   * @param asset The address of the underlying asset deposited\\n   * @param useAsCollateral `true` if the user wants to use the deposit as collateral, `false` otherwise\\n   **/\\n  function setUserUseReserveAsCollateral(address asset, bool useAsCollateral) external;\\n\\n  /**\\n   * @dev Function to liquidate a non-healthy position collateral-wise, with Health Factor below 1\\n   * - The caller (liquidator) covers `debtToCover` amount of debt of the user getting liquidated, and receives\\n   *   a proportionally amount of the `collateralAsset` plus a bonus to cover market risk\\n   * @param collateralAsset The address of the underlying asset used as collateral, to receive as result of the liquidation\\n   * @param debtAsset The address of the underlying borrowed asset to be repaid with the liquidation\\n   * @param user The address of the borrower getting liquidated\\n   * @param debtToCover The debt amount of borrowed `asset` the liquidator wants to cover\\n   * @param receiveAToken `true` if the liquidators wants to receive the collateral aTokens, `false` if he wants\\n   * to receive the underlying collateral asset directly\\n   **/\\n  function liquidationCall(\\n    address collateralAsset,\\n    address debtAsset,\\n    address user,\\n    uint256 debtToCover,\\n    bool receiveAToken\\n  ) external;\\n\\n  /**\\n   * @dev Allows smartcontracts to access the liquidity of the pool within one transaction,\\n   * as long as the amount taken plus a fee is returned.\\n   * IMPORTANT There are security concerns for developers of flashloan receiver contracts that must be kept into consideration.\\n   * For further details please visit https://developers.aave.com\\n   * @param receiverAddress The address of the contract receiving the funds, implementing the IFlashLoanReceiver interface\\n   * @param assets The addresses of the assets being flash-borrowed\\n   * @param amounts The amounts amounts being flash-borrowed\\n   * @param modes Types of the debt to open if the flash loan is not returned:\\n   *   0 -> Don't open any debt, just revert if funds can't be transferred from the receiver\\n   *   1 -> Open debt at stable rate for the value of the amount flash-borrowed to the `onBehalfOf` address\\n   *   2 -> Open debt at variable rate for the value of the amount flash-borrowed to the `onBehalfOf` address\\n   * @param onBehalfOf The address  that will receive the debt in the case of using on `modes` 1 or 2\\n   * @param params Variadic packed params to pass to the receiver as extra information\\n   * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\\n   *   0 if the action is executed directly by the user, without any middle-man\\n   **/\\n  function flashLoan(\\n    address receiverAddress,\\n    address[] calldata assets,\\n    uint256[] calldata amounts,\\n    uint256[] calldata modes,\\n    address onBehalfOf,\\n    bytes calldata params,\\n    uint16 referralCode\\n  ) external;\\n\\n  /**\\n   * @dev Returns the user account data across all the reserves\\n   * @param user The address of the user\\n   * @return totalCollateralETH the total collateral in ETH of the user\\n   * @return totalDebtETH the total debt in ETH of the user\\n   * @return availableBorrowsETH the borrowing power left of the user\\n   * @return currentLiquidationThreshold the liquidation threshold of the user\\n   * @return ltv the loan to value of the user\\n   * @return healthFactor the current health factor of the user\\n   **/\\n  function getUserAccountData(address user)\\n    external\\n    view\\n    returns (\\n      uint256 totalCollateralETH,\\n      uint256 totalDebtETH,\\n      uint256 availableBorrowsETH,\\n      uint256 currentLiquidationThreshold,\\n      uint256 ltv,\\n      uint256 healthFactor\\n    );\\n\\n  function initReserve(\\n    address reserve,\\n    address aTokenAddress,\\n    address stableDebtAddress,\\n    address variableDebtAddress,\\n    address interestRateStrategyAddress\\n  ) external;\\n\\n  function setReserveInterestRateStrategyAddress(address reserve, address rateStrategyAddress)\\n    external;\\n\\n  function setConfiguration(address reserve, uint256 configuration) external;\\n\\n  /**\\n   * @dev Returns the configuration of the reserve\\n   * @param asset The address of the underlying asset of the reserve\\n   * @return The configuration of the reserve\\n   **/\\n  function getConfiguration(address asset)\\n    external\\n    view\\n    returns (DataTypes.ReserveConfigurationMap memory);\\n\\n  /**\\n   * @dev Returns the configuration of the user across all the reserves\\n   * @param user The user address\\n   * @return The configuration of the user\\n   **/\\n  function getUserConfiguration(address user)\\n    external\\n    view\\n    returns (DataTypes.UserConfigurationMap memory);\\n\\n  /**\\n   * @dev Returns the normalized income normalized income of the reserve\\n   * @param asset The address of the underlying asset of the reserve\\n   * @return The reserve's normalized income\\n   */\\n  function getReserveNormalizedIncome(address asset) external view returns (uint256);\\n\\n  /**\\n   * @dev Returns the normalized variable debt per unit of asset\\n   * @param asset The address of the underlying asset of the reserve\\n   * @return The reserve normalized variable debt\\n   */\\n  function getReserveNormalizedVariableDebt(address asset) external view returns (uint256);\\n\\n  /**\\n   * @dev Returns the state and configuration of the reserve\\n   * @param asset The address of the underlying asset of the reserve\\n   * @return The state of the reserve\\n   **/\\n  function getReserveData(address asset) external view returns (DataTypes.ReserveData memory);\\n\\n  function finalizeTransfer(\\n    address asset,\\n    address from,\\n    address to,\\n    uint256 amount,\\n    uint256 balanceFromAfter,\\n    uint256 balanceToBefore\\n  ) external;\\n\\n  function getReservesList() external view returns (address[] memory);\\n\\n  function getAddressesProvider() external view returns (ILendingPoolAddressesProvider);\\n\\n  function setPause(bool val) external;\\n\\n  function paused() external view returns (bool);\\n}\\n\",\"keccak256\":\"0x99b669c0895f7d536d4e226059b3f778d01b4ea81d739ca5c3c76afe4280d8fb\",\"license\":\"agpl-3.0\"},\"contracts/Strategies/interfaces/Aave/ILendingPoolAddressesProvider.sol\":{\"content\":\"// SPDX-License-Identifier: agpl-3.0\\n// Copyright (C) 2020 Aave\\n\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU Affero General Public License as\\n// published by the Free Software Foundation, either version 3 of the\\n// License, or any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\\n// [GNU Affero General Public License](https://www.gnu.org/licenses/agpl-3.0.en.html)\\npragma solidity >=0.6.12;\\n\\n/**\\n * @title LendingPoolAddressesProvider contract\\n * @dev Main registry of addresses part of or connected to the protocol, including permissioned roles\\n * - Acting also as factory of proxies and admin of those, so with right to change its implementations\\n * - Owned by the Aave Governance\\n * @author Aave\\n **/\\ninterface ILendingPoolAddressesProvider {\\n  event MarketIdSet(string newMarketId);\\n  event LendingPoolUpdated(address indexed newAddress);\\n  event ConfigurationAdminUpdated(address indexed newAddress);\\n  event EmergencyAdminUpdated(address indexed newAddress);\\n  event LendingPoolConfiguratorUpdated(address indexed newAddress);\\n  event LendingPoolCollateralManagerUpdated(address indexed newAddress);\\n  event PriceOracleUpdated(address indexed newAddress);\\n  event LendingRateOracleUpdated(address indexed newAddress);\\n  event ProxyCreated(bytes32 id, address indexed newAddress);\\n  event AddressSet(bytes32 id, address indexed newAddress, bool hasProxy);\\n\\n  function getMarketId() external view returns (string memory);\\n\\n  function setMarketId(string calldata marketId) external;\\n\\n  function setAddress(bytes32 id, address newAddress) external;\\n\\n  function setAddressAsProxy(bytes32 id, address impl) external;\\n\\n  function getAddress(bytes32 id) external view returns (address);\\n\\n  function getLendingPool() external view returns (address);\\n\\n  function setLendingPoolImpl(address pool) external;\\n\\n  function getLendingPoolConfigurator() external view returns (address);\\n\\n  function setLendingPoolConfiguratorImpl(address configurator) external;\\n\\n  function getLendingPoolCollateralManager() external view returns (address);\\n\\n  function setLendingPoolCollateralManager(address manager) external;\\n\\n  function getPoolAdmin() external view returns (address);\\n\\n  function setPoolAdmin(address admin) external;\\n\\n  function getEmergencyAdmin() external view returns (address);\\n\\n  function setEmergencyAdmin(address admin) external;\\n\\n  function getPriceOracle() external view returns (address);\\n\\n  function setPriceOracle(address priceOracle) external;\\n\\n  function getLendingRateOracle() external view returns (address);\\n\\n  function setLendingRateOracle(address lendingRateOracle) external;\\n}\\n\",\"keccak256\":\"0x0c4688b3a19fe59cd74c1b52e04b0e8bd57ccdcc6a9c6cb5afed8470ad9a5528\",\"license\":\"agpl-3.0\"},\"contracts/Strategies/interfaces/Aave/IPriceOracleGetter.sol\":{\"content\":\"// SPDX-License-Identifier: agpl-3.0\\n// Copyright (C) 2020 Aave\\n\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU Affero General Public License as\\n// published by the Free Software Foundation, either version 3 of the\\n// License, or any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\\n// [GNU Affero General Public License](https://www.gnu.org/licenses/agpl-3.0.en.html)\\npragma solidity >=0.6.12;\\n\\n/**\\n * @title IPriceOracleGetter interface\\n * @notice Interface for the Aave price oracle.\\n **/\\n\\ninterface IPriceOracleGetter {\\n  /**\\n   * @dev returns the asset price in ETH\\n   * @param asset the address of the asset\\n   * @return the ETH price of the asset\\n   **/\\n  function getAssetPrice(address asset) external view returns (uint256);\\n}\\n\",\"keccak256\":\"0x900c996610dbc9c49bfca99e9885c070ddac20c8bce08a041b5e79c8eafa982a\",\"license\":\"agpl-3.0\"},\"contracts/Strategies/interfaces/IOfferLogic.sol\":{\"content\":\"pragma solidity >=0.7.0;\\npragma abicoder v2;\\n\\nimport \\\"../../MgvLib.sol\\\";\\n\\ninterface IOfferLogic is IMaker {\\n  ///////////////////\\n  // MangroveOffer //\\n  ///////////////////\\n\\n  /** @notice Events */\\n\\n  // Logged whenever something went wrong during `makerPosthook` execution\\n  event PosthookFail(\\n    address indexed outbound_tkn,\\n    address indexed inbound_tkn,\\n    uint offerId,\\n    string message\\n  );\\n\\n  // Logged whenever `__get__` hook failed to fetch the totality of the requested amount\\n  event GetFail(\\n    address indexed outbound_tkn,\\n    address indexed inbound_tkn,\\n    uint offerId,\\n    uint missingAmount\\n  );\\n\\n  // Logged whenever `__put__` hook failed to deposit the totality of the requested amount\\n  event PutFail(\\n    address indexed outbound_tkn,\\n    address indexed inbound_tkn,\\n    uint offerId,\\n    uint missingAmount\\n  );\\n\\n  // Logged whenever `__lastLook__` hook returned `false`\\n  event Reneged(\\n    address indexed outbound_tkn,\\n    address indexed inbound_tkn,\\n    uint offerId\\n  );\\n\\n  // Offer logic default gas required --value is used in update and new offer if maxUint is given\\n  function OFR_GASREQ() external returns (uint);\\n\\n  // returns missing provision on Mangrove, should `offerId` be reposted using `gasreq` and `gasprice` parameters\\n  // if `offerId` is not in the `outbound_tkn,inbound_tkn` offer list, the totality of the necessary provision is returned\\n  function getMissingProvision(\\n    address outbound_tkn,\\n    address inbound_tkn,\\n    uint gasreq,\\n    uint gasprice,\\n    uint offerId\\n  ) external view returns (uint);\\n\\n  // Changing OFR_GASREQ of the logic\\n  function setGasreq(uint gasreq) external;\\n\\n  function redeemToken(address token, uint amount)\\n    external\\n    returns (bool success);\\n\\n  function approveMangrove(address outbound_tkn, uint amount) external;\\n\\n  function withdrawFromMangrove(address receiver, uint amount)\\n    external\\n    returns (bool noRevert);\\n\\n  function fundMangrove() external payable;\\n\\n  function newOffer(\\n    address outbound_tkn, // address of the ERC20 contract managing outbound tokens\\n    address inbound_tkn, // address of the ERC20 contract managing outbound tokens\\n    uint wants, // amount of `inbound_tkn` required for full delivery\\n    uint gives, // max amount of `outbound_tkn` promised by the offer\\n    uint gasreq, // max gas required by the offer when called. If maxUint256 is used here, default `OFR_GASREQ` will be considered instead\\n    uint gasprice, // gasprice that should be consider to compute the bounty (Mangrove's gasprice will be used if this value is lower)\\n    uint pivotId // identifier of an offer in the (`outbound_tkn,inbound_tkn`) Offer List after which the new offer should be inserted (gas cost of insertion will increase if the `pivotId` is far from the actual position of the new offer)\\n  ) external payable returns (uint offerId);\\n\\n  function updateOffer(\\n    address outbound_tkn,\\n    address inbound_tkn,\\n    uint wants,\\n    uint gives,\\n    uint gasreq,\\n    uint gasprice,\\n    uint pivotId,\\n    uint offerId\\n  ) external payable;\\n\\n  function retractOffer(\\n    address outbound_tkn,\\n    address inbound_tkn,\\n    uint offerId,\\n    bool deprovision // if set to `true`, `this` contract will receive the remaining provision (in WEI) associated to `offerId`.\\n  ) external returns (uint received);\\n}\\n\",\"keccak256\":\"0xb06be7c9a12510b5d6447660d10f08a207ef480b82069993440326078bd4e5e8\"},\"contracts/Strategies/lib/AccessControlled.sol\":{\"content\":\"// SPDX-License-Identifier:\\tBSD-2-Clause\\n\\n// AccessedControlled.sol\\n\\n// Copyright (c) 2021 Giry SAS. All rights reserved.\\n\\n// Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\\n\\n// 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\\n// 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \\\"AS IS\\\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\\npragma solidity ^0.8.10;\\npragma abicoder v2;\\n\\ncontract AccessControlled {\\n  address public admin;\\n\\n  constructor() {\\n    admin = msg.sender;\\n  }\\n\\n  modifier onlyCaller(address caller) {\\n    require(\\n      caller == address(0) || msg.sender == caller,\\n      \\\"AccessControlled/Invalid\\\"\\n    );\\n    _;\\n  }\\n\\n  modifier onlyAdmin() {\\n    require(msg.sender == admin, \\\"AccessControlled/Invalid\\\");\\n    _;\\n  }\\n\\n  modifier internalOrAdmin() {\\n    require(\\n      msg.sender == admin || msg.sender == address(this),\\n      \\\"AccessControlled/Invalid\\\"\\n    );\\n    _;\\n  }\\n\\n  function setAdmin(address _admin) external onlyAdmin {\\n    admin = _admin;\\n  }\\n}\\n\",\"keccak256\":\"0xf551c965f2bd8fa04bc83c05b5a7bdbe14d04dac8ee89caadf52a3696ac77b34\",\"license\":\"BSD-2-Clause\"},\"contracts/Strategies/lib/CarefulMath.sol\":{\"content\":\"// SPDX-License-Identifier:\\tBSD-3-Clause\\n\\n// Copyright 2020 Compound Labs, Inc.\\n\\n// Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\\n\\n// 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\\n\\n// 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\\n\\n// 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.\\n\\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \\\"AS IS\\\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\\n\\npragma solidity ^0.8.10;\\n\\n/**\\n * @title Careful Math\\n * @author Compound\\n * @notice Derived from OpenZeppelin's SafeMath library\\n *         https://github.com/OpenZeppelin/openzeppelin-solidity/blob/master/contracts/math/SafeMath.sol\\n */\\ncontract CarefulMath {\\n  /**\\n   * @dev Possible error codes that we can return\\n   */\\n  enum MathError {\\n    NO_ERROR,\\n    DIVISION_BY_ZERO,\\n    INTEGER_OVERFLOW,\\n    INTEGER_UNDERFLOW\\n  }\\n\\n  /**\\n   * @dev Multiplies two numbers, returns an error on overflow.\\n   */\\n  function mulUInt(uint a, uint b) internal pure returns (MathError, uint) {\\n    if (a == 0) {\\n      return (MathError.NO_ERROR, 0);\\n    }\\n\\n    uint c = a * b;\\n\\n    if (c / a != b) {\\n      return (MathError.INTEGER_OVERFLOW, 0);\\n    } else {\\n      return (MathError.NO_ERROR, c);\\n    }\\n  }\\n\\n  /**\\n   * @dev Integer division of two numbers, truncating the quotient.\\n   */\\n  function divUInt(uint a, uint b) internal pure returns (MathError, uint) {\\n    if (b == 0) {\\n      return (MathError.DIVISION_BY_ZERO, 0);\\n    }\\n\\n    return (MathError.NO_ERROR, a / b);\\n  }\\n\\n  /**\\n   * @dev Subtracts two numbers, returns an error on overflow (i.e. if subtrahend is greater than minuend).\\n   */\\n  function subUInt(uint a, uint b) internal pure returns (MathError, uint) {\\n    if (b <= a) {\\n      return (MathError.NO_ERROR, a - b);\\n    } else {\\n      return (MathError.INTEGER_UNDERFLOW, 0);\\n    }\\n  }\\n\\n  /**\\n   * @dev Adds two numbers, returns an error on overflow.\\n   */\\n  function addUInt(uint a, uint b) internal pure returns (MathError, uint) {\\n    uint c = a + b;\\n\\n    if (c >= a) {\\n      return (MathError.NO_ERROR, c);\\n    } else {\\n      return (MathError.INTEGER_OVERFLOW, 0);\\n    }\\n  }\\n\\n  /**\\n   * @dev add a and b and then subtract c\\n   */\\n  function addThenSubUInt(\\n    uint a,\\n    uint b,\\n    uint c\\n  ) internal pure returns (MathError, uint) {\\n    (MathError err0, uint sum) = addUInt(a, b);\\n\\n    if (err0 != MathError.NO_ERROR) {\\n      return (err0, 0);\\n    }\\n\\n    return subUInt(sum, c);\\n  }\\n\\n  /**\\n   * @dev min and max functions\\n   */\\n  function min(uint a, uint b) internal pure returns (uint) {\\n    return (a < b ? a : b);\\n  }\\n\\n  function max(uint a, uint b) internal pure returns (uint) {\\n    return (a > b ? a : b);\\n  }\\n\\n  uint constant MAXUINT = type(uint).max;\\n  uint constant MAXUINT96 = type(uint96).max;\\n  uint constant MAXUINT24 = type(uint24).max;\\n}\\n\",\"keccak256\":\"0xa2358b7355c4fd9a439fe13450332bad7b7cd2087215c1b744448dd581d32b51\",\"license\":\"BSD-3-Clause\"},\"contracts/Strategies/lib/Exponential.sol\":{\"content\":\"// SPDX-License-Identifier:\\tBSD-3-Clause\\n\\n// Copyright 2020 Compound Labs, Inc.\\n\\n// Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\\n\\n// 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\\n\\n// 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\\n\\n// 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.\\n\\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \\\"AS IS\\\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\\n\\npragma solidity ^0.8.10;\\n\\nimport \\\"./CarefulMath.sol\\\";\\nimport \\\"./ExponentialNoError.sol\\\";\\n\\n/**\\n * @title Exponential module for storing fixed-precision decimals\\n * @author Compound\\n * @dev Legacy contract for compatibility reasons with existing contracts that still use MathError\\n * @notice Exp is a struct which stores decimals with a fixed precision of 18 decimal places.\\n *         Thus, if we wanted to store the 5.1, mantissa would store 5.1e18. That is:\\n *         `Exp({mantissa: 5100000000000000000})`.\\n */\\ncontract Exponential is CarefulMath, ExponentialNoError {\\n  /**\\n   * @dev Creates an exponential from numerator and denominator values.\\n   *      Note: Returns an error if (`num` * 10e18) > MAX_INT,\\n   *            or if `denom` is zero.\\n   */\\n  function getExp(uint num, uint denom)\\n    internal\\n    pure\\n    returns (MathError, Exp memory)\\n  {\\n    (MathError err0, uint scaledNumerator) = mulUInt(num, expScale);\\n    if (err0 != MathError.NO_ERROR) {\\n      return (err0, Exp({mantissa: 0}));\\n    }\\n\\n    (MathError err1, uint rational) = divUInt(scaledNumerator, denom);\\n    if (err1 != MathError.NO_ERROR) {\\n      return (err1, Exp({mantissa: 0}));\\n    }\\n\\n    return (MathError.NO_ERROR, Exp({mantissa: rational}));\\n  }\\n\\n  /**\\n   * @dev Adds two exponentials, returning a new exponential.\\n   */\\n  function addExp(Exp memory a, Exp memory b)\\n    internal\\n    pure\\n    returns (MathError, Exp memory)\\n  {\\n    (MathError error, uint result) = addUInt(a.mantissa, b.mantissa);\\n\\n    return (error, Exp({mantissa: result}));\\n  }\\n\\n  /**\\n   * @dev Subtracts two exponentials, returning a new exponential.\\n   */\\n  function subExp(Exp memory a, Exp memory b)\\n    internal\\n    pure\\n    returns (MathError, Exp memory)\\n  {\\n    (MathError error, uint result) = subUInt(a.mantissa, b.mantissa);\\n\\n    return (error, Exp({mantissa: result}));\\n  }\\n\\n  /**\\n   * @dev Multiply an Exp by a scalar, returning a new Exp.\\n   */\\n  function mulScalar(Exp memory a, uint scalar)\\n    internal\\n    pure\\n    returns (MathError, Exp memory)\\n  {\\n    (MathError err0, uint scaledMantissa) = mulUInt(a.mantissa, scalar);\\n    if (err0 != MathError.NO_ERROR) {\\n      return (err0, Exp({mantissa: 0}));\\n    }\\n\\n    return (MathError.NO_ERROR, Exp({mantissa: scaledMantissa}));\\n  }\\n\\n  /**\\n   * @dev Multiply an Exp by a scalar, then truncate to return an unsigned integer.\\n   */\\n  function mulScalarTruncate(Exp memory a, uint scalar)\\n    internal\\n    pure\\n    returns (MathError, uint)\\n  {\\n    (MathError err, Exp memory product) = mulScalar(a, scalar);\\n    if (err != MathError.NO_ERROR) {\\n      return (err, 0);\\n    }\\n\\n    return (MathError.NO_ERROR, truncate(product));\\n  }\\n\\n  /**\\n   * @dev Multiply an Exp by a scalar, truncate, then add an to an unsigned integer, returning an unsigned integer.\\n   */\\n  function mulScalarTruncateAddUInt(\\n    Exp memory a,\\n    uint scalar,\\n    uint addend\\n  ) internal pure returns (MathError, uint) {\\n    (MathError err, Exp memory product) = mulScalar(a, scalar);\\n    if (err != MathError.NO_ERROR) {\\n      return (err, 0);\\n    }\\n\\n    return addUInt(truncate(product), addend);\\n  }\\n\\n  /**\\n   * @dev Divide an Exp by a scalar, returning a new Exp.\\n   */\\n  function divScalar(Exp memory a, uint scalar)\\n    internal\\n    pure\\n    returns (MathError, Exp memory)\\n  {\\n    (MathError err0, uint descaledMantissa) = divUInt(a.mantissa, scalar);\\n    if (err0 != MathError.NO_ERROR) {\\n      return (err0, Exp({mantissa: 0}));\\n    }\\n\\n    return (MathError.NO_ERROR, Exp({mantissa: descaledMantissa}));\\n  }\\n\\n  /**\\n   * @dev Divide a scalar by an Exp, returning a new Exp.\\n   */\\n  function divScalarByExp(uint scalar, Exp memory divisor)\\n    internal\\n    pure\\n    returns (MathError, Exp memory)\\n  {\\n    /*\\n          We are doing this as:\\n          getExp(mulUInt(expScale, scalar), divisor.mantissa)\\n\\n          How it works:\\n          Exp = a / b;\\n          Scalar = s;\\n          `s / (a / b)` = `b * s / a` and since for an Exp `a = mantissa, b = expScale`\\n        */\\n    (MathError err0, uint numerator) = mulUInt(expScale, scalar);\\n    if (err0 != MathError.NO_ERROR) {\\n      return (err0, Exp({mantissa: 0}));\\n    }\\n    return getExp(numerator, divisor.mantissa);\\n  }\\n\\n  /**\\n   * @dev Divide a scalar by an Exp, then truncate to return an unsigned integer.\\n   */\\n  function divScalarByExpTruncate(uint scalar, Exp memory divisor)\\n    internal\\n    pure\\n    returns (MathError, uint)\\n  {\\n    (MathError err, Exp memory fraction) = divScalarByExp(scalar, divisor);\\n    if (err != MathError.NO_ERROR) {\\n      return (err, 0);\\n    }\\n\\n    return (MathError.NO_ERROR, truncate(fraction));\\n  }\\n\\n  /**\\n   * @dev Multiplies two exponentials, returning a new exponential.\\n   */\\n  function mulExp(Exp memory a, Exp memory b)\\n    internal\\n    pure\\n    returns (MathError, Exp memory)\\n  {\\n    (MathError err0, uint doubleScaledProduct) = mulUInt(\\n      a.mantissa,\\n      b.mantissa\\n    );\\n    if (err0 != MathError.NO_ERROR) {\\n      return (err0, Exp({mantissa: 0}));\\n    }\\n\\n    // We add half the scale before dividing so that we get rounding instead of truncation.\\n    //  See \\\"Listing 6\\\" and text above it at https://accu.org/index.php/journals/1717\\n    // Without this change, a result like 6.6...e-19 will be truncated to 0 instead of being rounded to 1e-18.\\n    (MathError err1, uint doubleScaledProductWithHalfScale) = addUInt(\\n      halfExpScale,\\n      doubleScaledProduct\\n    );\\n    if (err1 != MathError.NO_ERROR) {\\n      return (err1, Exp({mantissa: 0}));\\n    }\\n\\n    (MathError err2, uint product) = divUInt(\\n      doubleScaledProductWithHalfScale,\\n      expScale\\n    );\\n    // The only error `div` can return is MathError.DIVISION_BY_ZERO but we control `expScale` and it is not zero.\\n    assert(err2 == MathError.NO_ERROR);\\n\\n    return (MathError.NO_ERROR, Exp({mantissa: product}));\\n  }\\n\\n  /**\\n   * @dev Multiplies two exponentials given their mantissas, returning a new exponential.\\n   */\\n  function mulExp(uint a, uint b)\\n    internal\\n    pure\\n    returns (MathError, Exp memory)\\n  {\\n    return mulExp(Exp({mantissa: a}), Exp({mantissa: b}));\\n  }\\n\\n  /**\\n   * @dev Multiplies three exponentials, returning a new exponential.\\n   */\\n  function mulExp3(\\n    Exp memory a,\\n    Exp memory b,\\n    Exp memory c\\n  ) internal pure returns (MathError, Exp memory) {\\n    (MathError err, Exp memory ab) = mulExp(a, b);\\n    if (err != MathError.NO_ERROR) {\\n      return (err, ab);\\n    }\\n    return mulExp(ab, c);\\n  }\\n\\n  /**\\n   * @dev Divides two exponentials, returning a new exponential.\\n   *     (a/scale) / (b/scale) = (a/scale) * (scale/b) = a/b,\\n   *  which we can scale as an Exp by calling getExp(a.mantissa, b.mantissa)\\n   */\\n  function divExp(Exp memory a, Exp memory b)\\n    internal\\n    pure\\n    returns (MathError, Exp memory)\\n  {\\n    return getExp(a.mantissa, b.mantissa);\\n  }\\n}\\n\",\"keccak256\":\"0x3a873831731e9b9a954af7ed596540cb3a176f9611360b2711ea6514c045ec21\",\"license\":\"BSD-3-Clause\"},\"contracts/Strategies/lib/ExponentialNoError.sol\":{\"content\":\"// SPDX-License-Identifier:\\tBSD-3-Clause\\n\\n// Copyright 2020 Compound Labs, Inc.\\n\\n// Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\\n\\n// 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\\n\\n// 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\\n\\n// 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.\\n\\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \\\"AS IS\\\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\\n\\npragma solidity ^0.8.10;\\n\\n/**\\n * @title Exponential module for storing fixed-precision decimals\\n * @author Compound\\n * @notice Exp is a struct which stores decimals with a fixed precision of 18 decimal places.\\n *         Thus, if we wanted to store the 5.1, mantissa would store 5.1e18. That is:\\n *         `Exp({mantissa: 5100000000000000000})`.\\n */\\ncontract ExponentialNoError {\\n  uint constant expScale = 1e18;\\n  uint constant doubleScale = 1e36;\\n  uint constant halfExpScale = expScale / 2;\\n  uint constant mantissaOne = expScale;\\n\\n  struct Exp {\\n    uint mantissa;\\n  }\\n\\n  struct Double {\\n    uint mantissa;\\n  }\\n\\n  /**\\n   * @dev Truncates the given exp to a whole number value.\\n   *      For example, truncate(Exp{mantissa: 15 * expScale}) = 15\\n   */\\n  function truncate(Exp memory exp) internal pure returns (uint) {\\n    // Note: We are not using careful math here as we're performing a division that cannot fail\\n    return exp.mantissa / expScale;\\n  }\\n\\n  /**\\n   * @dev Multiply an Exp by a scalar, then truncate to return an unsigned integer.\\n   */\\n  function mul_ScalarTruncate(Exp memory a, uint scalar)\\n    internal\\n    pure\\n    returns (uint)\\n  {\\n    Exp memory product = mul_(a, scalar);\\n    return truncate(product);\\n  }\\n\\n  /**\\n   * @dev Multiply an Exp by a scalar, truncate, then add an to an unsigned integer, returning an unsigned integer.\\n   */\\n  function mul_ScalarTruncateAddUInt(\\n    Exp memory a,\\n    uint scalar,\\n    uint addend\\n  ) internal pure returns (uint) {\\n    Exp memory product = mul_(a, scalar);\\n    return add_(truncate(product), addend);\\n  }\\n\\n  /**\\n   * @dev Checks if first Exp is less than second Exp.\\n   */\\n  function lessThanExp(Exp memory left, Exp memory right)\\n    internal\\n    pure\\n    returns (bool)\\n  {\\n    return left.mantissa < right.mantissa;\\n  }\\n\\n  /**\\n   * @dev Checks if left Exp <= right Exp.\\n   */\\n  function lessThanOrEqualExp(Exp memory left, Exp memory right)\\n    internal\\n    pure\\n    returns (bool)\\n  {\\n    return left.mantissa <= right.mantissa;\\n  }\\n\\n  /**\\n   * @dev Checks if left Exp > right Exp.\\n   */\\n  function greaterThanExp(Exp memory left, Exp memory right)\\n    internal\\n    pure\\n    returns (bool)\\n  {\\n    return left.mantissa > right.mantissa;\\n  }\\n\\n  /**\\n   * @dev returns true if Exp is exactly zero\\n   */\\n  function isZeroExp(Exp memory value) internal pure returns (bool) {\\n    return value.mantissa == 0;\\n  }\\n\\n  function safe224(uint n, string memory errorMessage)\\n    internal\\n    pure\\n    returns (uint224)\\n  {\\n    require(n < 2**224, errorMessage);\\n    return uint224(n);\\n  }\\n\\n  function safe32(uint n, string memory errorMessage)\\n    internal\\n    pure\\n    returns (uint32)\\n  {\\n    require(n < 2**32, errorMessage);\\n    return uint32(n);\\n  }\\n\\n  function add_(Exp memory a, Exp memory b) internal pure returns (Exp memory) {\\n    return Exp({mantissa: add_(a.mantissa, b.mantissa)});\\n  }\\n\\n  function add_(Double memory a, Double memory b)\\n    internal\\n    pure\\n    returns (Double memory)\\n  {\\n    return Double({mantissa: add_(a.mantissa, b.mantissa)});\\n  }\\n\\n  function add_(uint a, uint b) internal pure returns (uint) {\\n    return add_(a, b, \\\"addition overflow\\\");\\n  }\\n\\n  function add_(\\n    uint a,\\n    uint b,\\n    string memory errorMessage\\n  ) internal pure returns (uint) {\\n    uint c = a + b;\\n    require(c >= a, errorMessage);\\n    return c;\\n  }\\n\\n  function sub_(Exp memory a, Exp memory b) internal pure returns (Exp memory) {\\n    return Exp({mantissa: sub_(a.mantissa, b.mantissa)});\\n  }\\n\\n  function sub_(Double memory a, Double memory b)\\n    internal\\n    pure\\n    returns (Double memory)\\n  {\\n    return Double({mantissa: sub_(a.mantissa, b.mantissa)});\\n  }\\n\\n  function sub_(uint a, uint b) internal pure returns (uint) {\\n    return sub_(a, b, \\\"subtraction underflow\\\");\\n  }\\n\\n  function sub_(\\n    uint a,\\n    uint b,\\n    string memory errorMessage\\n  ) internal pure returns (uint) {\\n    require(b <= a, errorMessage);\\n    return a - b;\\n  }\\n\\n  function mul_(Exp memory a, Exp memory b) internal pure returns (Exp memory) {\\n    return Exp({mantissa: mul_(a.mantissa, b.mantissa) / expScale});\\n  }\\n\\n  function mul_(Exp memory a, uint b) internal pure returns (Exp memory) {\\n    return Exp({mantissa: mul_(a.mantissa, b)});\\n  }\\n\\n  function mul_(uint a, Exp memory b) internal pure returns (uint) {\\n    return mul_(a, b.mantissa) / expScale;\\n  }\\n\\n  function mul_(Double memory a, Double memory b)\\n    internal\\n    pure\\n    returns (Double memory)\\n  {\\n    return Double({mantissa: mul_(a.mantissa, b.mantissa) / doubleScale});\\n  }\\n\\n  function mul_(Double memory a, uint b) internal pure returns (Double memory) {\\n    return Double({mantissa: mul_(a.mantissa, b)});\\n  }\\n\\n  function mul_(uint a, Double memory b) internal pure returns (uint) {\\n    return mul_(a, b.mantissa) / doubleScale;\\n  }\\n\\n  function mul_(uint a, uint b) internal pure returns (uint) {\\n    return mul_(a, b, \\\"multiplication overflow\\\");\\n  }\\n\\n  function mul_(\\n    uint a,\\n    uint b,\\n    string memory errorMessage\\n  ) internal pure returns (uint) {\\n    if (a == 0 || b == 0) {\\n      return 0;\\n    }\\n    uint c = a * b;\\n    require(c / a == b, errorMessage);\\n    return c;\\n  }\\n\\n  function div_(Exp memory a, Exp memory b) internal pure returns (Exp memory) {\\n    return Exp({mantissa: div_(mul_(a.mantissa, expScale), b.mantissa)});\\n  }\\n\\n  function div_(Exp memory a, uint b) internal pure returns (Exp memory) {\\n    return Exp({mantissa: div_(a.mantissa, b)});\\n  }\\n\\n  function div_(uint a, Exp memory b) internal pure returns (uint) {\\n    return div_(mul_(a, expScale), b.mantissa);\\n  }\\n\\n  function div_(Double memory a, Double memory b)\\n    internal\\n    pure\\n    returns (Double memory)\\n  {\\n    return Double({mantissa: div_(mul_(a.mantissa, doubleScale), b.mantissa)});\\n  }\\n\\n  function div_(Double memory a, uint b) internal pure returns (Double memory) {\\n    return Double({mantissa: div_(a.mantissa, b)});\\n  }\\n\\n  function div_(uint a, Double memory b) internal pure returns (uint) {\\n    return div_(mul_(a, doubleScale), b.mantissa);\\n  }\\n\\n  function div_(uint a, uint b) internal pure returns (uint) {\\n    return div_(a, b, \\\"divide by zero\\\");\\n  }\\n\\n  function div_(\\n    uint a,\\n    uint b,\\n    string memory errorMessage\\n  ) internal pure returns (uint) {\\n    require(b > 0, errorMessage);\\n    return a / b;\\n  }\\n\\n  function fraction(uint a, uint b) internal pure returns (Double memory) {\\n    return Double({mantissa: div_(mul_(a, doubleScale), b)});\\n  }\\n}\\n\",\"keccak256\":\"0x375fc6f9cacdbd8f98c6296a539d93e4ed8038f958abdc1e762873b8f64d7e0e\",\"license\":\"BSD-3-Clause\"},\"contracts/Strategies/lib/TradeHandler.sol\":{\"content\":\"// SPDX-License-Identifier:\\tBSD-2-Clause\\n\\n// TradeHandler.sol\\n\\n// Copyright (c) 2021 Giry SAS. All rights reserved.\\n\\n// Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\\n\\n// 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\\n// 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \\\"AS IS\\\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\\npragma solidity ^0.8.10;\\npragma abicoder v2;\\n\\nimport \\\"../../Mangrove.sol\\\";\\nimport \\\"../../MgvLib.sol\\\";\\n\\n\\n\\n//import \\\"hardhat/console.sol\\\";\\n\\ncontract TradeHandler {\\n  using P.Offer for P.Offer.t;\\n  using P.OfferDetail for P.OfferDetail.t;\\n  using P.Global for P.Global.t;\\n  using P.Local for P.Local.t;\\n  // internal bytes32 to select appropriate posthook\\n  bytes32 constant RENEGED = \\\"mgvOffer/reneged\\\";\\n  bytes32 constant OUTOFLIQUIDITY = \\\"mgvOffer/outOfLiquidity\\\";\\n  bytes32 constant PUTFAILURE = \\\"mgvOffer/putFailure\\\";\\n\\n  /// @notice extracts old offer from the order that is received from the Mangrove\\n  function unpackOfferFromOrder(MgvLib.SingleOrder calldata order)\\n    internal\\n    pure\\n    returns (\\n      uint offer_wants,\\n      uint offer_gives,\\n      uint gasreq,\\n      uint gasprice\\n    )\\n  {\\n    gasreq = order.offerDetail.gasreq();\\n    gasprice = order.offerDetail.gasprice();\\n    offer_wants = order.offer.wants();\\n    offer_gives = order.offer.gives();\\n  }\\n\\n  function _getMissingProvision(\\n    Mangrove mgv,\\n    uint balance, // offer owner balance on Mangrove\\n    address outbound_tkn,\\n    address inbound_tkn,\\n    uint gasreq,\\n    uint gasprice,\\n    uint offerId\\n  ) internal view returns (uint) {\\n    (P.Global.t globalData, P.Local.t localData) = mgv.config(\\n      outbound_tkn,\\n      inbound_tkn\\n    );\\n    P.OfferDetail.t offerDetailData = mgv.offerDetails(\\n      outbound_tkn,\\n      inbound_tkn,\\n      offerId\\n    );\\n    uint _gp;\\n    if (globalData.gasprice() > gasprice) {\\n      _gp = globalData.gasprice();\\n    } else {\\n      _gp = gasprice;\\n    }\\n    uint bounty = (gasreq + localData.offer_gasbase()) *\\n      _gp *\\n      10**9; // in WEI\\n    uint currentProvisionLocked = (offerDetailData.gasreq() +\\n      offerDetailData.offer_gasbase()) * \\n      offerDetailData.gasprice() *\\n      10**9;\\n    uint currentProvision = currentProvisionLocked + balance;\\n    return (currentProvision >= bounty ? 0 : bounty - currentProvision);\\n  }\\n\\n  //queries the mangrove to get current gasprice (considered to compute bounty)\\n  function _getCurrentGasPrice(Mangrove mgv) internal view returns (uint) {\\n    (P.Global.t global_pack, ) = mgv.config(address(0), address(0));\\n    return global_pack.gasprice();\\n  }\\n\\n  //truncate some bytes into a byte32 word\\n  function truncateBytes(bytes memory data) internal pure returns (bytes32 w) {\\n    assembly {\\n      w := mload(add(data, 32))\\n    }\\n  }\\n\\n  function bytesOfWord(bytes32 w) internal pure returns (bytes memory) {\\n    bytes memory b = new bytes(32);\\n    assembly {\\n      mstore(add(b, 32), w)\\n    }\\n    return b;\\n  }\\n}\\n\",\"keccak256\":\"0x4314accef17ab12eec4a79f3bcbdee0b50cedcb02ec0a117a59139ce4697e6e5\",\"license\":\"BSD-2-Clause\"},\"contracts/Strategies/lib/consolerr/consolerr.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\npragma solidity >=0.6.10 <=0.8.10;\\n\\n/*\\n * Error logging\\n * Author: Zac Williamson, AZTEC\\n * Licensed under the Apache 2.0 license\\n */\\n\\nlibrary consolerr {\\n  function errorBytes(string memory reasonString, bytes memory varA)\\n    internal\\n    pure\\n  {\\n    (bytes32 revertPtr, bytes32 errorPtr) = initErrorPtr();\\n    appendString(reasonString, errorPtr);\\n    appendBytes(varA, errorPtr);\\n\\n    assembly {\\n      revert(revertPtr, add(mload(errorPtr), 0x44))\\n    }\\n  }\\n\\n  function error(string memory reasonString, bytes32 varA) internal pure {\\n    (bytes32 revertPtr, bytes32 errorPtr) = initErrorPtr();\\n    appendString(reasonString, errorPtr);\\n    append0x(errorPtr);\\n    appendBytes32(varA, errorPtr);\\n\\n    assembly {\\n      revert(revertPtr, add(mload(errorPtr), 0x44))\\n    }\\n  }\\n\\n  function error(\\n    string memory reasonString,\\n    bytes32 varA,\\n    bytes32 varB\\n  ) internal pure {\\n    (bytes32 revertPtr, bytes32 errorPtr) = initErrorPtr();\\n    appendString(reasonString, errorPtr);\\n    append0x(errorPtr);\\n    appendBytes32(varA, errorPtr);\\n    appendComma(errorPtr);\\n    append0x(errorPtr);\\n    appendBytes32(varB, errorPtr);\\n\\n    assembly {\\n      revert(revertPtr, add(mload(errorPtr), 0x44))\\n    }\\n  }\\n\\n  function error(\\n    string memory reasonString,\\n    bytes32 varA,\\n    bytes32 varB,\\n    bytes32 varC\\n  ) internal pure {\\n    (bytes32 revertPtr, bytes32 errorPtr) = initErrorPtr();\\n    appendString(reasonString, errorPtr);\\n    append0x(errorPtr);\\n    appendBytes32(varA, errorPtr);\\n    appendComma(errorPtr);\\n    append0x(errorPtr);\\n    appendBytes32(varB, errorPtr);\\n    appendComma(errorPtr);\\n    append0x(errorPtr);\\n    appendBytes32(varC, errorPtr);\\n\\n    assembly {\\n      revert(revertPtr, add(mload(errorPtr), 0x44))\\n    }\\n  }\\n\\n  function errorBytes32(string memory reasonString, bytes32 varA)\\n    internal\\n    pure\\n  {\\n    error(reasonString, varA);\\n  }\\n\\n  function errorBytes32(\\n    string memory reasonString,\\n    bytes32 varA,\\n    bytes32 varB\\n  ) internal pure {\\n    error(reasonString, varA, varB);\\n  }\\n\\n  function errorBytes32(\\n    string memory reasonString,\\n    bytes32 varA,\\n    bytes32 varB,\\n    bytes32 varC\\n  ) internal pure {\\n    error(reasonString, varA, varB, varC);\\n  }\\n\\n  function errorAddress(string memory reasonString, address varA)\\n    internal\\n    pure\\n  {\\n    (bytes32 revertPtr, bytes32 errorPtr) = initErrorPtr();\\n    appendString(reasonString, errorPtr);\\n    appendAddress(varA, errorPtr);\\n\\n    assembly {\\n      revert(revertPtr, add(mload(errorPtr), 0x44))\\n    }\\n  }\\n\\n  function errorAddress(\\n    string memory reasonString,\\n    address varA,\\n    address varB\\n  ) internal pure {\\n    (bytes32 revertPtr, bytes32 errorPtr) = initErrorPtr();\\n    appendString(reasonString, errorPtr);\\n    appendAddress(varA, errorPtr);\\n    appendComma(errorPtr);\\n    appendAddress(varB, errorPtr);\\n\\n    assembly {\\n      revert(revertPtr, add(mload(errorPtr), 0x44))\\n    }\\n  }\\n\\n  function errorAddress(\\n    string memory reasonString,\\n    address varA,\\n    address varB,\\n    address varC\\n  ) internal pure {\\n    (bytes32 revertPtr, bytes32 errorPtr) = initErrorPtr();\\n    appendString(reasonString, errorPtr);\\n    appendAddress(varA, errorPtr);\\n    appendComma(errorPtr);\\n    appendAddress(varB, errorPtr);\\n    appendComma(errorPtr);\\n    appendAddress(varC, errorPtr);\\n\\n    assembly {\\n      revert(revertPtr, add(mload(errorPtr), 0x44))\\n    }\\n  }\\n\\n  function errorUint(string memory reasonString, uint varA) internal pure {\\n    (bytes32 revertPtr, bytes32 errorPtr) = initErrorPtr();\\n    appendString(reasonString, errorPtr);\\n    appendUint(varA, errorPtr);\\n\\n    assembly {\\n      revert(revertPtr, add(mload(errorPtr), 0x44))\\n    }\\n  }\\n\\n  function errorUint(\\n    string memory reasonString,\\n    uint varA,\\n    uint varB\\n  ) internal pure {\\n    (bytes32 revertPtr, bytes32 errorPtr) = initErrorPtr();\\n    appendString(reasonString, errorPtr);\\n    appendUint(varA, errorPtr);\\n    appendComma(errorPtr);\\n    appendUint(varB, errorPtr);\\n\\n    assembly {\\n      revert(revertPtr, add(mload(errorPtr), 0x44))\\n    }\\n  }\\n\\n  function errorUint(\\n    string memory reasonString,\\n    uint varA,\\n    uint varB,\\n    uint varC\\n  ) internal pure {\\n    (bytes32 revertPtr, bytes32 errorPtr) = initErrorPtr();\\n    appendString(reasonString, errorPtr);\\n    appendUint(varA, errorPtr);\\n    appendComma(errorPtr);\\n    appendUint(varB, errorPtr);\\n    appendComma(errorPtr);\\n    appendUint(varC, errorPtr);\\n\\n    assembly {\\n      revert(revertPtr, add(mload(errorPtr), 0x44))\\n    }\\n  }\\n\\n  function toAscii(bytes32 input)\\n    internal\\n    pure\\n    returns (bytes32 hi, bytes32 lo)\\n  {\\n    assembly {\\n      for {\\n        let j := 0\\n      } lt(j, 32) {\\n        j := add(j, 0x01)\\n      } {\\n        let slice := add(0x30, and(input, 0xf))\\n        if gt(slice, 0x39) {\\n          slice := add(slice, 39)\\n        }\\n        lo := add(lo, shl(mul(8, j), slice))\\n        input := shr(4, input)\\n      }\\n      for {\\n        let k := 0\\n      } lt(k, 32) {\\n        k := add(k, 0x01)\\n      } {\\n        let slice := add(0x30, and(input, 0xf))\\n        if gt(slice, 0x39) {\\n          slice := add(slice, 39)\\n        }\\n        hi := add(hi, shl(mul(8, k), slice))\\n        input := shr(4, input)\\n      }\\n    }\\n  }\\n\\n  function appendComma(bytes32 stringPtr) internal pure {\\n    assembly {\\n      let stringLen := mload(stringPtr)\\n\\n      mstore(add(stringPtr, add(stringLen, 0x20)), \\\", \\\")\\n      mstore(stringPtr, add(stringLen, 2))\\n    }\\n  }\\n\\n  function append0x(bytes32 stringPtr) internal pure {\\n    assembly {\\n      let stringLen := mload(stringPtr)\\n      mstore(add(stringPtr, add(stringLen, 0x20)), \\\"0x\\\")\\n      mstore(stringPtr, add(stringLen, 2))\\n    }\\n  }\\n\\n  function appendString(string memory toAppend, bytes32 stringPtr)\\n    internal\\n    pure\\n  {\\n    assembly {\\n      let appendLen := mload(toAppend)\\n      let stringLen := mload(stringPtr)\\n      let appendPtr := add(stringPtr, add(0x20, stringLen))\\n      for {\\n        let i := 0\\n      } lt(i, appendLen) {\\n        i := add(i, 0x20)\\n      } {\\n        mstore(add(appendPtr, i), mload(add(toAppend, add(i, 0x20))))\\n      }\\n\\n      // update string length\\n      mstore(stringPtr, add(stringLen, appendLen))\\n    }\\n  }\\n\\n  function appendBytes(bytes memory toAppend, bytes32 stringPtr) internal pure {\\n    uint bytesLen;\\n    bytes32 inPtr;\\n    assembly {\\n      bytesLen := mload(toAppend)\\n      inPtr := add(toAppend, 0x20)\\n    }\\n\\n    for (uint i = 0; i < bytesLen; i += 0x20) {\\n      bytes32 slice;\\n      assembly {\\n        slice := mload(inPtr)\\n        inPtr := add(inPtr, 0x20)\\n      }\\n      appendBytes32(slice, stringPtr);\\n    }\\n\\n    uint offset = bytesLen % 0x20;\\n    if (offset > 0) {\\n      // update length\\n      assembly {\\n        let lengthReduction := sub(0x20, offset)\\n        let len := mload(stringPtr)\\n        mstore(stringPtr, sub(len, lengthReduction))\\n      }\\n    }\\n  }\\n\\n  function appendBytes32(bytes32 input, bytes32 stringPtr) internal pure {\\n    assembly {\\n      let hi\\n      let lo\\n      for {\\n        let j := 0\\n      } lt(j, 32) {\\n        j := add(j, 0x01)\\n      } {\\n        let slice := add(0x30, and(input, 0xf))\\n        slice := add(slice, mul(39, gt(slice, 0x39)))\\n        lo := add(lo, shl(mul(8, j), slice))\\n        input := shr(4, input)\\n      }\\n      for {\\n        let k := 0\\n      } lt(k, 32) {\\n        k := add(k, 0x01)\\n      } {\\n        let slice := add(0x30, and(input, 0xf))\\n        if gt(slice, 0x39) {\\n          slice := add(slice, 39)\\n        }\\n        hi := add(hi, shl(mul(8, k), slice))\\n        input := shr(4, input)\\n      }\\n\\n      let stringLen := mload(stringPtr)\\n\\n      // mstore(add(stringPtr, add(stringLen, 0x20)), '0x')\\n      mstore(add(stringPtr, add(stringLen, 0x20)), hi)\\n      mstore(add(stringPtr, add(stringLen, 0x40)), lo)\\n      mstore(stringPtr, add(stringLen, 0x40))\\n    }\\n  }\\n\\n  function appendAddress(address input, bytes32 stringPtr) internal pure {\\n    assembly {\\n      let hi\\n      let lo\\n      for {\\n        let j := 0\\n      } lt(j, 8) {\\n        j := add(j, 0x01)\\n      } {\\n        let slice := add(0x30, and(input, 0xf))\\n        slice := add(slice, mul(39, gt(slice, 0x39)))\\n        lo := add(lo, shl(mul(8, j), slice))\\n        input := shr(4, input)\\n      }\\n\\n      lo := shl(192, lo)\\n      for {\\n        let k := 0\\n      } lt(k, 32) {\\n        k := add(k, 0x01)\\n      } {\\n        let slice := add(0x30, and(input, 0xf))\\n        if gt(slice, 0x39) {\\n          slice := add(slice, 39)\\n        }\\n        hi := add(hi, shl(mul(8, k), slice))\\n        input := shr(4, input)\\n      }\\n\\n      let stringLen := mload(stringPtr)\\n\\n      mstore(add(stringPtr, add(stringLen, 0x20)), \\\"0x\\\")\\n      mstore(add(stringPtr, add(stringLen, 0x22)), hi)\\n      mstore(add(stringPtr, add(stringLen, 0x42)), lo)\\n      mstore(stringPtr, add(stringLen, 42))\\n    }\\n  }\\n\\n  function appendUint(uint input, bytes32 stringPtr) internal pure {\\n    assembly {\\n      // Clear out some low bytes\\n      let result := mload(0x40)\\n      if lt(result, 0x200) {\\n        result := 0x200\\n      }\\n      mstore(add(result, 0xa0), mload(0x40))\\n      mstore(add(result, 0xc0), mload(0x60))\\n      mstore(add(result, 0xe0), mload(0x80))\\n      mstore(add(result, 0x100), mload(0xa0))\\n      mstore(add(result, 0x120), mload(0xc0))\\n      mstore(add(result, 0x140), mload(0xe0))\\n      mstore(add(result, 0x160), mload(0x100))\\n      mstore(add(result, 0x180), mload(0x120))\\n      mstore(add(result, 0x1a0), mload(0x140))\\n\\n      // Store lookup table that maps an integer from 0 to 99 into a 2-byte ASCII equivalent\\n      mstore(\\n        0x00,\\n        0x0000000000000000000000000000000000000000000000000000000000003030\\n      )\\n      mstore(\\n        0x20,\\n        0x3031303230333034303530363037303830393130313131323133313431353136\\n      )\\n      mstore(\\n        0x40,\\n        0x3137313831393230323132323233323432353236323732383239333033313332\\n      )\\n      mstore(\\n        0x60,\\n        0x3333333433353336333733383339343034313432343334343435343634373438\\n      )\\n      mstore(\\n        0x80,\\n        0x3439353035313532353335343535353635373538353936303631363236333634\\n      )\\n      mstore(\\n        0xa0,\\n        0x3635363636373638363937303731373237333734373537363737373837393830\\n      )\\n      mstore(\\n        0xc0,\\n        0x3831383238333834383538363837383838393930393139323933393439353936\\n      )\\n      mstore(\\n        0xe0,\\n        0x3937393839390000000000000000000000000000000000000000000000000000\\n      )\\n\\n      // Convert integer into string slices\\n      function slice(v) -> y {\\n        y := add(\\n          add(\\n            add(\\n              add(\\n                and(mload(shl(1, mod(v, 100))), 0xffff),\\n                shl(16, and(mload(shl(1, mod(div(v, 100), 100))), 0xffff))\\n              ),\\n              add(\\n                shl(32, and(mload(shl(1, mod(div(v, 10000), 100))), 0xffff)),\\n                shl(48, and(mload(shl(1, mod(div(v, 1000000), 100))), 0xffff))\\n              )\\n            ),\\n            add(\\n              add(\\n                shl(\\n                  64,\\n                  and(mload(shl(1, mod(div(v, 100000000), 100))), 0xffff)\\n                ),\\n                shl(\\n                  80,\\n                  and(mload(shl(1, mod(div(v, 10000000000), 100))), 0xffff)\\n                )\\n              ),\\n              add(\\n                shl(\\n                  96,\\n                  and(mload(shl(1, mod(div(v, 1000000000000), 100))), 0xffff)\\n                ),\\n                shl(\\n                  112,\\n                  and(mload(shl(1, mod(div(v, 100000000000000), 100))), 0xffff)\\n                )\\n              )\\n            )\\n          ),\\n          add(\\n            add(\\n              add(\\n                shl(\\n                  128,\\n                  and(\\n                    mload(shl(1, mod(div(v, 10000000000000000), 100))),\\n                    0xffff\\n                  )\\n                ),\\n                shl(\\n                  144,\\n                  and(\\n                    mload(shl(1, mod(div(v, 1000000000000000000), 100))),\\n                    0xffff\\n                  )\\n                )\\n              ),\\n              add(\\n                shl(\\n                  160,\\n                  and(\\n                    mload(shl(1, mod(div(v, 100000000000000000000), 100))),\\n                    0xffff\\n                  )\\n                ),\\n                shl(\\n                  176,\\n                  and(\\n                    mload(shl(1, mod(div(v, 10000000000000000000000), 100))),\\n                    0xffff\\n                  )\\n                )\\n              )\\n            ),\\n            add(\\n              add(\\n                shl(\\n                  192,\\n                  and(\\n                    mload(shl(1, mod(div(v, 1000000000000000000000000), 100))),\\n                    0xffff\\n                  )\\n                ),\\n                shl(\\n                  208,\\n                  and(\\n                    mload(\\n                      shl(1, mod(div(v, 100000000000000000000000000), 100))\\n                    ),\\n                    0xffff\\n                  )\\n                )\\n              ),\\n              add(\\n                shl(\\n                  224,\\n                  and(\\n                    mload(\\n                      shl(1, mod(div(v, 10000000000000000000000000000), 100))\\n                    ),\\n                    0xffff\\n                  )\\n                ),\\n                shl(\\n                  240,\\n                  and(\\n                    mload(\\n                      shl(1, mod(div(v, 1000000000000000000000000000000), 100))\\n                    ),\\n                    0xffff\\n                  )\\n                )\\n              )\\n            )\\n          )\\n        )\\n      }\\n\\n      mstore(0x100, 0x00)\\n      mstore(0x120, 0x00)\\n      mstore(0x140, slice(input))\\n      input := div(input, 100000000000000000000000000000000)\\n      if input {\\n        mstore(0x120, slice(input))\\n        input := div(input, 100000000000000000000000000000000)\\n        if input {\\n          mstore(0x100, slice(input))\\n        }\\n      }\\n\\n      function getMsbBytePosition(inp) -> y {\\n        inp := sub(\\n          inp,\\n          0x3030303030303030303030303030303030303030303030303030303030303030\\n        )\\n        let v := and(\\n          add(\\n            inp,\\n            0x7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f\\n          ),\\n          0x8080808080808080808080808080808080808080808080808080808080808080\\n        )\\n        v := or(v, shr(1, v))\\n        v := or(v, shr(2, v))\\n        v := or(v, shr(4, v))\\n        v := or(v, shr(8, v))\\n        v := or(v, shr(16, v))\\n        v := or(v, shr(32, v))\\n        v := or(v, shr(64, v))\\n        v := or(v, shr(128, v))\\n        y := mul(\\n          iszero(iszero(inp)),\\n          and(\\n            div(\\n              0x201f1e1d1c1b1a191817161514131211100f0e0d0c0b0a090807060504030201,\\n              add(shr(8, v), 1)\\n            ),\\n            0xff\\n          )\\n        )\\n      }\\n\\n      let len := getMsbBytePosition(mload(0x140))\\n      if mload(0x120) {\\n        len := add(getMsbBytePosition(mload(0x120)), 32)\\n        if mload(0x100) {\\n          len := add(getMsbBytePosition(mload(0x100)), 64)\\n        }\\n      }\\n\\n      let currentStringLength := mload(stringPtr)\\n\\n      let writePtr := add(stringPtr, add(currentStringLength, 0x20))\\n\\n      let offset := sub(96, len)\\n      // mstore(result, len)\\n      mstore(writePtr, mload(add(0x100, offset)))\\n      mstore(add(writePtr, 0x20), mload(add(0x120, offset)))\\n      mstore(add(writePtr, 0x40), mload(add(0x140, offset)))\\n\\n      // // update length\\n      mstore(stringPtr, add(currentStringLength, len))\\n\\n      mstore(0x40, mload(add(result, 0xa0)))\\n      mstore(0x60, mload(add(result, 0xc0)))\\n      mstore(0x80, mload(add(result, 0xe0)))\\n      mstore(0xa0, mload(add(result, 0x100)))\\n      mstore(0xc0, mload(add(result, 0x120)))\\n      mstore(0xe0, mload(add(result, 0x140)))\\n      mstore(0x100, mload(add(result, 0x160)))\\n      mstore(0x120, mload(add(result, 0x180)))\\n      mstore(0x140, mload(add(result, 0x1a0)))\\n    }\\n  }\\n\\n  function initErrorPtr() internal pure returns (bytes32, bytes32) {\\n    bytes32 mPtr;\\n    bytes32 errorPtr;\\n    assembly {\\n      mPtr := mload(0x40)\\n      if lt(mPtr, 0x200) {\\n        // our uint -> base 10 ascii method requires about 0x200 bytes of mem\\n        mPtr := 0x200\\n      }\\n      mstore(0x40, add(mPtr, 0x1000)) // let's reserve a LOT of memory for our error string.\\n      mstore(\\n        mPtr,\\n        0x08c379a000000000000000000000000000000000000000000000000000000000\\n      )\\n      mstore(add(mPtr, 0x04), 0x20)\\n      mstore(add(mPtr, 0x24), 0)\\n      errorPtr := add(mPtr, 0x24)\\n    }\\n\\n    return (mPtr, errorPtr);\\n  }\\n}\\n\",\"keccak256\":\"0xdd26de611844a0be35b87ce93daac2daec0c7f9983a3403bf04841e51b9eb409\",\"license\":\"Apache-2.0\"},\"contracts/periphery/MgvReader.sol\":{\"content\":\"// SPDX-License-Identifier:\\tAGPL-3.0\\n\\n// MgvReader.sol\\n\\n// Copyright (C) 2021 Giry SAS.\\n//\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU Affero General Public License as published\\n// by the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n//\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU Affero General Public License for more details.\\n//\\n// You should have received a copy of the GNU Affero General Public License\\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\\npragma solidity ^0.8.10;\\npragma abicoder v2;\\nimport {MgvLib as ML, P} from \\\"../MgvLib.sol\\\";\\n\\ninterface MangroveLike {\\n  function best(address, address) external view returns (uint);\\n\\n  function offers(\\n    address,\\n    address,\\n    uint\\n  ) external view returns (P.Offer.t);\\n\\n  function offerDetails(\\n    address,\\n    address,\\n    uint\\n  ) external view returns (P.OfferDetail.t);\\n\\n  function offerInfo(\\n    address,\\n    address,\\n    uint\\n  ) external view returns (P.OfferStruct memory, P.OfferDetailStruct memory);\\n\\n  function config(address, address) external view returns (P.Global.t, P.Local.t);\\n}\\n\\ncontract MgvReader {\\n  using P.Offer for P.Offer.t;\\n  using P.Global for P.Global.t;\\n  using P.Local for P.Local.t;\\n  MangroveLike immutable mgv;\\n\\n  constructor(address _mgv) {\\n    mgv = MangroveLike(payable(_mgv));\\n  }\\n\\n  /*\\n   * Returns two uints.\\n   *\\n   * `startId` is the id of the best live offer with id equal or greater than\\n   * `fromId`, 0 if there is no such offer.\\n   *\\n   * `length` is 0 if `startId == 0`. Other it is the number of live offers as good or worse than the offer with\\n   * id `startId`.\\n   */\\n  function offerListEndPoints(\\n    address outbound_tkn,\\n    address inbound_tkn,\\n    uint fromId,\\n    uint maxOffers\\n  ) public view returns (uint startId, uint length) { unchecked {\\n    if (fromId == 0) {\\n      startId = mgv.best(outbound_tkn, inbound_tkn);\\n    } else {\\n      startId = mgv.offers(outbound_tkn, inbound_tkn, fromId).gives()\\n      > 0\\n        ? fromId\\n        : 0;\\n    }\\n\\n    uint currentId = startId;\\n\\n    while (currentId != 0 && length < maxOffers) {\\n      currentId = mgv.offers(outbound_tkn, inbound_tkn, currentId).next();\\n      length = length + 1;\\n    }\\n\\n    return (startId, length);\\n  }}\\n\\n  // Returns the orderbook for the outbound_tkn/inbound_tkn pair in packed form. First number is id of next offer (0 is we're done). First array is ids, second is offers (as bytes32), third is offerDetails (as bytes32). Array will be of size `min(# of offers in out/in list, maxOffers)`.\\n  function packedOfferList(\\n    address outbound_tkn,\\n    address inbound_tkn,\\n    uint fromId,\\n    uint maxOffers\\n  )\\n    public\\n    view\\n    returns (\\n      uint,\\n      uint[] memory,\\n      P.Offer.t[] memory,\\n      P.OfferDetail.t[] memory\\n    )\\n  { unchecked {\\n    (uint currentId, uint length) = offerListEndPoints(\\n      outbound_tkn,\\n      inbound_tkn,\\n      fromId,\\n      maxOffers\\n    );\\n\\n    uint[] memory offerIds = new uint[](length);\\n    P.Offer.t[] memory offers = new P.Offer.t[](length);\\n    P.OfferDetail.t[] memory details = new P.OfferDetail.t[](length);\\n\\n    uint i = 0;\\n\\n    while (currentId != 0 && i < length) {\\n      offerIds[i] = currentId;\\n      offers[i] = mgv.offers(outbound_tkn, inbound_tkn, currentId);\\n      details[i] = mgv.offerDetails(outbound_tkn, inbound_tkn, currentId);\\n      currentId = offers[i].next();\\n      i = i + 1;\\n    }\\n\\n    return (currentId, offerIds, offers, details);\\n  }}\\n  // Returns the orderbook for the outbound_tkn/inbound_tkn pair in unpacked form. First number is id of next offer (0 if we're done). First array is ids, second is offers (as structs), third is offerDetails (as structs). Array will be of size `min(# of offers in out/in list, maxOffers)`.\\n  function offerList(\\n    address outbound_tkn,\\n    address inbound_tkn,\\n    uint fromId,\\n    uint maxOffers\\n  )\\n    public\\n    view\\n    returns (\\n      uint,\\n      uint[] memory,\\n      P.OfferStruct[] memory,\\n      P.OfferDetailStruct[] memory\\n    )\\n  { unchecked {\\n    (uint currentId, uint length) = offerListEndPoints(\\n      outbound_tkn,\\n      inbound_tkn,\\n      fromId,\\n      maxOffers\\n    );\\n\\n    uint[] memory offerIds = new uint[](length);\\n    P.OfferStruct[] memory offers = new P.OfferStruct[](length);\\n    P.OfferDetailStruct[] memory details = new P.OfferDetailStruct[](length);\\n\\n    uint i = 0;\\n    while (currentId != 0 && i < length) {\\n      offerIds[i] = currentId;\\n      (offers[i], details[i]) = mgv.offerInfo(\\n        outbound_tkn,\\n        inbound_tkn,\\n        currentId\\n      );\\n      currentId = offers[i].next;\\n      i = i + 1;\\n    }\\n\\n    return (currentId, offerIds, offers, details);\\n  }}\\n\\n  function getProvision(\\n    address outbound_tkn,\\n    address inbound_tkn,\\n    uint ofr_gasreq,\\n    uint ofr_gasprice\\n  ) external view returns (uint) { unchecked {\\n    (P.Global.t global, P.Local.t local) = mgv.config(outbound_tkn, inbound_tkn);\\n    uint _gp;\\n    uint global_gasprice = global.gasprice();\\n    if (global_gasprice > ofr_gasprice) {\\n      _gp = global_gasprice;\\n    } else {\\n      _gp = ofr_gasprice;\\n    }\\n    return\\n      (ofr_gasreq + local.offer_gasbase()) *\\n      _gp *\\n      10**9;\\n  }}\\n}\\n\",\"keccak256\":\"0xc9d736c8818e71607db0aad34bdfef79cf3b1dbd7ae019f466b9a8bb237c2e95\",\"license\":\"AGPL-3.0\"}},\"version\":1}",
  "bytecode": "0x610100604052620186a06001553480156200001957600080fd5b506040516200420a3803806200420a8339810160408190526200003c9162000317565b600080546001600160a01b031916331781556001600160a01b03808316608052831660a052839062000072565b60405180910390fd5b6005805461ffff19811661ffff90911617905560408051630261bf8b60e01b815290516000916001600160a01b03851691630261bf8b916004808201926020929091908290030181865afa158015620000cf573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190620000f591906200036b565b90506000836001600160a01b031663fca513a86040518163ffffffff1660e01b8152600401602060405180830381865afa15801562000138573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906200015e91906200036b565b90506001600160a01b038216620001b85760405162461bcd60e51b815260206004820152601b60248201527f496e76616c6964206c656e64696e67506f6f6c20616464726573730000000000604482015260640162000069565b6001600160a01b038116620002105760405162461bcd60e51b815260206004820152601b60248201527f496e76616c69642070726963654f7261636c6520616464726573730000000000604482015260640162000069565b6001600160a01b0391821660c0521660e05250620002339050620c35006200023c565b50505062000392565b6000546001600160a01b03163314806200025557503330145b620002a35760405162461bcd60e51b815260206004820152601860248201527f416363657373436f6e74726f6c6c65642f496e76616c69640000000000000000604482015260640162000069565b808162ffffff1614620002f95760405162461bcd60e51b815260206004820152601d60248201527f4d616e67726f76654f666665722f6761737265712f6f766572666c6f77000000604482015260640162000069565b600155565b6001600160a01b03811681146200031457600080fd5b50565b6000806000606084860312156200032d57600080fd5b83516200033a81620002fe565b60208501519093506200034d81620002fe565b60408501519092506200036081620002fe565b809150509250925092565b6000602082840312156200037e57600080fd5b81516200038b81620002fe565b9392505050565b60805160a05160c05160e051613dab6200045f600039600081816102a201526109b6015260008181610421015281816106310152818161076401528181610838015281816123d20152612e5c015260006110460152600081816103ed01528181610c4401528181610dd801528181610e6201528181610f520152818161123c01528181611333015281816113c00152818161145d01528181611a8701528181611b7c01528181611cc901528181611e79015281816120c1015281816124c001526129200152613dab6000f3fe6080604052600436106101965760003560e01c80637b1a4909116100e1578063ad97db1b1161008a578063e4c34f8411610064578063e4c34f84146104e6578063f851a44014610506578063f92495e514610533578063faa030ec1461055357600080fd5b8063ad97db1b14610490578063aefe8403146104b0578063e428204d146104d057600080fd5b8063a59a9973116100bb578063a59a99731461040f578063a903f25c14610443578063aab9e0051461046357600080fd5b80637b1a49091461039b578063830cbbbd146103bb57806399fa5e2d146103db57600080fd5b80633d3d130d116101435780636a4f76911161011d5780636a4f7691146103485780636c49c32c1461035b578063704b6c021461037b57600080fd5b80633d3d130d146102e657806349f6d2dc1461030657806365a1d9f21461031957600080fd5b80632197c31e116101745780632197c31e1461025b5780632630c12f1461029057806334bd8931146102c457600080fd5b8063063df2d21461019b5780630efc8fd2146101d05780631bea800614610215575b600080fd5b3480156101a757600080fd5b506101bb6101b6366004613043565b61055b565b60405190151581526020015b60405180910390f35b3480156101dc57600080fd5b506101f06101eb36600461306f565b6105e9565b60405173ffffffffffffffffffffffffffffffffffffffff90911681526020016101c7565b34801561022157600080fd5b5061024d61023036600461308c565b600460209081526000928352604080842090915290825290205481565b6040519081526020016101c7565b34801561026757600080fd5b5061027b6102763660046130d3565b6106a9565b604080519283526020830191909152016101c7565b34801561029c57600080fd5b506101f07f000000000000000000000000000000000000000000000000000000000000000081565b3480156102d057600080fd5b506102e46102df36600461311e565b610b44565b005b3480156102f257600080fd5b506102e461030136600461314a565b610c42565b61024d6103143660046131aa565b610d3b565b34801561032557600080fd5b5061033961033436600461320c565b610fe3565b6040516101c793929190613252565b6102e46103563660046132ee565b6111a6565b34801561036757600080fd5b5061024d610376366004613359565b611459565b34801561038757600080fd5b506102e461039636600461306f565b6116c4565b3480156103a757600080fd5b506101bb6103b6366004613043565b61178c565b3480156103c757600080fd5b506101bb6103d6366004613043565b611873565b3480156103e757600080fd5b506101f07f000000000000000000000000000000000000000000000000000000000000000081565b34801561041b57600080fd5b506101f07f000000000000000000000000000000000000000000000000000000000000000081565b34801561044f57600080fd5b506102e461045e366004613043565b6118f5565b34801561046f57600080fd5b5061024d61047e36600461306f565b60036020526000908152604090205481565b34801561049c57600080fd5b5061024d6104ab366004613376565b611984565b3480156104bc57600080fd5b506102e46104cb366004613043565b611b0e565b3480156104dc57600080fd5b5061024d60015481565b3480156104f257600080fd5b5061024d6105013660046133c9565b611b18565b34801561051257600080fd5b506000546101f09073ffffffffffffffffffffffffffffffffffffffff1681565b34801561053f57600080fd5b506101f061054e36600461341a565b611bb2565b6102e4611c5d565b6000333014156105cc576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601660248201527f4d75746c69557365722f6e6f5265656e7472616e63790000000000000000000060448201526064015b60405180910390fd5b6105d63383611d54565b6105e08383611e47565b90505b92915050565b6040517f35ea6a7500000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff82811660048301526000917f0000000000000000000000000000000000000000000000000000000000000000909116906335ea6a759060240161018060405180830381865afa15801561067b573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061069f91906135bd565b60e0015192915050565b6000806106d76040518060800160405280600081526020016000815260200160008152602001600081525090565b61071f60405180610100016040528060008152602001600081526020016000815260200160008152602001600081526020016000815260200160008152602001600081525090565b6040517fbf92857c00000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff86811660048301527f0000000000000000000000000000000000000000000000000000000000000000169063bf92857c9060240160c060405180830381865afa1580156107ab573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906107cf91906136aa565b60c0870152608086015260a08501526040808501919091526020840191909152908252517f35ea6a7500000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff88811660048301526000917f0000000000000000000000000000000000000000000000000000000000000000909116906335ea6a759060240161018060405180830381865afa158015610882573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906108a691906135bd565b80515160ff603082901c1660408681019190915261ffff601083901c81166020808901919091529216865260e083015181517f70a0823100000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff8b8116600483015292519495509116926370a08231926024808401939192918290030181865afa158015610948573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061096c91906136f4565b60e08301526040517fb3596f0700000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff89811660048301527f0000000000000000000000000000000000000000000000000000000000000000169063b3596f0790602401602060405180830381865afa1580156109fd573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610a2191906136f4565b606084015260a08201518251610a5191610a4791610a3f9190611f04565b612710611f46565b8360200151611f88565b60608301526040830151600090610a9f90610a6d90600a61385c565b8460600151610a7c9190613868565b610a8890612710613868565b610a9a86602001518760600151611f04565b611f46565b9050610aaf818460e00151611fca565b905087610ac557945060009350610b3c92505050565b6000610ad8610a3f838760000151611f04565b90506000610b07610afd86604001518860400151600a610af8919061385c565b611f04565b8760600151611f46565b905080821115610b235782600097509750505050505050610b3c565b6000610b2f8284611f88565b9398509296505050505050505b935093915050565b60005473ffffffffffffffffffffffffffffffffffffffff16331480610b6957503330145b610bcf576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601860248201527f416363657373436f6e74726f6c6c65642f496e76616c6964000000000000000060448201526064016105c3565b808162ffffff1614610c3d576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601d60248201527f4d616e67726f76654f666665722f6761737265712f6f766572666c6f7700000060448201526064016105c3565b600155565b7f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff81161580610c9b57503373ffffffffffffffffffffffffffffffffffffffff8216145b610d01576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601860248201527f416363657373436f6e74726f6c6c65642f496e76616c6964000000000000000060448201526064016105c3565b81602001357f6d67762f747261646553756363657373000000000000000000000000000000001415610d3657610d3683611fe0565b505050565b600033301415610da7576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601660248201527f4d75746c69557365722f6e6f5265656e7472616e63790000000000000000000060448201526064016105c3565b6040517f70a082310000000000000000000000000000000000000000000000000000000081523060048201526000907f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff16906370a0823190602401602060405180830381865afa158015610e34573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610e5891906136f4565b90503415610ee2577f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff1663b60d4288346040518263ffffffff1660e01b81526004016000604051808303818588803b158015610ec857600080fd5b505af1158015610edc573d6000803e3d6000fd5b50505050505b6040517f49f6d2dc00000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff8a81166004830152898116602483015260448201899052606482018890526084820187905260a4820186905260c482018590527f000000000000000000000000000000000000000000000000000000000000000016906349f6d2dc9060e4016020604051808303816000875af1158015610f9b573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610fbf91906136f4565b9150610fcd89898433611fec565b610fd73382612090565b50979650505050505050565b6040517f2c7e545f00000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff85811660048301528481166024830152604482018490526064820183905260009160609182917f000000000000000000000000000000000000000000000000000000000000000090911690632c7e545f90608401600060405180830381865afa15801561108f573d6000803e3d6000fd5b505050506040513d6000823e601f3d9081017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe01682016040526110d59190810190613a12565b50508051919450925067ffffffffffffffff8111156110f6576110f661345b565b60405190808252806020026020018201604052801561111f578160200160208202803683370190505b50905060005b825181101561119b57611152888885848151811061114557611145613b07565b6020026020010151611bb2565b82828151811061116457611164613b07565b73ffffffffffffffffffffffffffffffffffffffff909216602092830291909101909101528061119381613b36565b915050611125565b509450945094915050565b60006111b3898984611bb2565b905073ffffffffffffffffffffffffffffffffffffffff81163314611234576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820181905260248201527f6d67764f666665722f4d756c74694f776e65722f756e617574686f72697a656460448201526064016105c3565b34156112bc577f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff1663b60d4288346040518263ffffffff1660e01b81526004016000604051808303818588803b1580156112a257600080fd5b505af11580156112b6573d6000803e3d6000fd5b50505050505b6040517f6a4f769100000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff8a81166004830152898116602483015260448201899052606482018890526084820187905260a4820186905260c4820185905260e482018490527f00000000000000000000000000000000000000000000000000000000000000001690636a4f76919061010401600060405180830381600087803b15801561137857600080fd5b505af115801561138c573d6000803e3d6000fd5b50506040517f70a08231000000000000000000000000000000000000000000000000000000008152306004820152600092507f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff1691506370a0823190602401602060405180830381865afa15801561141d573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061144191906136f4565b905061144d8282612090565b50505050505050505050565b60007f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff811615806114b457503373ffffffffffffffffffffffffffffffffffffffff8216145b61151a576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601860248201527f416363657373436f6e74726f6c6c65642f496e76616c6964000000000000000060448201526064016105c3565b600061152a8460a001358561217e565b905080156115ea57611542604085016020860161306f565b73ffffffffffffffffffffffffffffffffffffffff16611565602086018661306f565b73ffffffffffffffffffffffffffffffffffffffff167f3482722a7c71a098521214cdb975e1d9faa0b0163f768e89566f7acc36cffd0b8660400135846040516115b9929190918252602082015260400190565b60405180910390a37f6d67764f666665722f7075744661696c757265000000000000000000000000009250506116be565b60006115fa8560800135866121dc565b905080156116bb57611612604086016020870161306f565b73ffffffffffffffffffffffffffffffffffffffff16611635602087018761306f565b73ffffffffffffffffffffffffffffffffffffffff167fc99fe658c80b903af0e1270f4a55564b3a7509294ab1052c6ab07f8198baea67876040013584604051611689929190918252602082015260400190565b60405180910390a37f6d67764f666665722f6f75744f664c6971756964697479000000000000000000935050506116be565b50505b50919050565b60005473ffffffffffffffffffffffffffffffffffffffff163314611745576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601860248201527f416363657373436f6e74726f6c6c65642f496e76616c6964000000000000000060448201526064016105c3565b600080547fffffffffffffffffffffffff00000000000000000000000000000000000000001673ffffffffffffffffffffffffffffffffffffffff92909216919091179055565b6000805473ffffffffffffffffffffffffffffffffffffffff16331461180e576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601860248201527f416363657373436f6e74726f6c6c65642f496e76616c6964000000000000000060448201526064016105c3565b60405173ffffffffffffffffffffffffffffffffffffffff8416908390600081818185875af1925050503d8060008114611864576040519150601f19603f3d011682016040523d82523d6000602084013e611869565b606091505b5090949350505050565b6000333014156118df576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601660248201527f4d75746c69557365722f6e6f5265656e7472616e63790000000000000000000060448201526064016105c3565b6118ea8333846121e8565b6105e08333846122f8565b60005473ffffffffffffffffffffffffffffffffffffffff163314611976576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601860248201527f416363657373436f6e74726f6c6c65642f496e76616c6964000000000000000060448201526064016105c3565b6119808282612395565b5050565b73ffffffffffffffffffffffffffffffffffffffff8481166000908152600260209081526040808320878516845282528083208684529091528120549091163314611a2b576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820181905260248201527f6d67764f666665722f4d756c74694f776e65722f756e617574686f72697a656460448201526064016105c3565b6040517fad97db1b00000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff868116600483015285811660248301526044820185905283151560648301527f0000000000000000000000000000000000000000000000000000000000000000169063ad97db1b906084016020604051808303816000875af1158015611ad0573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611af491906136f4565b90508015611b0657611b06338261244e565b949350505050565b6119808282612483565b6000806000611b28888886611bb2565b905073ffffffffffffffffffffffffffffffffffffffff8116611b4e5760009150611b77565b73ffffffffffffffffffffffffffffffffffffffff811660009081526003602052604090205491505b611ba67f0000000000000000000000000000000000000000000000000000000000000000838a8a8a8a8a6125a2565b98975050505050505050565b73ffffffffffffffffffffffffffffffffffffffff8084166000908152600260209081526040808320868516845282528083208584529091529020541680611c56576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601560248201527f6d756c7469557365722f756e6b6f776e4f66666572000000000000000000000060448201526064016105c3565b9392505050565b33301415611cc7576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601660248201527f4d75746c69557365722f6e6f5265656e7472616e63790000000000000000000060448201526064016105c3565b7f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff1663b60d4288346040518263ffffffff1660e01b81526004016000604051808303818588803b158015611d2f57600080fd5b505af1158015611d43573d6000803e3d6000fd5b5050505050611d52333461244e565b565b73ffffffffffffffffffffffffffffffffffffffff8216600090815260036020526040902054811115611e09576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602260248201527f4d756c74694f776e65722f64656269744f6e4d67762f696e737566666963696560448201527f6e7400000000000000000000000000000000000000000000000000000000000060648201526084016105c3565b73ffffffffffffffffffffffffffffffffffffffff821660009081526003602052604081208054839290611e3e908490613b6f565b90915550505050565b6040517f2e1a7d4d000000000000000000000000000000000000000000000000000000008152600481018290526000907f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff1690632e1a7d4d906024016020604051808303816000875af1158015611ed7573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611efb9190613b86565b61180e57600080fd5b60006105e083836040518060400160405280601781526020017f6d756c7469706c69636174696f6e206f766572666c6f770000000000000000008152506127b9565b60006105e083836040518060400160405280600e81526020017f646976696465206279207a65726f00000000000000000000000000000000000081525061282f565b60006105e083836040518060400160405280601581526020017f7375627472616374696f6e20756e646572666c6f770000000000000000000000815250612875565b6000818310611fd957816105e0565b5090919050565b611fe9816128be565b50565b73ffffffffffffffffffffffffffffffffffffffff848116600081815260026020908152604080832088861680855290835281842088855283529281902080547fffffffffffffffffffffffff00000000000000000000000000000000000000001695871695861790555193845285939192917ff4d6dd56d4e8a2abba2bcbd020eb452fe8213f9b1466dd3f17d342f9a6353435910160405180910390a450505050565b6040517f70a082310000000000000000000000000000000000000000000000000000000081523060048201526000907f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff16906370a0823190602401602060405180830381865afa15801561211d573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061214191906136f4565b90508181141561215057505050565b8181111561216b57610d36836121668484613b6f565b61244e565b610d36836121798385613b6f565b611d54565b600061218a8383612af8565b905060006121b861219e602085018561306f565b6121ae604086016020870161306f565b8560400135611bb2565b90506121d46121cd604085016020860161306f565b8286612b31565b505092915050565b60006105e08383612b49565b73ffffffffffffffffffffffffffffffffffffffff8084166000908152600460209081526040808320938616835292905220548111156122aa576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602260248201527f4d756c74694f776e65722f6465626974546f6b656e2f696e737566666963696560448201527f6e7400000000000000000000000000000000000000000000000000000000000060648201526084016105c3565b73ffffffffffffffffffffffffffffffffffffffff8084166000908152600460209081526040808320938616835292905290812080548392906122ee908490613b6f565b9091555050505050565b6040517fa9059cbb00000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff8381166004830152602482018390526000919085169063a9059cbb906044016020604051808303816000875af1158015612371573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611b069190613b86565b6040517f095ea7b300000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff7f0000000000000000000000000000000000000000000000000000000000000000811660048301526024820183905283169063095ea7b3906044016020604051808303816000875af115801561242a573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610d369190613b86565b73ffffffffffffffffffffffffffffffffffffffff821660009081526003602052604081208054839290611e3e908490613ba3565b6040517f095ea7b300000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff7f0000000000000000000000000000000000000000000000000000000000000000811660048301526024820183905283169063095ea7b3906044016020604051808303816000875af1158015612518573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061253c9190613b86565b611980576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601560248201527f6d67764f666665722f617070726f76652f4661696c000000000000000000000060448201526064016105c3565b6040517fcbf75c9a00000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff8681166004830152858116602483015260009182918291908b169063cbf75c9a906044016040805180830381865afa15801561261d573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906126419190613bbb565b6040517f5722647b00000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff8b811660048301528a81166024830152604482018890529294509092506000918c1690635722647b90606401602060405180830381865afa1580156126c5573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906126e991906136f4565b9050600086604085901c61ffff16111561270c575061ffff604084901c1661270f565b50855b60008161272562ffffff606087901c168b613ba3565b61272f9190613868565b61273d90633b9aca00613868565b9050600061ffff602085901c1661276462ffffff603087901c811690604888901c16613ba3565b61276e9190613868565b61277c90633b9aca00613868565b9050600061278a8e83613ba3565b9050828110156127a35761279e8184613b6f565b6127a6565b60005b9f9e505050505050505050505050505050565b60008315806127c6575082155b156127d357506000611c56565b60006127df8486613868565b9050836127ec8683613bdf565b148390612826576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016105c39190613c85565b50949350505050565b6000818361286a576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016105c39190613c85565b50611b068385613bdf565b600081848411156128b3576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016105c39190613c85565b50611b068385613b6f565b60006128e0608083013560608401356bffffffffffffffffffffffff16613b6f565b9050600061290760a08401356bffffffffffffffffffffffff606080870135901c16613b6f565b905073ffffffffffffffffffffffffffffffffffffffff7f000000000000000000000000000000000000000000000000000000000000000016636a4f7691612952602086018661306f565b612962604087016020880161306f565b848660c089013560481c62ffffff1660c08a013560201c61ffff1660608b013560c01c63ffffffff16604080517fffffffff0000000000000000000000000000000000000000000000000000000060e08b901b16815273ffffffffffffffffffffffffffffffffffffffff988916600482015297909616602488015260448701949094526064860192909252608485015260a484015260c483015286013560e482015261010401600060405180830381600087803b158015612a2357600080fd5b505af1925050508015612a34575060015b610d3657612a40613c98565b806308c379a01415612aec5750612a55613cb4565b80612a605750612aee565b612a70604085016020860161306f565b73ffffffffffffffffffffffffffffffffffffffff16612a93602086018661306f565b73ffffffffffffffffffffffffffffffffffffffff167f768269e5e6803a8bc566de9364d8347774fff5b114c5a2ec556ab0459a172426866040013584604051612ade929190613d5c565b60405180910390a350505050565b505b3d6000803e3d6000fd5b600080612b0b61219e602085018561306f565b9050612b27612b20604085016020860161306f565b8286612dff565b5060009392505050565b6000612b3e8484846121e8565b611b068484846122f8565b600080612b5c61219e602085018561306f565b90506000612b78612b70602086018661306f565b6000846106a9565b50905080851115612b8d5784925050506105e3565b6000612b9f6101eb602087018761306f565b6040517f23b872dd00000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff858116600483015230602483015260448201899052919250908216906323b872dd906064016020604051808303816000875af1925050508015612c58575060408051601f3d9081017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0168201909252612c5591810190613b86565b60015b612d1c5760408501803590612c70906020880161306f565b73ffffffffffffffffffffffffffffffffffffffff16612c93602088018861306f565b73ffffffffffffffffffffffffffffffffffffffff167f3aa32c175e32764fe670a20f7800e840796a2c690e646f8d73ad446ae04628e989604051612d0f918152604060208201819052601d908201527f6c656e6465722f6d756c74692f7472616e7366657246726f6d4661696c000000606082015260800190565b60405180910390a4612df5565b612d27873088612e43565b612d385760009450505050506105e3565b60408601803590612d4c906020890161306f565b73ffffffffffffffffffffffffffffffffffffffff16612d6f602089018961306f565b73ffffffffffffffffffffffffffffffffffffffff167f3aa32c175e32764fe670a20f7800e840796a2c690e646f8d73ad446ae04628e98a604051612deb9181526040602082018190526019908201527f6c656e6465722f6d756c74692f72656465656d4661696c656400000000000000606082015260800190565b60405180910390a4505b5093949350505050565b73ffffffffffffffffffffffffffffffffffffffff8084166000908152600460209081526040808320938616835292905290812080548392906122ee908490613ba3565b600073ffffffffffffffffffffffffffffffffffffffff7f0000000000000000000000000000000000000000000000000000000000000000166369328dec612e8e602085018561306f565b6040517fffffffff0000000000000000000000000000000000000000000000000000000060e084901b16815273ffffffffffffffffffffffffffffffffffffffff91821660048201526024810188905290861660448201526064016020604051808303816000875af1925050508015612f42575060408051601f3d9081017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0168201909252612f3f918101906136f4565b60015b612ffd57612f4e613c98565b806308c379a01415612aec5750612f63613cb4565b80612f6e5750612aee565b60408301803590612f82906020860161306f565b73ffffffffffffffffffffffffffffffffffffffff16612fa5602086018661306f565b73ffffffffffffffffffffffffffffffffffffffff167f3aa32c175e32764fe670a20f7800e840796a2c690e646f8d73ad446ae04628e98885604051612fec929190613d5c565b60405180910390a484915050611c56565b8085141561300f576000915050611c56565b6130198186613b6f565b915050611c56565b73ffffffffffffffffffffffffffffffffffffffff81168114611fe957600080fd5b6000806040838503121561305657600080fd5b823561306181613021565b946020939093013593505050565b60006020828403121561308157600080fd5b8135611c5681613021565b6000806040838503121561309f57600080fd5b82356130aa81613021565b915060208301356130ba81613021565b809150509250929050565b8015158114611fe957600080fd5b6000806000606084860312156130e857600080fd5b83356130f381613021565b92506020840135613103816130c5565b9150604084013561311381613021565b809150509250925092565b60006020828403121561313057600080fd5b5035919050565b600061012082840312156116be57600080fd5b60008082840361016081121561315f57600080fd5b6131698585613137565b925060407ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffee08201121561319b57600080fd5b50610120830190509250929050565b600080600080600080600060e0888a0312156131c557600080fd5b87356131d081613021565b965060208801356131e081613021565b96999698505050506040850135946060810135946080820135945060a0820135935060c0909101359150565b6000806000806080858703121561322257600080fd5b843561322d81613021565b9350602085013561323d81613021565b93969395505050506040820135916060013590565b6000606082018583526020606081850152818651808452608086019150828801935060005b8181101561329357845183529383019391830191600101613277565b50508481036040860152855180825290820192508186019060005b818110156132e057825173ffffffffffffffffffffffffffffffffffffffff16855293830193918301916001016132ae565b509298975050505050505050565b600080600080600080600080610100898b03121561330b57600080fd5b883561331681613021565b9750602089013561332681613021565b979a9799505050506040860135956060810135956080820135955060a0820135945060c0820135935060e0909101359150565b6000610120828403121561336c57600080fd5b6105e08383613137565b6000806000806080858703121561338c57600080fd5b843561339781613021565b935060208501356133a781613021565b92506040850135915060608501356133be816130c5565b939692955090935050565b600080600080600060a086880312156133e157600080fd5b85356133ec81613021565b945060208601356133fc81613021565b94979496505050506040830135926060810135926080909101359150565b60008060006060848603121561342f57600080fd5b833561343a81613021565b9250602084013561344a81613021565b929592945050506040919091013590565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b6080810181811067ffffffffffffffff821117156134aa576134aa61345b565b60405250565b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0601f830116810181811067ffffffffffffffff821117156134f4576134f461345b565b6040525050565b604051610180810167ffffffffffffffff8111828210171561351f5761351f61345b565b60405290565b60006020828403121561353757600080fd5b6040516020810181811067ffffffffffffffff8211171561355a5761355a61345b565b6040529151825250919050565b80516fffffffffffffffffffffffffffffffff8116811461358757600080fd5b919050565b805164ffffffffff8116811461358757600080fd5b805161358781613021565b805160ff8116811461358757600080fd5b600061018082840312156135d057600080fd5b6135d86134fb565b6135e28484613525565b81526135f060208401613567565b602082015261360160408401613567565b604082015261361260608401613567565b606082015261362360808401613567565b608082015261363460a08401613567565b60a082015261364560c0840161358c565b60c082015261365660e084016135a1565b60e08201526101006136698185016135a1565b9082015261012061367b8482016135a1565b9082015261014061368d8482016135a1565b9082015261016061369f8482016135ac565b908201529392505050565b60008060008060008060c087890312156136c357600080fd5b865195506020870151945060408701519350606087015192506080870151915060a087015190509295509295509295565b60006020828403121561370657600080fd5b5051919050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b600181815b8085111561379557817fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff0482111561377b5761377b61370d565b8085161561378857918102915b93841c9390800290613741565b509250929050565b6000826137ac575060016105e3565b816137b9575060006105e3565b81600181146137cf57600281146137d9576137f5565b60019150506105e3565b60ff8411156137ea576137ea61370d565b50506001821b6105e3565b5060208310610133831016604e8410600b8410161715613818575081810a6105e3565b613822838361373c565b807fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff048211156138545761385461370d565b029392505050565b60006105e0838361379d565b6000817fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff04831182151516156138a0576138a061370d565b500290565b600067ffffffffffffffff8211156138bf576138bf61345b565b5060051b60200190565b600082601f8301126138da57600080fd5b815160206138e7826138a5565b604080516138f583826134b0565b84815260079490941b860183019383810192508785111561391557600080fd5b8387015b85811015610fd7576080818a0312156139325760008081fd5b825161393d8161348a565b815181528582015186820152838201518482015260608083015190820152845292840192608001613919565b600082601f83011261397a57600080fd5b81516020613987826138a5565b6040805161399583826134b0565b84815260079490941b86018301938381019250878511156139b557600080fd5b8387015b85811015610fd7576080818a0312156139d25760008081fd5b82516139dd8161348a565b81516139e881613021565b815281860151868201528382015184820152606080830151908201528452928401926080016139b9565b60008060008060808587031215613a2857600080fd5b8451935060208086015167ffffffffffffffff80821115613a4857600080fd5b818801915088601f830112613a5c57600080fd5b8151613a67816138a5565b604051613a7482826134b0565b82815260059290921b840185019185810191508b831115613a9457600080fd5b938501935b82851015613ab257845182529385019390850190613a99565b60408b01519098509450505080831115613acb57600080fd5b613ad789848a016138c9565b94506060880151925080831115613aed57600080fd5b5050613afb87828801613969565b91505092959194509250565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b60007fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff821415613b6857613b6861370d565b5060010190565b600082821015613b8157613b8161370d565b500390565b600060208284031215613b9857600080fd5b8151611c56816130c5565b60008219821115613bb657613bb661370d565b500190565b60008060408385031215613bce57600080fd5b505080516020909101519092909150565b600082613c15577f4e487b7100000000000000000000000000000000000000000000000000000000600052601260045260246000fd5b500490565b6000815180845260005b81811015613c4057602081850181015186830182015201613c24565b81811115613c52576000602083870101525b50601f017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0169290920160200192915050565b6020815260006105e06020830184613c1a565b600060033d1115613cb15760046000803e5060005160e01c5b90565b600060443d1015613cc25790565b6040517ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc803d016004833e81513d67ffffffffffffffff8160248401118184111715613d1057505050505090565b8285019150815181811115613d285750505050505090565b843d8701016020828501011115613d425750505050505090565b613d51602082860101876134b0565b509095945050505050565b828152604060208201526000611b066040830184613c1a56fea2646970667358221220eb7048c3579b37c1500cb012c3ffb16f3dfed629af85b24bb6adc4133e27d8a364736f6c634300080a0033",
  "deployedBytecode": "0x6080604052600436106101965760003560e01c80637b1a4909116100e1578063ad97db1b1161008a578063e4c34f8411610064578063e4c34f84146104e6578063f851a44014610506578063f92495e514610533578063faa030ec1461055357600080fd5b8063ad97db1b14610490578063aefe8403146104b0578063e428204d146104d057600080fd5b8063a59a9973116100bb578063a59a99731461040f578063a903f25c14610443578063aab9e0051461046357600080fd5b80637b1a49091461039b578063830cbbbd146103bb57806399fa5e2d146103db57600080fd5b80633d3d130d116101435780636a4f76911161011d5780636a4f7691146103485780636c49c32c1461035b578063704b6c021461037b57600080fd5b80633d3d130d146102e657806349f6d2dc1461030657806365a1d9f21461031957600080fd5b80632197c31e116101745780632197c31e1461025b5780632630c12f1461029057806334bd8931146102c457600080fd5b8063063df2d21461019b5780630efc8fd2146101d05780631bea800614610215575b600080fd5b3480156101a757600080fd5b506101bb6101b6366004613043565b61055b565b60405190151581526020015b60405180910390f35b3480156101dc57600080fd5b506101f06101eb36600461306f565b6105e9565b60405173ffffffffffffffffffffffffffffffffffffffff90911681526020016101c7565b34801561022157600080fd5b5061024d61023036600461308c565b600460209081526000928352604080842090915290825290205481565b6040519081526020016101c7565b34801561026757600080fd5b5061027b6102763660046130d3565b6106a9565b604080519283526020830191909152016101c7565b34801561029c57600080fd5b506101f07f000000000000000000000000000000000000000000000000000000000000000081565b3480156102d057600080fd5b506102e46102df36600461311e565b610b44565b005b3480156102f257600080fd5b506102e461030136600461314a565b610c42565b61024d6103143660046131aa565b610d3b565b34801561032557600080fd5b5061033961033436600461320c565b610fe3565b6040516101c793929190613252565b6102e46103563660046132ee565b6111a6565b34801561036757600080fd5b5061024d610376366004613359565b611459565b34801561038757600080fd5b506102e461039636600461306f565b6116c4565b3480156103a757600080fd5b506101bb6103b6366004613043565b61178c565b3480156103c757600080fd5b506101bb6103d6366004613043565b611873565b3480156103e757600080fd5b506101f07f000000000000000000000000000000000000000000000000000000000000000081565b34801561041b57600080fd5b506101f07f000000000000000000000000000000000000000000000000000000000000000081565b34801561044f57600080fd5b506102e461045e366004613043565b6118f5565b34801561046f57600080fd5b5061024d61047e36600461306f565b60036020526000908152604090205481565b34801561049c57600080fd5b5061024d6104ab366004613376565b611984565b3480156104bc57600080fd5b506102e46104cb366004613043565b611b0e565b3480156104dc57600080fd5b5061024d60015481565b3480156104f257600080fd5b5061024d6105013660046133c9565b611b18565b34801561051257600080fd5b506000546101f09073ffffffffffffffffffffffffffffffffffffffff1681565b34801561053f57600080fd5b506101f061054e36600461341a565b611bb2565b6102e4611c5d565b6000333014156105cc576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601660248201527f4d75746c69557365722f6e6f5265656e7472616e63790000000000000000000060448201526064015b60405180910390fd5b6105d63383611d54565b6105e08383611e47565b90505b92915050565b6040517f35ea6a7500000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff82811660048301526000917f0000000000000000000000000000000000000000000000000000000000000000909116906335ea6a759060240161018060405180830381865afa15801561067b573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061069f91906135bd565b60e0015192915050565b6000806106d76040518060800160405280600081526020016000815260200160008152602001600081525090565b61071f60405180610100016040528060008152602001600081526020016000815260200160008152602001600081526020016000815260200160008152602001600081525090565b6040517fbf92857c00000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff86811660048301527f0000000000000000000000000000000000000000000000000000000000000000169063bf92857c9060240160c060405180830381865afa1580156107ab573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906107cf91906136aa565b60c0870152608086015260a08501526040808501919091526020840191909152908252517f35ea6a7500000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff88811660048301526000917f0000000000000000000000000000000000000000000000000000000000000000909116906335ea6a759060240161018060405180830381865afa158015610882573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906108a691906135bd565b80515160ff603082901c1660408681019190915261ffff601083901c81166020808901919091529216865260e083015181517f70a0823100000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff8b8116600483015292519495509116926370a08231926024808401939192918290030181865afa158015610948573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061096c91906136f4565b60e08301526040517fb3596f0700000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff89811660048301527f0000000000000000000000000000000000000000000000000000000000000000169063b3596f0790602401602060405180830381865afa1580156109fd573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610a2191906136f4565b606084015260a08201518251610a5191610a4791610a3f9190611f04565b612710611f46565b8360200151611f88565b60608301526040830151600090610a9f90610a6d90600a61385c565b8460600151610a7c9190613868565b610a8890612710613868565b610a9a86602001518760600151611f04565b611f46565b9050610aaf818460e00151611fca565b905087610ac557945060009350610b3c92505050565b6000610ad8610a3f838760000151611f04565b90506000610b07610afd86604001518860400151600a610af8919061385c565b611f04565b8760600151611f46565b905080821115610b235782600097509750505050505050610b3c565b6000610b2f8284611f88565b9398509296505050505050505b935093915050565b60005473ffffffffffffffffffffffffffffffffffffffff16331480610b6957503330145b610bcf576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601860248201527f416363657373436f6e74726f6c6c65642f496e76616c6964000000000000000060448201526064016105c3565b808162ffffff1614610c3d576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601d60248201527f4d616e67726f76654f666665722f6761737265712f6f766572666c6f7700000060448201526064016105c3565b600155565b7f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff81161580610c9b57503373ffffffffffffffffffffffffffffffffffffffff8216145b610d01576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601860248201527f416363657373436f6e74726f6c6c65642f496e76616c6964000000000000000060448201526064016105c3565b81602001357f6d67762f747261646553756363657373000000000000000000000000000000001415610d3657610d3683611fe0565b505050565b600033301415610da7576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601660248201527f4d75746c69557365722f6e6f5265656e7472616e63790000000000000000000060448201526064016105c3565b6040517f70a082310000000000000000000000000000000000000000000000000000000081523060048201526000907f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff16906370a0823190602401602060405180830381865afa158015610e34573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610e5891906136f4565b90503415610ee2577f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff1663b60d4288346040518263ffffffff1660e01b81526004016000604051808303818588803b158015610ec857600080fd5b505af1158015610edc573d6000803e3d6000fd5b50505050505b6040517f49f6d2dc00000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff8a81166004830152898116602483015260448201899052606482018890526084820187905260a4820186905260c482018590527f000000000000000000000000000000000000000000000000000000000000000016906349f6d2dc9060e4016020604051808303816000875af1158015610f9b573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610fbf91906136f4565b9150610fcd89898433611fec565b610fd73382612090565b50979650505050505050565b6040517f2c7e545f00000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff85811660048301528481166024830152604482018490526064820183905260009160609182917f000000000000000000000000000000000000000000000000000000000000000090911690632c7e545f90608401600060405180830381865afa15801561108f573d6000803e3d6000fd5b505050506040513d6000823e601f3d9081017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe01682016040526110d59190810190613a12565b50508051919450925067ffffffffffffffff8111156110f6576110f661345b565b60405190808252806020026020018201604052801561111f578160200160208202803683370190505b50905060005b825181101561119b57611152888885848151811061114557611145613b07565b6020026020010151611bb2565b82828151811061116457611164613b07565b73ffffffffffffffffffffffffffffffffffffffff909216602092830291909101909101528061119381613b36565b915050611125565b509450945094915050565b60006111b3898984611bb2565b905073ffffffffffffffffffffffffffffffffffffffff81163314611234576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820181905260248201527f6d67764f666665722f4d756c74694f776e65722f756e617574686f72697a656460448201526064016105c3565b34156112bc577f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff1663b60d4288346040518263ffffffff1660e01b81526004016000604051808303818588803b1580156112a257600080fd5b505af11580156112b6573d6000803e3d6000fd5b50505050505b6040517f6a4f769100000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff8a81166004830152898116602483015260448201899052606482018890526084820187905260a4820186905260c4820185905260e482018490527f00000000000000000000000000000000000000000000000000000000000000001690636a4f76919061010401600060405180830381600087803b15801561137857600080fd5b505af115801561138c573d6000803e3d6000fd5b50506040517f70a08231000000000000000000000000000000000000000000000000000000008152306004820152600092507f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff1691506370a0823190602401602060405180830381865afa15801561141d573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061144191906136f4565b905061144d8282612090565b50505050505050505050565b60007f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff811615806114b457503373ffffffffffffffffffffffffffffffffffffffff8216145b61151a576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601860248201527f416363657373436f6e74726f6c6c65642f496e76616c6964000000000000000060448201526064016105c3565b600061152a8460a001358561217e565b905080156115ea57611542604085016020860161306f565b73ffffffffffffffffffffffffffffffffffffffff16611565602086018661306f565b73ffffffffffffffffffffffffffffffffffffffff167f3482722a7c71a098521214cdb975e1d9faa0b0163f768e89566f7acc36cffd0b8660400135846040516115b9929190918252602082015260400190565b60405180910390a37f6d67764f666665722f7075744661696c757265000000000000000000000000009250506116be565b60006115fa8560800135866121dc565b905080156116bb57611612604086016020870161306f565b73ffffffffffffffffffffffffffffffffffffffff16611635602087018761306f565b73ffffffffffffffffffffffffffffffffffffffff167fc99fe658c80b903af0e1270f4a55564b3a7509294ab1052c6ab07f8198baea67876040013584604051611689929190918252602082015260400190565b60405180910390a37f6d67764f666665722f6f75744f664c6971756964697479000000000000000000935050506116be565b50505b50919050565b60005473ffffffffffffffffffffffffffffffffffffffff163314611745576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601860248201527f416363657373436f6e74726f6c6c65642f496e76616c6964000000000000000060448201526064016105c3565b600080547fffffffffffffffffffffffff00000000000000000000000000000000000000001673ffffffffffffffffffffffffffffffffffffffff92909216919091179055565b6000805473ffffffffffffffffffffffffffffffffffffffff16331461180e576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601860248201527f416363657373436f6e74726f6c6c65642f496e76616c6964000000000000000060448201526064016105c3565b60405173ffffffffffffffffffffffffffffffffffffffff8416908390600081818185875af1925050503d8060008114611864576040519150601f19603f3d011682016040523d82523d6000602084013e611869565b606091505b5090949350505050565b6000333014156118df576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601660248201527f4d75746c69557365722f6e6f5265656e7472616e63790000000000000000000060448201526064016105c3565b6118ea8333846121e8565b6105e08333846122f8565b60005473ffffffffffffffffffffffffffffffffffffffff163314611976576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601860248201527f416363657373436f6e74726f6c6c65642f496e76616c6964000000000000000060448201526064016105c3565b6119808282612395565b5050565b73ffffffffffffffffffffffffffffffffffffffff8481166000908152600260209081526040808320878516845282528083208684529091528120549091163314611a2b576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820181905260248201527f6d67764f666665722f4d756c74694f776e65722f756e617574686f72697a656460448201526064016105c3565b6040517fad97db1b00000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff868116600483015285811660248301526044820185905283151560648301527f0000000000000000000000000000000000000000000000000000000000000000169063ad97db1b906084016020604051808303816000875af1158015611ad0573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611af491906136f4565b90508015611b0657611b06338261244e565b949350505050565b6119808282612483565b6000806000611b28888886611bb2565b905073ffffffffffffffffffffffffffffffffffffffff8116611b4e5760009150611b77565b73ffffffffffffffffffffffffffffffffffffffff811660009081526003602052604090205491505b611ba67f0000000000000000000000000000000000000000000000000000000000000000838a8a8a8a8a6125a2565b98975050505050505050565b73ffffffffffffffffffffffffffffffffffffffff8084166000908152600260209081526040808320868516845282528083208584529091529020541680611c56576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601560248201527f6d756c7469557365722f756e6b6f776e4f66666572000000000000000000000060448201526064016105c3565b9392505050565b33301415611cc7576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601660248201527f4d75746c69557365722f6e6f5265656e7472616e63790000000000000000000060448201526064016105c3565b7f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff1663b60d4288346040518263ffffffff1660e01b81526004016000604051808303818588803b158015611d2f57600080fd5b505af1158015611d43573d6000803e3d6000fd5b5050505050611d52333461244e565b565b73ffffffffffffffffffffffffffffffffffffffff8216600090815260036020526040902054811115611e09576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602260248201527f4d756c74694f776e65722f64656269744f6e4d67762f696e737566666963696560448201527f6e7400000000000000000000000000000000000000000000000000000000000060648201526084016105c3565b73ffffffffffffffffffffffffffffffffffffffff821660009081526003602052604081208054839290611e3e908490613b6f565b90915550505050565b6040517f2e1a7d4d000000000000000000000000000000000000000000000000000000008152600481018290526000907f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff1690632e1a7d4d906024016020604051808303816000875af1158015611ed7573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611efb9190613b86565b61180e57600080fd5b60006105e083836040518060400160405280601781526020017f6d756c7469706c69636174696f6e206f766572666c6f770000000000000000008152506127b9565b60006105e083836040518060400160405280600e81526020017f646976696465206279207a65726f00000000000000000000000000000000000081525061282f565b60006105e083836040518060400160405280601581526020017f7375627472616374696f6e20756e646572666c6f770000000000000000000000815250612875565b6000818310611fd957816105e0565b5090919050565b611fe9816128be565b50565b73ffffffffffffffffffffffffffffffffffffffff848116600081815260026020908152604080832088861680855290835281842088855283529281902080547fffffffffffffffffffffffff00000000000000000000000000000000000000001695871695861790555193845285939192917ff4d6dd56d4e8a2abba2bcbd020eb452fe8213f9b1466dd3f17d342f9a6353435910160405180910390a450505050565b6040517f70a082310000000000000000000000000000000000000000000000000000000081523060048201526000907f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff16906370a0823190602401602060405180830381865afa15801561211d573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061214191906136f4565b90508181141561215057505050565b8181111561216b57610d36836121668484613b6f565b61244e565b610d36836121798385613b6f565b611d54565b600061218a8383612af8565b905060006121b861219e602085018561306f565b6121ae604086016020870161306f565b8560400135611bb2565b90506121d46121cd604085016020860161306f565b8286612b31565b505092915050565b60006105e08383612b49565b73ffffffffffffffffffffffffffffffffffffffff8084166000908152600460209081526040808320938616835292905220548111156122aa576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602260248201527f4d756c74694f776e65722f6465626974546f6b656e2f696e737566666963696560448201527f6e7400000000000000000000000000000000000000000000000000000000000060648201526084016105c3565b73ffffffffffffffffffffffffffffffffffffffff8084166000908152600460209081526040808320938616835292905290812080548392906122ee908490613b6f565b9091555050505050565b6040517fa9059cbb00000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff8381166004830152602482018390526000919085169063a9059cbb906044016020604051808303816000875af1158015612371573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611b069190613b86565b6040517f095ea7b300000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff7f0000000000000000000000000000000000000000000000000000000000000000811660048301526024820183905283169063095ea7b3906044016020604051808303816000875af115801561242a573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610d369190613b86565b73ffffffffffffffffffffffffffffffffffffffff821660009081526003602052604081208054839290611e3e908490613ba3565b6040517f095ea7b300000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff7f0000000000000000000000000000000000000000000000000000000000000000811660048301526024820183905283169063095ea7b3906044016020604051808303816000875af1158015612518573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061253c9190613b86565b611980576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601560248201527f6d67764f666665722f617070726f76652f4661696c000000000000000000000060448201526064016105c3565b6040517fcbf75c9a00000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff8681166004830152858116602483015260009182918291908b169063cbf75c9a906044016040805180830381865afa15801561261d573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906126419190613bbb565b6040517f5722647b00000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff8b811660048301528a81166024830152604482018890529294509092506000918c1690635722647b90606401602060405180830381865afa1580156126c5573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906126e991906136f4565b9050600086604085901c61ffff16111561270c575061ffff604084901c1661270f565b50855b60008161272562ffffff606087901c168b613ba3565b61272f9190613868565b61273d90633b9aca00613868565b9050600061ffff602085901c1661276462ffffff603087901c811690604888901c16613ba3565b61276e9190613868565b61277c90633b9aca00613868565b9050600061278a8e83613ba3565b9050828110156127a35761279e8184613b6f565b6127a6565b60005b9f9e505050505050505050505050505050565b60008315806127c6575082155b156127d357506000611c56565b60006127df8486613868565b9050836127ec8683613bdf565b148390612826576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016105c39190613c85565b50949350505050565b6000818361286a576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016105c39190613c85565b50611b068385613bdf565b600081848411156128b3576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016105c39190613c85565b50611b068385613b6f565b60006128e0608083013560608401356bffffffffffffffffffffffff16613b6f565b9050600061290760a08401356bffffffffffffffffffffffff606080870135901c16613b6f565b905073ffffffffffffffffffffffffffffffffffffffff7f000000000000000000000000000000000000000000000000000000000000000016636a4f7691612952602086018661306f565b612962604087016020880161306f565b848660c089013560481c62ffffff1660c08a013560201c61ffff1660608b013560c01c63ffffffff16604080517fffffffff0000000000000000000000000000000000000000000000000000000060e08b901b16815273ffffffffffffffffffffffffffffffffffffffff988916600482015297909616602488015260448701949094526064860192909252608485015260a484015260c483015286013560e482015261010401600060405180830381600087803b158015612a2357600080fd5b505af1925050508015612a34575060015b610d3657612a40613c98565b806308c379a01415612aec5750612a55613cb4565b80612a605750612aee565b612a70604085016020860161306f565b73ffffffffffffffffffffffffffffffffffffffff16612a93602086018661306f565b73ffffffffffffffffffffffffffffffffffffffff167f768269e5e6803a8bc566de9364d8347774fff5b114c5a2ec556ab0459a172426866040013584604051612ade929190613d5c565b60405180910390a350505050565b505b3d6000803e3d6000fd5b600080612b0b61219e602085018561306f565b9050612b27612b20604085016020860161306f565b8286612dff565b5060009392505050565b6000612b3e8484846121e8565b611b068484846122f8565b600080612b5c61219e602085018561306f565b90506000612b78612b70602086018661306f565b6000846106a9565b50905080851115612b8d5784925050506105e3565b6000612b9f6101eb602087018761306f565b6040517f23b872dd00000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff858116600483015230602483015260448201899052919250908216906323b872dd906064016020604051808303816000875af1925050508015612c58575060408051601f3d9081017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0168201909252612c5591810190613b86565b60015b612d1c5760408501803590612c70906020880161306f565b73ffffffffffffffffffffffffffffffffffffffff16612c93602088018861306f565b73ffffffffffffffffffffffffffffffffffffffff167f3aa32c175e32764fe670a20f7800e840796a2c690e646f8d73ad446ae04628e989604051612d0f918152604060208201819052601d908201527f6c656e6465722f6d756c74692f7472616e7366657246726f6d4661696c000000606082015260800190565b60405180910390a4612df5565b612d27873088612e43565b612d385760009450505050506105e3565b60408601803590612d4c906020890161306f565b73ffffffffffffffffffffffffffffffffffffffff16612d6f602089018961306f565b73ffffffffffffffffffffffffffffffffffffffff167f3aa32c175e32764fe670a20f7800e840796a2c690e646f8d73ad446ae04628e98a604051612deb9181526040602082018190526019908201527f6c656e6465722f6d756c74692f72656465656d4661696c656400000000000000606082015260800190565b60405180910390a4505b5093949350505050565b73ffffffffffffffffffffffffffffffffffffffff8084166000908152600460209081526040808320938616835292905290812080548392906122ee908490613ba3565b600073ffffffffffffffffffffffffffffffffffffffff7f0000000000000000000000000000000000000000000000000000000000000000166369328dec612e8e602085018561306f565b6040517fffffffff0000000000000000000000000000000000000000000000000000000060e084901b16815273ffffffffffffffffffffffffffffffffffffffff91821660048201526024810188905290861660448201526064016020604051808303816000875af1925050508015612f42575060408051601f3d9081017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0168201909252612f3f918101906136f4565b60015b612ffd57612f4e613c98565b806308c379a01415612aec5750612f63613cb4565b80612f6e5750612aee565b60408301803590612f82906020860161306f565b73ffffffffffffffffffffffffffffffffffffffff16612fa5602086018661306f565b73ffffffffffffffffffffffffffffffffffffffff167f3aa32c175e32764fe670a20f7800e840796a2c690e646f8d73ad446ae04628e98885604051612fec929190613d5c565b60405180910390a484915050611c56565b8085141561300f576000915050611c56565b6130198186613b6f565b915050611c56565b73ffffffffffffffffffffffffffffffffffffffff81168114611fe957600080fd5b6000806040838503121561305657600080fd5b823561306181613021565b946020939093013593505050565b60006020828403121561308157600080fd5b8135611c5681613021565b6000806040838503121561309f57600080fd5b82356130aa81613021565b915060208301356130ba81613021565b809150509250929050565b8015158114611fe957600080fd5b6000806000606084860312156130e857600080fd5b83356130f381613021565b92506020840135613103816130c5565b9150604084013561311381613021565b809150509250925092565b60006020828403121561313057600080fd5b5035919050565b600061012082840312156116be57600080fd5b60008082840361016081121561315f57600080fd5b6131698585613137565b925060407ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffee08201121561319b57600080fd5b50610120830190509250929050565b600080600080600080600060e0888a0312156131c557600080fd5b87356131d081613021565b965060208801356131e081613021565b96999698505050506040850135946060810135946080820135945060a0820135935060c0909101359150565b6000806000806080858703121561322257600080fd5b843561322d81613021565b9350602085013561323d81613021565b93969395505050506040820135916060013590565b6000606082018583526020606081850152818651808452608086019150828801935060005b8181101561329357845183529383019391830191600101613277565b50508481036040860152855180825290820192508186019060005b818110156132e057825173ffffffffffffffffffffffffffffffffffffffff16855293830193918301916001016132ae565b509298975050505050505050565b600080600080600080600080610100898b03121561330b57600080fd5b883561331681613021565b9750602089013561332681613021565b979a9799505050506040860135956060810135956080820135955060a0820135945060c0820135935060e0909101359150565b6000610120828403121561336c57600080fd5b6105e08383613137565b6000806000806080858703121561338c57600080fd5b843561339781613021565b935060208501356133a781613021565b92506040850135915060608501356133be816130c5565b939692955090935050565b600080600080600060a086880312156133e157600080fd5b85356133ec81613021565b945060208601356133fc81613021565b94979496505050506040830135926060810135926080909101359150565b60008060006060848603121561342f57600080fd5b833561343a81613021565b9250602084013561344a81613021565b929592945050506040919091013590565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b6080810181811067ffffffffffffffff821117156134aa576134aa61345b565b60405250565b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0601f830116810181811067ffffffffffffffff821117156134f4576134f461345b565b6040525050565b604051610180810167ffffffffffffffff8111828210171561351f5761351f61345b565b60405290565b60006020828403121561353757600080fd5b6040516020810181811067ffffffffffffffff8211171561355a5761355a61345b565b6040529151825250919050565b80516fffffffffffffffffffffffffffffffff8116811461358757600080fd5b919050565b805164ffffffffff8116811461358757600080fd5b805161358781613021565b805160ff8116811461358757600080fd5b600061018082840312156135d057600080fd5b6135d86134fb565b6135e28484613525565b81526135f060208401613567565b602082015261360160408401613567565b604082015261361260608401613567565b606082015261362360808401613567565b608082015261363460a08401613567565b60a082015261364560c0840161358c565b60c082015261365660e084016135a1565b60e08201526101006136698185016135a1565b9082015261012061367b8482016135a1565b9082015261014061368d8482016135a1565b9082015261016061369f8482016135ac565b908201529392505050565b60008060008060008060c087890312156136c357600080fd5b865195506020870151945060408701519350606087015192506080870151915060a087015190509295509295509295565b60006020828403121561370657600080fd5b5051919050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b600181815b8085111561379557817fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff0482111561377b5761377b61370d565b8085161561378857918102915b93841c9390800290613741565b509250929050565b6000826137ac575060016105e3565b816137b9575060006105e3565b81600181146137cf57600281146137d9576137f5565b60019150506105e3565b60ff8411156137ea576137ea61370d565b50506001821b6105e3565b5060208310610133831016604e8410600b8410161715613818575081810a6105e3565b613822838361373c565b807fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff048211156138545761385461370d565b029392505050565b60006105e0838361379d565b6000817fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff04831182151516156138a0576138a061370d565b500290565b600067ffffffffffffffff8211156138bf576138bf61345b565b5060051b60200190565b600082601f8301126138da57600080fd5b815160206138e7826138a5565b604080516138f583826134b0565b84815260079490941b860183019383810192508785111561391557600080fd5b8387015b85811015610fd7576080818a0312156139325760008081fd5b825161393d8161348a565b815181528582015186820152838201518482015260608083015190820152845292840192608001613919565b600082601f83011261397a57600080fd5b81516020613987826138a5565b6040805161399583826134b0565b84815260079490941b86018301938381019250878511156139b557600080fd5b8387015b85811015610fd7576080818a0312156139d25760008081fd5b82516139dd8161348a565b81516139e881613021565b815281860151868201528382015184820152606080830151908201528452928401926080016139b9565b60008060008060808587031215613a2857600080fd5b8451935060208086015167ffffffffffffffff80821115613a4857600080fd5b818801915088601f830112613a5c57600080fd5b8151613a67816138a5565b604051613a7482826134b0565b82815260059290921b840185019185810191508b831115613a9457600080fd5b938501935b82851015613ab257845182529385019390850190613a99565b60408b01519098509450505080831115613acb57600080fd5b613ad789848a016138c9565b94506060880151925080831115613aed57600080fd5b5050613afb87828801613969565b91505092959194509250565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b60007fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff821415613b6857613b6861370d565b5060010190565b600082821015613b8157613b8161370d565b500390565b600060208284031215613b9857600080fd5b8151611c56816130c5565b60008219821115613bb657613bb661370d565b500190565b60008060408385031215613bce57600080fd5b505080516020909101519092909150565b600082613c15577f4e487b7100000000000000000000000000000000000000000000000000000000600052601260045260246000fd5b500490565b6000815180845260005b81811015613c4057602081850181015186830182015201613c24565b81811115613c52576000602083870101525b50601f017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0169290920160200192915050565b6020815260006105e06020830184613c1a565b600060033d1115613cb15760046000803e5060005160e01c5b90565b600060443d1015613cc25790565b6040517ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc803d016004833e81513d67ffffffffffffffff8160248401118184111715613d1057505050505090565b8285019150815181811115613d285750505050505090565b843d8701016020828501011115613d425750505050505090565b613d51602082860101876134b0565b509095945050505050565b828152604060208201526000611b066040830184613c1a56fea2646970667358221220eb7048c3579b37c1500cb012c3ffb16f3dfed629af85b24bb6adc4133e27d8a364736f6c634300080a0033",
  "devdoc": {
    "kind": "dev",
    "methods": {},
    "version": 1
  },
  "userdoc": {
    "events": {
      "PosthookFail(address,address,uint256,string)": {
        "notice": "Events "
      }
    },
    "kind": "user",
    "methods": {
      "approveLender(address,uint256)": {
        "notice": "approval of ctoken contract by the underlying is necessary for minting and repaying borrowuser must use this function to do so."
      },
      "approveMangrove(address,uint256)": {
        "notice": "trader needs to approve Mangrove to let it perform outbound token transfer at the end of the `makerExecute` function Warning: anyone can approve here."
      },
      "maxGettableUnderlying(address,bool,address)": {
        "notice": "Computes maximal maximal redeem capacity (R) and max borrow capacity (B|R) after R has been redeemed returns (R, B|R)"
      },
      "withdrawFromMangrove(address,uint256)": {
        "notice": "withdraws ETH from the bounty vault of the Mangrove. NB: `Mangrove.fund` function need not be called by `this` so is not included here. Warning: this function should not be called internally for msg.sender provision is being checked"
      }
    },
    "version": 1
  },
  "storageLayout": {
    "storage": [
      {
        "astId": 15869,
        "contract": "contracts/Strategies/OfferLogics/MultiUsers/Deployable/OfferProxy.sol:OfferProxy",
        "label": "admin",
        "offset": 0,
        "slot": "0",
        "type": "t_address"
      },
      {
        "astId": 10849,
        "contract": "contracts/Strategies/OfferLogics/MultiUsers/Deployable/OfferProxy.sol:OfferProxy",
        "label": "OFR_GASREQ",
        "offset": 0,
        "slot": "1",
        "type": "t_uint256"
      },
      {
        "astId": 11486,
        "contract": "contracts/Strategies/OfferLogics/MultiUsers/Deployable/OfferProxy.sol:OfferProxy",
        "label": "_offerOwners",
        "offset": 0,
        "slot": "2",
        "type": "t_mapping(t_address,t_mapping(t_address,t_mapping(t_uint256,t_address)))"
      },
      {
        "astId": 11490,
        "contract": "contracts/Strategies/OfferLogics/MultiUsers/Deployable/OfferProxy.sol:OfferProxy",
        "label": "mgvBalanceOf",
        "offset": 0,
        "slot": "3",
        "type": "t_mapping(t_address,t_uint256)"
      },
      {
        "astId": 11496,
        "contract": "contracts/Strategies/OfferLogics/MultiUsers/Deployable/OfferProxy.sol:OfferProxy",
        "label": "tokenBalanceOf",
        "offset": 0,
        "slot": "4",
        "type": "t_mapping(t_address,t_mapping(t_address,t_uint256))"
      },
      {
        "astId": 9562,
        "contract": "contracts/Strategies/OfferLogics/MultiUsers/Deployable/OfferProxy.sol:OfferProxy",
        "label": "referralCode",
        "offset": 0,
        "slot": "5",
        "type": "t_uint16"
      }
    ],
    "types": {
      "t_address": {
        "encoding": "inplace",
        "label": "address",
        "numberOfBytes": "20"
      },
      "t_mapping(t_address,t_mapping(t_address,t_mapping(t_uint256,t_address)))": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => mapping(address => mapping(uint256 => address)))",
        "numberOfBytes": "32",
        "value": "t_mapping(t_address,t_mapping(t_uint256,t_address))"
      },
      "t_mapping(t_address,t_mapping(t_address,t_uint256))": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => mapping(address => uint256))",
        "numberOfBytes": "32",
        "value": "t_mapping(t_address,t_uint256)"
      },
      "t_mapping(t_address,t_mapping(t_uint256,t_address))": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => mapping(uint256 => address))",
        "numberOfBytes": "32",
        "value": "t_mapping(t_uint256,t_address)"
      },
      "t_mapping(t_address,t_uint256)": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => uint256)",
        "numberOfBytes": "32",
        "value": "t_uint256"
      },
      "t_mapping(t_uint256,t_address)": {
        "encoding": "mapping",
        "key": "t_uint256",
        "label": "mapping(uint256 => address)",
        "numberOfBytes": "32",
        "value": "t_address"
      },
      "t_uint16": {
        "encoding": "inplace",
        "label": "uint16",
        "numberOfBytes": "2"
      },
      "t_uint256": {
        "encoding": "inplace",
        "label": "uint256",
        "numberOfBytes": "32"
      }
    }
  }
}